Guile NEWS --- history of user-visible changes.
Copyright (C) 1996-2011 Free Software Foundation, Inc.
See the end for copying conditions.

Please send Guile bug reports to bug-guile@gnu.org.


Changes in 2.0.1 (since 2.0.0):

* Notable changes

** guile.m4 supports linking with rpath
    
The GUILE_FLAGS macro now sets GUILE_LIBS and GUILE_LTLIBS, which
include appropriate directives to the linker to include libguile-2.0.so
in the runtime library lookup path.

** `begin' expands macros in its body before other expressions

This enables support for programs like the following:

    (begin
      (define even?
        (lambda (x)
          (or (= x 0) (odd? (- x 1)))))
      (define-syntax odd?
        (syntax-rules ()
          ((odd? x) (not (even? x)))))
      (even? 10))

** REPL reader usability enhancements

The REPL now flushes input after a read error, which should prevent one
error from causing other errors.  The REPL also now interprets comments
as whitespace.

** REPL output has configurable width

The REPL now defaults to output with the current terminal's width, in
columns.  See "Debug Commands" in the manual for more information on
the ,width command.

** Better C access to the module system

Guile now has convenient C accessors to look up variables or values in
modules and their public interfaces.  See `scm_c_public_ref' and friends
in "Accessing Modules from C" in the manual.

** Added `scm_call_5', `scm_call_6'
    
See "Fly Evaluation" in the manual.

** Added `scm_from_latin1_keyword', `scm_from_utf8_keyword'
    
See "Keyword Procedures" in the manual, for more.  Note that
`scm_from_locale_keyword' should not be used when the name is a C string
constant.

** R6RS unicode and string I/O work

Added efficient implementations of `get-string-n' and `get-string-n!'
for binary ports.  Exported `current-input-port', `current-output-port'
and `current-error-port' from `(rnrs io ports)', and enhanced support
for transcoders.

** Added `pointer->scm', `scm->pointer' to `(system foreign)'
    
These procedure are useful if one needs to pass and receive SCM values
to and from foreign functions.  See "Foreign Variables" in the manual,
for more.
    
** Added `heap-allocated-since-gc' to `(gc-stats)'

Also fixed the long-standing bug in the REPL `,stat' command.
    
** Add `on-error' REPL option
    
This option controls what happens when an error occurs at the REPL, and
defaults to `debug', indicating that Guile should enter the debugger.
Other values include `report', which will simply print a backtrace
without entering the debugger.  See "System Commands" in the manual.

** Enforce immutability of string literals

Attempting to mutate a string literal now causes a runtime error.
    
** Fix pthread redirection

Guile 2.0.0 shipped with headers that, if configured with pthread
support, would re-define `pthread_create', `pthread_join', and other API
to redirect to the BDW-GC wrappers, `GC_pthread_create', etc.  This was
unintended, and not necessary: because threads must enter Guile with
scm_with_guile, Guile can handle thread registration itself, without
needing to make the GC aware of all threads.  This oversight has been
fixed.

** `with-continuation-barrier' now unwinds on `quit'

A throw to `quit' in a continuation barrier will cause Guile to exit.
Before, it would do so before unwinding to the barrier, which would
prevent cleanup handlers from running.  This has been fixed so that it
exits only after unwinding.
    
** `string->pointer' and `pointer->string' have optional encoding arg
    
This allows users of the FFI to more easily deal in strings with
particular (non-locale) encodings, like "utf-8".  See "Void Pointers and
Byte Access" in the manual, for more.

** R6RS fixnum arithmetic optimizations
    
R6RS fixnum operations are are still slower than generic arithmetic,
however.

** New procedure: `define-inlinable'
    
See "Inlinable Procedures" in the manual, for more.

** New procedure: `exact-integer-sqrt'

See "Integer Operations" in the manual, for more.
    
** "Extended read syntax" for symbols parses better

In #{foo}# symbols, backslashes are now treated as escapes, as the
symbol-printing code intended.  Additionally, "\x" within #{foo}# is now
interpreted as starting an R6RS hex escape.  This is backward compatible
because the symbol printer would never produce a "\x" before.  The
printer also works better too.

** Added --force-auto-compile option

This allows a user to invalidate the auto-compilation cache.  It's
usually not needed.  See "Compilation" in the manual, for a discussion.

* Manual updates

** GOOPS documentation updates

** New man page

Thanks to Mark Harig for improvements to guile.1.

** SRFI-23 documented

The humble `error' SRFI now has an entry in the manual.

* New modules

** `(ice-9 binary-ports)': XXX, in the manual
** `(ice-9 eval-string)': "Fly Evaluation", in the manual
    
* Bugs fixed

** Fixed iconv_t memory leak on close-port
** Fixed some leaks with weak hash tables
** Export `vhash-delq' and `vhash-delv' from `(ice-9 vlist)'
** `after-gc-hook' works again
** `define-record-type' now allowed in nested contexts
** `exact-integer-sqrt' now handles large integers correctly
** Fixed C extension examples in manual
** `vhash-delete' honors HASH argument
** Make `locale-digit-grouping' more robust
** Default exception printer robustness fixes
** Fix presence of non-I CPPFLAGS in `guile-2.0.pc'
** `read' updates line/column numbers when reading SCSH block comments
** Fix imports of multiple custom interfaces of same module
** Fix encoding scanning for non-seekable ports
** Fix `setter' when called with a non-setter generic
** Fix f32 and f64 bytevectors to not accept rationals
** Fix description of the R6RS `finite?' in manual
** Quotient, remainder and modulo accept inexact integers again
** Fix `continue' within `while' to take zero arguments
** Fix alignment for structures in FFI
** Fix port-filename of stdin, stdout, stderr to match the docs
** Fix weak hash table-related bug in `define-wrapped-pointer-type'
** Fix partial continuation application with pending procedure calls
** scm_{to,from}_locale_string use current locale, not current ports
** Fix thread cleanup, by using a pthread_key destructor
** Fix `quit' at the REPL
** Fix a failure to sync regs in vm bytevector ops
** Fix (texinfo reflection) to handle nested structures like syntax patterns
** Fix stexi->html double translation
** Fix tree-il->scheme fix for <prompt>
** Fix compilation of <prompt> in <fix> in single-value context
** Fix race condition in ensure-writable-dir
** Fix error message on ,disassemble "non-procedure"
** Fix prompt and abort with the boot evaluator
** Fix `procedure->pointer' for functions returning `void'
** Fix error reporting in dynamic-pointer
** Fix problems detecting coding: in block comments
** Fix duplicate load-path and load-compiled-path in compilation environment
** Add fallback read(2) suppport for .go files if mmap(2) unavailable
** Fix c32vector-set!, c64vector-set!
** Fix mistakenly deprecated read syntax for uniform complex vectors
** Fix parsing of exact numbers with negative exponents
** Ignore SIGPIPE in (system repl server)
** Fix optional second arg to R6RS log function
** Fix R6RS `assert' to return true value.
** Fix fencepost error when seeking in bytevector input ports



Changes in 2.0.0 (changes since the 1.8.x series):

* New modules (see the manual for details)

** `(srfi srfi-18)', more sophisticated multithreading support
** `(srfi srfi-27)', sources of random bits
** `(srfi srfi-38)', External Representation for Data With Shared Structure
** `(srfi srfi-42)', eager comprehensions
** `(srfi srfi-45)', primitives for expressing iterative lazy algorithms
** `(srfi srfi-67)', compare procedures
** `(ice-9 i18n)', internationalization support
** `(ice-9 futures)', fine-grain parallelism
** `(rnrs bytevectors)', the R6RS bytevector API
** `(rnrs io ports)', a subset of the R6RS I/O port API
** `(system xref)', a cross-referencing facility (FIXME undocumented)
** `(ice-9 vlist)', lists with constant-time random access; hash lists
** `(system foreign)', foreign function interface
** `(sxml match)', a pattern matcher for SXML
** `(srfi srfi-9 gnu)', extensions to the SRFI-9 record library
** `(system vm coverage)', a line-by-line code coverage library
** `(web uri)', URI data type, parser, and unparser
** `(web http)', HTTP header parsers and unparsers
** `(web request)', HTTP request data type, reader, and writer
** `(web response)', HTTP response data type, reader, and writer
** `(web server)', Generic HTTP server
** `(ice-9 poll)', a poll wrapper
** `(web server http)', HTTP-over-TCP web server implementation

** Replaced `(ice-9 match)' with Alex Shinn's compatible, hygienic matcher.
    
Guile's copy of Andrew K. Wright's `match' library has been replaced by
a compatible hygienic implementation by Alex Shinn.  It is now
documented, see "Pattern Matching" in the manual.

Compared to Andrew K. Wright's `match', the new `match' lacks
`match-define', `match:error-control', `match:set-error-control',
`match:error', `match:set-error', and all structure-related procedures.

** Imported statprof, SSAX, and texinfo modules from Guile-Lib
    
The statprof statistical profiler, the SSAX XML toolkit, and the texinfo
toolkit from Guile-Lib have been imported into Guile proper. See
"Standard Library" in the manual for more details.

** Integration of lalr-scm, a parser generator

Guile has included Dominique Boucher's fine `lalr-scm' parser generator
as `(system base lalr)'. See "LALR(1) Parsing" in the manual, for more
information.

* Changes to the stand-alone interpreter

** Guile now can compile Scheme to bytecode for a custom virtual machine.

Compiled code loads much faster than Scheme source code, and runs around
3 or 4 times as fast, generating much less garbage in the process.

** Evaluating Scheme code does not use the C stack.

Besides when compiling Guile itself, Guile no longer uses a recursive C
function as an evaluator. This obviates the need to check the C stack
pointer for overflow. Continuations still capture the C stack, however.

** New environment variables: GUILE_LOAD_COMPILED_PATH,
   GUILE_SYSTEM_LOAD_COMPILED_PATH

GUILE_LOAD_COMPILED_PATH is for compiled files what GUILE_LOAD_PATH is
for source files. It is a different path, however, because compiled
files are architecture-specific. GUILE_SYSTEM_LOAD_COMPILED_PATH is like
GUILE_SYSTEM_PATH.

** New read-eval-print loop (REPL) implementation

Running Guile with no arguments drops the user into the new REPL.  See
"Using Guile Interactively" in the manual, for more information.

** Remove old Emacs interface

Guile had an unused `--emacs' command line argument that was supposed to
help when running Guile inside Emacs. This option has been removed, and
the helper functions `named-module-use!' and `load-emacs-interface' have
been deprecated.
    
** Add `(system repl server)' module and `--listen' command-line argument
    
The `(system repl server)' module exposes procedures to listen on
sockets for connections, and serve REPLs to those clients.  The --listen
command-line argument allows any Guile program to thus be remotely
debuggable.

See "Invoking Guile" for more information on `--listen'.

** Command line additions

The guile binary now supports a new switch "-x", which can be used to
extend the list of filename extensions tried when loading files
(%load-extensions).

** New reader options: `square-brackets', `r6rs-hex-escapes',
   `hungry-eol-escapes'

The reader supports a new option (changeable via `read-options'),
`square-brackets', which instructs it to interpret square brackets as
parentheses.  This option is on by default.

When the new `r6rs-hex-escapes' reader option is enabled, the reader
will recognize string escape sequences as defined in R6RS.  R6RS string
escape sequences are incompatible with Guile's existing escapes, though,
so this option is off by default.

Additionally, Guile follows the R6RS newline escaping rules when the
`hungry-eol-escapes' option is enabled.

See "String Syntax" in the manual, for more information.

** Function profiling and tracing at the REPL
    
The `,profile FORM' REPL meta-command can now be used to statistically
profile execution of a form, to see which functions are taking the most
time. See `,help profile' for more information.

Similarly, `,trace FORM' traces all function applications that occur
during the execution of `FORM'. See `,help trace' for more information.

** Recursive debugging REPL on error

When Guile sees an error at the REPL, instead of saving the stack, Guile
will directly enter a recursive REPL in the dynamic context of the
error. See "Error Handling" in the manual, for more information.

A recursive REPL is the same as any other REPL, except that it
has been augmented with debugging information, so that one can inspect
the context of the error. The debugger has been integrated with the REPL
via a set of debugging meta-commands.

For example, one may access a backtrace with `,backtrace' (or
`,bt'). See "Interactive Debugging" in the manual, for more
information.

** New `guile-tools' commands: `compile', `disassemble'

Pass the `--help' command-line option to these commands for more
information.

** Guile now adds its install prefix to the LTDL_LIBRARY_PATH

Users may now install Guile to nonstandard prefixes and just run
`/path/to/bin/guile', instead of also having to set LTDL_LIBRARY_PATH to
include `/path/to/lib'.

** Guile's Emacs integration is now more keyboard-friendly

Backtraces may now be disclosed with the keyboard in addition to the
mouse.

** Load path change: search in version-specific paths before site paths
    
When looking for a module, Guile now searches first in Guile's
version-specific path (the library path), *then* in the site dir. This
allows Guile's copy of SSAX to override any Guile-Lib copy the user has
installed. Also it should cut the number of `stat' system calls by half,
in the common case.

** Value history in the REPL on by default

By default, the REPL will save computed values in variables like `$1',
`$2', and the like. There are programmatic and interactive interfaces to
control this. See "Value History" in the manual, for more information.

** Readline tab completion for arguments

When readline is enabled, tab completion works for arguments too, not
just for the operator position.

** Expression-oriented readline history
    
Guile's readline history now tries to operate on expressions instead of
input lines.  Let us know what you think!

** Interactive Guile follows GNU conventions

As recommended by the GPL, Guile now shows a brief copyright and
warranty disclaimer on startup, along with pointers to more information.

* Changes to Scheme functions and syntax

** Support for R6RS libraries

The `library' and `import' forms from the latest Scheme report have been
added to Guile, in such a way that R6RS libraries share a namespace with
Guile modules. R6RS modules may import Guile modules, and are available
for Guile modules to import via use-modules and all the rest. See "R6RS
Libraries" in the manual for more information.

** Implementations of R6RS libraries

Guile now has implementations for all of the libraries defined in the
R6RS. Thanks to Julian Graham for this excellent hack. See "R6RS
Standard Libraries" in the manual for a full list of libraries.

** Partial R6RS compatibility

Guile now has enough support for R6RS to run a reasonably large subset
of R6RS programs.

Guile is not fully R6RS compatible. Many incompatibilities are simply
bugs, though some parts of Guile will remain R6RS-incompatible for the
foreseeable future. See "R6RS Incompatibilities" in the manual, for more
information.

Please contact bug-guile@gnu.org if you have found an issue not
mentioned in that compatibility list.
    
** New implementation of `primitive-eval'

Guile's `primitive-eval' is now implemented in Scheme. Actually there is
still a C evaluator, used when building a fresh Guile to interpret the
compiler, so we can compile eval.scm. Thereafter all calls to
primitive-eval are implemented by VM-compiled code.

This allows all of Guile's procedures, be they interpreted or compiled,
to execute on the same stack, unifying multiple-value return semantics,
providing for proper tail recursion between interpreted and compiled
code, and simplifying debugging.

As part of this change, the evaluator no longer mutates the internal
representation of the code being evaluated in a thread-unsafe manner.

There are two negative aspects of this change, however. First, Guile
takes a lot longer to compile now. Also, there is less debugging
information available for debugging interpreted code. We hope to improve
both of these situations.

There are many changes to the internal C evalator interface, but all
public interfaces should be the same. See the ChangeLog for details. If
we have inadvertantly changed an interface that you were using, please
contact bug-guile@gnu.org.

** Procedure removed: `the-environment'

This procedure was part of the interpreter's execution model, and does
not apply to the compiler.

** No more `local-eval'

`local-eval' used to exist so that one could evaluate code in the
lexical context of a function. Since there is no way to get the lexical
environment any more, as that concept has no meaning for the compiler,
and a different meaning for the interpreter, we have removed the
function.

If you think you need `local-eval', you should probably implement your
own metacircular evaluator. It will probably be as fast as Guile's
anyway.

** Scheme source files will now be compiled automatically.

If a compiled .go file corresponding to a .scm file is not found or is
not fresh, the .scm file will be compiled on the fly, and the resulting
.go file stored away. An advisory note will be printed on the console.

Note that this mechanism depends on the timestamp of the .go file being
newer than that of the .scm file; if the .scm or .go files are moved
after installation, care should be taken to preserve their original
timestamps.

Auto-compiled files will be stored in the $XDG_CACHE_HOME/guile/ccache
directory, where $XDG_CACHE_HOME defaults to ~/.cache. This directory
will be created if needed.

To inhibit automatic compilation, set the GUILE_AUTO_COMPILE environment
variable to 0, or pass --no-auto-compile on the Guile command line.

** New POSIX procedures: `getrlimit' and `setrlimit'

Note however that the interface of these functions is likely to change
in the next prerelease.

** New POSIX procedure: `getsid'

Scheme binding for the `getsid' C library call.

** New POSIX procedure: `getaddrinfo'

Scheme binding for the `getaddrinfo' C library function.

** Multicast socket options

Support was added for the IP_MULTICAST_TTL and IP_MULTICAST_IF socket
options.  See "Network Sockets and Communication" in the manual, for
more information.

** `recv!', `recvfrom!', `send', `sendto' now deal in bytevectors

These socket procedures now take bytevectors as arguments, instead of
strings.  There is some deprecated string support, however.

** New GNU procedures: `setaffinity' and `getaffinity'.
    
See "Processes" in the manual, for more information.

** New procedures: `compose', `negate', and `const'

See "Higher-Order Functions" in the manual, for more information.

** New procedure in `(oops goops)': `method-formals'

** New procedures in (ice-9 session): `add-value-help-handler!',
   `remove-value-help-handler!', `add-name-help-handler!'
   `remove-name-help-handler!', `procedure-arguments'

The value and name help handlers provide some minimal extensibility to
the help interface. Guile-lib's `(texinfo reflection)' uses them, for
example, to make stexinfo help documentation available. See those
procedures' docstrings for more information.

`procedure-arguments' describes the arguments that a procedure can take,
combining arity and formals. For example:

  (procedure-arguments resolve-interface)
  => ((required . (name)) (rest . args))

Additionally, `module-commentary' is now publically exported from
`(ice-9 session).

** Removed: `procedure->memoizing-macro', `procedure->syntax'

These procedures created primitive fexprs for the old evaluator, and are
no longer supported. If you feel that you need these functions, you
probably need to write your own metacircular evaluator (which will
probably be as fast as Guile's, anyway).

** New language: ECMAScript

Guile now ships with one other high-level language supported,
ECMAScript. The goal is to support all of version 3.1 of the standard,
but not all of the libraries are there yet. This support is not yet
documented; ask on the mailing list if you are interested.

** New language: Brainfuck

Brainfuck is a toy language that closely models Turing machines. Guile's
brainfuck compiler is meant to be an example of implementing other
languages. See the manual for details, or
http://en.wikipedia.org/wiki/Brainfuck for more information about the
Brainfuck language itself.

** New language: Elisp

Guile now has an experimental Emacs Lisp compiler and runtime. You can
now switch to Elisp at the repl: `,language elisp'. All kudos to Daniel
Kraft and Brian Templeton, and all bugs to bug-guile@gnu.org.

** Better documentation infrastructure for macros

It is now possible to introspect on the type of a macro, e.g.
syntax-rules, identifier-syntax, etc, and extract information about that
macro, such as the syntax-rules patterns or the defmacro arguments.
`(texinfo reflection)' takes advantage of this to give better macro
documentation.

** Support for arbitrary procedure metadata

Building on its support for docstrings, Guile now supports multiple
docstrings, adding them to the tail of a compiled procedure's
properties. For example:

  (define (foo)
    "one"
    "two"
    3)
  (procedure-properties foo)
  => ((name . foo) (documentation . "one") (documentation . "two"))

Also, vectors of pairs are now treated as additional metadata entries:

  (define (bar)
    #((quz . #f) (docstring . "xyzzy"))
    3)
  (procedure-properties bar)
  => ((name . bar) (quz . #f) (docstring . "xyzzy"))

This allows arbitrary literals to be embedded as metadata in a compiled
procedure.

** The psyntax expander now knows how to interpret the @ and @@ special
   forms.

** The psyntax expander is now hygienic with respect to modules.

Free variables in a macro are scoped in the module that the macro was
defined in, not in the module the macro is used in. For example, code
like this works now:

   (define-module (foo) #:export (bar))
   (define (helper x) ...)
   (define-syntax bar
     (syntax-rules () ((_ x) (helper x))))

   (define-module (baz) #:use-module (foo))
   (bar qux)

It used to be you had to export `helper' from `(foo)' as well.
Thankfully, this has been fixed.

** Support for version information in Guile's `module' form
    
Guile modules now have a `#:version' field.  See "R6RS Version
References", "General Information about Modules", "Using Guile Modules",
and "Creating Guile Modules" in the manual for more information.

** Support for renaming bindings on module export
    
Wherever Guile accepts a symbol as an argument to specify a binding to
export, it now also accepts a pair of symbols, indicating that a binding
should be renamed on export. See "Creating Guile Modules" in the manual
for more information.

** New procedure: `module-export-all!'

This procedure exports all current and future bindings from a module.
Use as `(module-export-all! (current-module))'.
    
** New procedure `reload-module', and `,reload' REPL command
    
See "Module System Reflection" and "Module Commands" in the manual, for
more information.

** `eval-case' has been deprecated, and replaced by `eval-when'.

The semantics of `eval-when' are easier to understand. See "Eval When"
in the manual, for more information.

** Guile is now more strict about prohibiting definitions in expression
   contexts.

Although previous versions of Guile accepted it, the following
expression is not valid, in R5RS or R6RS:

  (if test (define foo 'bar) (define foo 'baz))

In this specific case, it would be better to do:

  (define foo (if test 'bar 'baz))

It is possible to circumvent this restriction with e.g.
`(module-define! (current-module) 'foo 'baz)'.  Contact the list if you
have any questions.

** Support for `letrec*'

Guile now supports `letrec*', a recursive lexical binding operator in
which the identifiers are bound in order. See "Local Bindings" in the
manual, for more details.

** Internal definitions now expand to `letrec*'

Following the R6RS, internal definitions now expand to letrec* instead
of letrec. The following program is invalid for R5RS, but valid for
R6RS:

    (define (foo)
      (define bar 10)
      (define baz (+ bar 20))
      baz)

    ;; R5RS and Guile <= 1.8:
    (foo) => Unbound variable: bar
    ;; R6RS and Guile >= 2.0:
    (foo) => 30

This change should not affect correct R5RS programs, or programs written
in earlier Guile dialects.

** Macro expansion produces structures instead of s-expressions

In the olden days, macroexpanding an s-expression would yield another
s-expression. Though the lexical variables were renamed, expansions of
core forms like `if' and `begin' were still non-hygienic, as they relied
on the toplevel definitions of `if' et al being the conventional ones.

The solution is to expand to structures instead of s-expressions. There
is an `if' structure, a `begin' structure, a `toplevel-ref' structure,
etc. The expander already did this for compilation, producing Tree-IL
directly; it has been changed now to do so when expanding for the
evaluator as well.

** Defmacros must now produce valid Scheme expressions.

It used to be that defmacros could unquote in Scheme values, as a way of
supporting partial evaluation, and avoiding some hygiene issues. For
example:

  (define (helper x) ...)
  (define-macro (foo bar)
    `(,helper ,bar))

Assuming this macro is in the `(baz)' module, the direct translation of
this code would be:

  (define (helper x) ...)
  (define-macro (foo bar)
    `((@@ (baz) helper) ,bar))

Of course, one could just use a hygienic macro instead:

  (define-syntax foo
    (syntax-rules ()
      ((_ bar) (helper bar))))

** Guile's psyntax now supports docstrings and internal definitions.

The following Scheme is not strictly legal:

  (define (foo)
    "bar"
    (define (baz) ...)
    (baz))

However its intent is fairly clear. Guile interprets "bar" to be the
docstring of `foo', and the definition of `baz' is still in definition
context.

** Support for settable identifier syntax

Following the R6RS, "variable transformers" are settable
identifier-syntax. See "Identifier macros" in the manual, for more
information.
    
** syntax-case treats `_' as a placeholder
    
Following R6RS, a `_' in a syntax-rules or syntax-case pattern matches
anything, and binds no pattern variables. Unlike the R6RS, Guile also
permits `_' to be in the literals list for a pattern.

** Macros need to be defined before their first use.

It used to be that with lazy memoization, this might work:

  (define (foo x)
    (ref x))
  (define-macro (ref x) x)
  (foo 1) => 1

But now, the body of `foo' is interpreted to mean a call to the toplevel
`ref' function, instead of a macro expansion. The solution is to define
macros before code that uses them.

** Functions needed by macros at expand-time need to be present at
   expand-time.

For example, this code will work at the REPL:

  (define (double-helper x) (* x x))
  (define-macro (double-literal x) (double-helper x))
  (double-literal 2) => 4

But it will not work when a file is compiled, because the definition of
`double-helper' is not present at expand-time. The solution is to wrap
the definition of `double-helper' in `eval-when':

  (eval-when (load compile eval)
    (define (double-helper x) (* x x)))
  (define-macro (double-literal x) (double-helper x))
  (double-literal 2) => 4

See the documentation for eval-when for more information.

** `macroexpand' produces structures, not S-expressions.

Given the need to maintain referential transparency, both lexically and
modular, the result of expanding Scheme expressions is no longer itself
an s-expression. If you want a human-readable approximation of the
result of `macroexpand', call `tree-il->scheme' from `(language
tree-il)'.

** Removed function: `macroexpand-1'

It is unclear how to implement `macroexpand-1' with syntax-case, though
PLT Scheme does prove that it is possible.

** New reader macros: #' #` #, #,@

These macros translate, respectively, to `syntax', `quasisyntax',
`unsyntax', and `unsyntax-splicing'. See the R6RS for more information.
These reader macros may be overridden by `read-hash-extend'.

** Incompatible change to #'

Guile did have a #' hash-extension, by default, which just returned the
subsequent datum: #'foo => foo. In the unlikely event that anyone
actually used this, this behavior may be reinstated via the
`read-hash-extend' mechanism.

** `unquote' and `unquote-splicing' accept multiple expressions
    
As per the R6RS, these syntax operators can now accept any number of
expressions to unquote.

** Scheme expresssions may be commented out with #;

#; comments out an entire expression.  See SRFI-62 or the R6RS for more
information.

** Prompts: Delimited, composable continuations

Guile now has prompts as part of its primitive language. See "Prompts"
in the manual, for more information.

Expressions entered in at the REPL, or from the command line, are
surrounded by a prompt with the default prompt tag.

** `make-stack' with a tail-called procedural narrowing argument no longer
   works (with compiled procedures)

It used to be the case that a captured stack could be narrowed to select
calls only up to or from a certain procedure, even if that procedure
already tail-called another procedure. This was because the debug
information from the original procedure was kept on the stack.

Now with the new compiler, the stack only contains active frames from
the current continuation. A narrow to a procedure that is not in the
stack will result in an empty stack. To fix this, narrow to a procedure
that is active in the current continuation, or narrow to a specific
number of stack frames.

** Backtraces through compiled procedures only show procedures that are
   active in the current continuation

Similarly to the previous issue, backtraces in compiled code may be
different from backtraces in interpreted code. There are no semantic
differences, however. Please mail bug-guile@gnu.org if you see any
deficiencies with Guile's backtraces.

** `positions' reader option enabled by default
    
This change allows primitive-load without --auto-compile to also
propagate source information through the expander, for better errors and
to let macros know their source locations.  The compiler was already
turning it on anyway.

** New macro: `current-source-location'

The macro returns the current source location (to be documented).

** syntax-rules and syntax-case macros now propagate source information
   through to the expanded code

This should result in better backtraces.

** The currying behavior of `define' has been removed.

Before, `(define ((f a) b) (* a b))' would translate to

  (define f (lambda (a) (lambda (b) (* a b))))

Now a syntax error is signaled, as this syntax is not supported by
default. Use the `(ice-9 curried-definitions)' module to get back the
old behavior.

** New procedure, `define!'

`define!' is a procedure that takes two arguments, a symbol and a value,
and binds the value to the symbol in the current module. It's useful to
programmatically make definitions in the current module, and is slightly
less verbose than `module-define!'.

** All modules have names now

Before, you could have anonymous modules: modules without names. Now,
because of hygiene and macros, all modules have names. If a module was
created without a name, the first time `module-name' is called on it, a
fresh name will be lazily generated for it.

** The module namespace is now separate from the value namespace

It was a little-known implementation detail of Guile's module system
that it was built on a single hierarchical namespace of values -- that
if there was a module named `(foo bar)', then in the module named
`(foo)' there was a binding from `bar' to the `(foo bar)' module.

This was a neat trick, but presented a number of problems. One problem
was that the bindings in a module were not apparent from the module
itself; perhaps the `(foo)' module had a private binding for `bar', and
then an external contributor defined `(foo bar)'. In the end there can
be only one binding, so one of the two will see the wrong thing, and
produce an obtuse error of unclear provenance.

Also, the public interface of a module was also bound in the value
namespace, as `%module-public-interface'. This was a hack from the early
days of Guile's modules.

Both of these warts have been fixed by the addition of fields in the
`module' data type. Access to modules and their interfaces from the
value namespace has been deprecated, and all accessors use the new
record accessors appropriately.

When Guile is built with support for deprecated code, as is the default,
the value namespace is still searched for modules and public interfaces,
and a deprecation warning is raised as appropriate.

Finally, to support lazy loading of modules as one used to be able to do
with module binder procedures, Guile now has submodule binders, called
if a given submodule is not found. See boot-9.scm for more information.
    
** New procedures: module-ref-submodule, module-define-submodule,
   nested-ref-module, nested-define-module!, local-ref-module,
   local-define-module

These new accessors are like their bare variants, but operate on
namespaces instead of values.

** The (app modules) module tree is officially deprecated

It used to be that one could access a module named `(foo bar)' via
`(nested-ref the-root-module '(app modules foo bar))'. The `(app
modules)' bit was a never-used and never-documented abstraction, and has
been deprecated. See the following mail for a full discussion:

    http://lists.gnu.org/archive/html/guile-devel/2010-04/msg00168.html

The `%app' binding is also deprecated.

** `module-filename' field and accessor

Modules now record the file in which they are defined. This field may be
accessed with the new `module-filename' procedure.

** Modules load within a known environment

It takes a few procedure calls to define a module, and those procedure
calls need to be in scope. Now we ensure that the current module when
loading a module is one that has the needed bindings, instead of relying
on chance.

** `load' is a macro (!) that resolves paths relative to source file dir
    
The familiar Schem `load' procedure is now a macro that captures the
name of the source file being expanded, and dispatches to the new
`load-in-vicinity'.  Referencing `load' by bare name returns a closure
that embeds the current source file name.

This fix allows `load' of relative paths to be resolved with respect to
the location of the file that calls `load'.

** Many syntax errors have different texts now

Syntax errors still throw to the `syntax-error' key, but the arguments
are often different now. Perhaps in the future, Guile will switch to
using standard SRFI-35 conditions.

** Returning multiple values to compiled code will silently truncate the
   values to the expected number

For example, the interpreter would raise an error evaluating the form,
`(+ (values 1 2) (values 3 4))', because it would see the operands as
being two compound "values" objects, to which `+' does not apply.

The compiler, on the other hand, receives multiple values on the stack,
not as a compound object. Given that it must check the number of values
anyway, if too many values are provided for a continuation, it chooses
to truncate those values, effectively evaluating `(+ 1 3)' instead.

The idea is that the semantics that the compiler implements is more
intuitive, and the use of the interpreter will fade out with time.
This behavior is allowed both by the R5RS and the R6RS.

** Multiple values in compiled code are not represented by compound
   objects

This change may manifest itself in the following situation:

  (let ((val (foo))) (do-something) val)

In the interpreter, if `foo' returns multiple values, multiple values
are produced from the `let' expression. In the compiler, those values
are truncated to the first value, and that first value is returned. In
the compiler, if `foo' returns no values, an error will be raised, while
the interpreter would proceed.

Both of these behaviors are allowed by R5RS and R6RS. The compiler's
behavior is more correct, however. If you wish to preserve a potentially
multiply-valued return, you will need to set up a multiple-value
continuation, using `call-with-values'.

** Defmacros are now implemented in terms of syntax-case.

The practical ramification of this is that the `defmacro?' predicate has
been removed, along with `defmacro-transformer', `macro-table',
`xformer-table', `assert-defmacro?!', `set-defmacro-transformer!' and
`defmacro:transformer'. This is because defmacros are simply macros. If
any of these procedures provided useful facilities to you, we encourage
you to contact the Guile developers.

** Hygienic macros documented as the primary syntactic extension mechanism.

The macro documentation was finally fleshed out with some documentation
on `syntax-rules' and `syntax-case' macros, and other parts of the macro
expansion process. See "Macros" in the manual, for details.

** psyntax is now the default expander

Scheme code is now expanded by default by the psyntax hygienic macro
expander. Expansion is performed completely before compilation or
interpretation.

Notably, syntax errors will be signalled before interpretation begins.
In the past, many syntax errors were only detected at runtime if the
code in question was memoized.

As part of its expansion, psyntax renames all lexically-bound
identifiers. Original identifier names are preserved and given to the
compiler, but the interpreter will see the renamed variables, e.g.,
`x432' instead of `x'.

Note that the psyntax that Guile uses is a fork, as Guile already had
modules before incompatible modules were added to psyntax -- about 10
years ago! Thus there are surely a number of bugs that have been fixed
in psyntax since then. If you find one, please notify bug-guile@gnu.org.

** syntax-rules and syntax-case are available by default.

There is no longer any need to import the `(ice-9 syncase)' module
(which is now deprecated). The expander may be invoked directly via
`macroexpand', though it is normally searched for via the current module
transformer.

Also, the helper routines for syntax-case are available in the default
environment as well: `syntax->datum', `datum->syntax',
`bound-identifier=?', `free-identifier=?', `generate-temporaries',
`identifier?', and `syntax-violation'. See the R6RS for documentation.

** Tail patterns in syntax-case

Guile has pulled in some more recent changes from the psyntax portable
syntax expander, to implement support for "tail patterns". Such patterns
are supported by syntax-rules and syntax-case. This allows a syntax-case
match clause to have ellipses, then a pattern at the end. For example:

  (define-syntax case
    (syntax-rules (else)
      ((_ val match-clause ... (else e e* ...))
       [...])))

Note how there is MATCH-CLAUSE, which is ellipsized, then there is a
tail pattern for the else clause. Thanks to Andreas Rottmann for the
patch, and Kent Dybvig for the code.

** Lexical bindings introduced by hygienic macros may not be referenced
   by nonhygienic macros.

If a lexical binding is introduced by a hygienic macro, it may not be
referenced by a nonhygienic macro. For example, this works:

  (let ()
    (define-macro (bind-x val body)
      `(let ((x ,val)) ,body))
    (define-macro (ref x)
      x)
    (bind-x 10 (ref x)))

But this does not:

  (let ()
    (define-syntax bind-x
      (syntax-rules ()
        ((_ val body) (let ((x val)) body))))
    (define-macro (ref x)
      x)
    (bind-x 10 (ref x)))

It is not normal to run into this situation with existing code. However,
if you have defmacros that expand to hygienic macros, it is possible to
run into situations like this. For example, if you have a defmacro that
generates a `while' expression, the `break' bound by the `while' may not
be visible within other parts of your defmacro. The solution is to port
from defmacros to syntax-rules or syntax-case.

** Macros may no longer be referenced as first-class values.

In the past, you could evaluate e.g. `if', and get its macro value. Now,
expanding this form raises a syntax error.

Macros still /exist/ as first-class values, but they must be
/referenced/ via the module system, e.g. `(module-ref (current-module)
'if)'.

** Macros may now have docstrings.

`object-documentation' from `(ice-9 documentation)' may be used to
retrieve the docstring, once you have a macro value -- but see the above
note about first-class macros. Docstrings are associated with the syntax
transformer procedures.

** `case-lambda' is now available in the default environment.

The binding in the default environment is equivalent to the one from the
`(srfi srfi-16)' module. Use the srfi-16 module explicitly if you wish
to maintain compatibility with Guile 1.8 and earlier.

** Procedures may now have more than one arity.

This can be the case, for example, in case-lambda procedures. The
arities of compiled procedures may be accessed via procedures from the
`(system vm program)' module; see "Compiled Procedures", "Optional
Arguments", and "Case-lambda" in the manual. 

** Deprecate arity access via (procedure-properties proc 'arity)

Instead of accessing a procedure's arity as a property, use the new
`procedure-minimum-arity' function, which gives the most permissive
arity that the the function has, in the same format as the old arity
accessor.

** `lambda*' and `define*' are now available in the default environment

As with `case-lambda', `(ice-9 optargs)' continues to be supported, for
compatibility purposes. No semantic change has been made (we hope).
Optional and keyword arguments now dispatch via special VM operations,
without the need to cons rest arguments, making them very fast.

** New syntax: define-once

`define-once' is like Lisp's `defvar': it creates a toplevel binding,
but only if one does not exist already.

** New function, `truncated-print', with `format' support

`(ice-9 pretty-print)' now exports `truncated-print', a printer that
will ensure that the output stays within a certain width, truncating the
output in what is hopefully an intelligent manner. See the manual for
more details.

There is a new `format' specifier, `~@y', for doing a truncated
print (as opposed to `~y', which does a pretty-print). See the `format'
documentation for more details.

** Better pretty-printing

Indentation recognizes more special forms, like `syntax-case', and read
macros like `quote' are printed better.

** Passing a number as the destination of `format' is deprecated

The `format' procedure in `(ice-9 format)' now emits a deprecation
warning if a number is passed as its first argument.

Also, it used to be that you could omit passing a port to `format', in
some cases.  This still works, but has been formally deprecated.
    
** SRFI-4 vectors reimplemented in terms of R6RS bytevectors

Guile now implements SRFI-4 vectors using bytevectors. Often when you
have a numeric vector, you end up wanting to write its bytes somewhere,
or have access to the underlying bytes, or read in bytes from somewhere
else. Bytevectors are very good at this sort of thing. But the SRFI-4
APIs are nicer to use when doing number-crunching, because they are
addressed by element and not by byte.

So as a compromise, Guile allows all bytevector functions to operate on
numeric vectors. They address the underlying bytes in the native
endianness, as one would expect.

Following the same reasoning, that it's just bytes underneath, Guile
also allows uniform vectors of a given type to be accessed as if they
were of any type. One can fill a u32vector, and access its elements with
u8vector-ref. One can use f64vector-ref on bytevectors. It's all the
same to Guile.

In this way, uniform numeric vectors may be written to and read from
input/output ports using the procedures that operate on bytevectors.

Calls to SRFI-4 accessors (ref and set functions) from Scheme are now
inlined to the VM instructions for bytevector access.

See "SRFI-4" in the manual, for more information.

** Nonstandard SRFI-4 procedures now available from `(srfi srfi-4 gnu)'

Guile's `(srfi srfi-4)' now only exports those srfi-4 procedures that
are part of the standard. Complex uniform vectors and the
`any->FOOvector' family are now available only from `(srfi srfi-4 gnu)'.

Guile's default environment imports `(srfi srfi-4)', and probably should
import `(srfi srfi-4 gnu)' as well.

See "SRFI-4 Extensions" in the manual, for more information.

** New syntax: include-from-path.

`include-from-path' is like `include', except it looks for its file in
the load path. It can be used to compile other files into a file.

** New syntax: quasisyntax.

`quasisyntax' is to `syntax' as `quasiquote' is to `quote'. See the R6RS
documentation for more information. Thanks to Andre van Tonder for the
implementation.

** `*unspecified*' is identifier syntax
    
`*unspecified*' is no longer a variable, so it is optimized properly by
the compiler, and is not `set!'-able.

** Changes and bugfixes in numerics code

*** Added six new sets of fast quotient and remainder operators

Added six new sets of fast quotient and remainder operator pairs with
different semantics than the R5RS operators.  They support not only
integers, but all reals, including exact rationals and inexact
floating point numbers.

These procedures accept two real numbers N and D, where the divisor D
must be non-zero.  Each set of operators computes an integer quotient
Q and a real remainder R such that N = Q*D + R and |R| < |D|.  They
differ only in how N/D is rounded to produce Q.

`euclidean-quotient' returns the integer Q and `euclidean-remainder'
returns the real R such that N = Q*D + R and 0 <= R < |D|.  `euclidean/'
returns both Q and R, and is more efficient than computing each
separately.  Note that when D > 0, `euclidean-quotient' returns
floor(N/D), and when D < 0 it returns ceiling(N/D).

`centered-quotient', `centered-remainder', and `centered/' are similar
except that the range of remainders is -abs(D/2) <= R < abs(D/2), and
`centered-quotient' rounds N/D to the nearest integer.  Note that these
operators are equivalent to the R6RS integer division operators `div',
`mod', `div-and-mod', `div0', `mod0', and `div0-and-mod0'.

`floor-quotient' and `floor-remainder' compute Q and R, respectively,
where Q has been rounded toward negative infinity.  `floor/' returns
both Q and R, and is more efficient than computing each separately.
Note that when applied to integers, `floor-remainder' is equivalent to
the R5RS integer-only `modulo' operator.  `ceiling-quotient',
`ceiling-remainder', and `ceiling/' are similar except that Q is
rounded toward positive infinity.

For `truncate-quotient', `truncate-remainder', and `truncate/', Q is
rounded toward zero.  Note that when applied to integers,
`truncate-quotient' and `truncate-remainder' are equivalent to the
R5RS integer-only operators `quotient' and `remainder'.

For `round-quotient', `round-remainder', and `round/', Q is rounded to
the nearest integer, with ties going to the nearest even integer.

*** Complex number changes

Guile is now able to represent non-real complex numbers whose
imaginary part is an _inexact_ zero (0.0 or -0.0), per R6RS.
Previously, such numbers were immediately changed into inexact reals.

(real? 0.0+0.0i) now returns #f, per R6RS, although (zero? 0.0+0.0i)
still returns #t, per R6RS.  (= 0 0.0+0.0i) and (= 0.0 0.0+0.0i) are
#t, but the same comparisons using `eqv?' or `equal?' are #f.

Like other non-real numbers, these complex numbers with inexact zero
imaginary part will raise exceptions is passed to procedures requiring
reals, such as `<', `>', `<=', `>=', `min', `max', `positive?',
`negative?', `inf?', `nan?', `finite?', etc.

**** `make-rectangular' changes

scm_make_rectangular `make-rectangular' now returns a real number only
if the imaginary part is an _exact_ 0.  Previously, it would return a
real number if the imaginary part was an inexact zero.

scm_c_make_rectangular now always returns a non-real complex number,
even if the imaginary part is zero.  Previously, it would return a
real number if the imaginary part was zero.

**** `make-polar' changes

scm_make_polar `make-polar' now returns a real number only if the
angle or magnitude is an _exact_ 0.  If the magnitude is an exact 0,
it now returns an exact 0.  Previously, it would return a real
number if the imaginary part was an inexact zero.

scm_c_make_polar now always returns a non-real complex number, even if
the imaginary part is 0.0.  Previously, it would return a real number
if the imaginary part was 0.0.

**** `imag-part' changes

scm_imag_part `imag-part' now returns an exact 0 if applied to an
inexact real number.  Previously it returned an inexact zero in this
case.

*** `eqv?' and `equal?' now compare numbers equivalently

scm_equal_p `equal?' now behaves equivalently to scm_eqv_p `eqv?' for
numeric values, per R5RS.  Previously, equal? worked differently,
e.g. `(equal? 0.0 -0.0)' returned #t but `(eqv? 0.0 -0.0)' returned #f,
and `(equal? +nan.0 +nan.0)' returned #f but `(eqv? +nan.0 +nan.0)'
returned #t.

*** `(equal? +nan.0 +nan.0)' now returns #t

Previously, `(equal? +nan.0 +nan.0)' returned #f, although
`(let ((x +nan.0)) (equal? x x))' and `(eqv? +nan.0 +nan.0)'
both returned #t.  R5RS requires that `equal?' behave like
`eqv?' when comparing numbers.

*** Change in handling products `*' involving exact 0

scm_product `*' now handles exact 0 differently.  A product containing
an exact 0 now returns an exact 0 if and only if the other arguments
are all exact.  An inexact zero is returned if and only if the other
arguments are all finite but not all exact.  If an infinite or NaN
value is present, a NaN value is returned.  Previously, any product
containing an exact 0 yielded an exact 0, regardless of the other
arguments.

*** `expt' and `integer-expt' changes when the base is 0

While `(expt 0 0)' is still 1, and `(expt 0 N)' for N > 0 is still
zero, `(expt 0 N)' for N < 0 is now a NaN value, and likewise for
integer-expt.  This is more correct, and conforming to R6RS, but seems
to be incompatible with R5RS, which would return 0 for all non-zero
values of N.

*** `expt' and `integer-expt' are more generic, less strict

When raising to an exact non-negative integer exponent, `expt' and
`integer-expt' are now able to exponentiate any object that can be
multiplied using `*'.  They can also raise an object to an exact
negative integer power if its reciprocal can be taken using `/'.
In order to allow this, the type of the first argument is no longer
checked when raising to an exact integer power.  If the exponent is 0
or 1, the first parameter is not manipulated at all, and need not
even support multiplication.

*** Infinities are no longer integers, nor rationals

scm_integer_p `integer?' and scm_rational_p `rational?' now return #f
for infinities, per R6RS.  Previously they returned #t for real
infinities.  The real infinities and NaNs are still considered real by
scm_real `real?' however, per R6RS.

*** NaNs are no longer rationals

scm_rational_p `rational?' now returns #f for NaN values, per R6RS.
Previously it returned #t for real NaN values.  They are still
considered real by scm_real `real?' however, per R6RS.

*** `inf?' and `nan?' now throw exceptions for non-reals

The domain of `inf?' and `nan?' is the real numbers.  Guile now signals
an error when a non-real number or non-number is passed to these
procedures.  (Note that NaNs _are_ considered numbers by scheme, despite
their name).

*** `rationalize' bugfixes and changes

Fixed bugs in scm_rationalize `rationalize'.  Previously, it returned
exact integers unmodified, although that was incorrect if the epsilon
was at least 1 or inexact, e.g. (rationalize 4 1) should return 3 per
R5RS and R6RS, but previously it returned 4.  It also now handles
cases involving infinities and NaNs properly, per R6RS.

*** Trigonometric functions now return exact numbers in some cases

scm_sin `sin', scm_cos `cos', scm_tan `tan', scm_asin `asin', scm_acos
`acos', scm_atan `atan', scm_sinh `sinh', scm_cosh `cosh', scm_tanh
`tanh', scm_sys_asinh `asinh', scm_sys_acosh `acosh', and
scm_sys_atanh `atanh' now return exact results in some cases.

*** New procedure: `finite?'

Add scm_finite_p `finite?' from R6RS to guile core, which returns #t
if and only if its argument is neither infinite nor a NaN.  Note that
this is not the same as (not (inf? x)) or (not (infinite? x)), since
NaNs are neither finite nor infinite.

*** Improved exactness handling for complex number parsing

When parsing non-real complex numbers, exactness specifiers are now
applied to each component, as is done in PLT Scheme.  For complex
numbers written in rectangular form, exactness specifiers are applied
to the real and imaginary parts before calling scm_make_rectangular.
For complex numbers written in polar form, exactness specifiers are
applied to the magnitude and angle before calling scm_make_polar.

Previously, exactness specifiers were applied to the number as a whole
_after_ calling scm_make_rectangular or scm_make_polar.

For example, (string->number "#i5.0+0i") now does the equivalent of:

  (make-rectangular (exact->inexact 5.0) (exact->inexact 0))

which yields 5.0+0.0i.  Previously it did the equivalent of:

  (exact->inexact (make-rectangular 5.0 0))

which yielded 5.0.

** Unicode characters

Unicode characters may be entered in octal format via e.g. `#\454', or
created via (integer->char 300). A hex external representation will
probably be introduced at some point.

** Unicode strings

Internally, strings are now represented either in the `latin-1'
encoding, one byte per character, or in UTF-32, with four bytes per
character. Strings manage their own allocation, switching if needed.

Extended characters may be written in a literal string using the
hexadecimal escapes `\xXX', `\uXXXX', or `\UXXXXXX', for 8-bit, 16-bit,
or 24-bit codepoints, respectively, or entered directly in the native
encoding of the port on which the string is read.

** Unicode symbols

One may now use U+03BB (GREEK SMALL LETTER LAMBDA) as an identifier.

** Support for non-ASCII source code files

The default reader now handles source code files for some of the
non-ASCII character encodings, such as UTF-8. A non-ASCII source file
should have an encoding declaration near the top of the file. Also,
there is a new function, `file-encoding', that scans a port for a coding
declaration. See the section of the manual entitled, "Character Encoding
of Source Files".

The pre-1.9.3 reader handled 8-bit clean but otherwise unspecified source
code.  This use is now discouraged.  Binary input and output is
currently supported by opening ports in the ISO-8859-1 locale.

** Source files default to UTF-8.

If source files do not specify their encoding via a `coding:' block,
the default encoding is UTF-8, instead of being taken from the current
locale.

** Interactive Guile installs the current locale.
    
Instead of leaving the user in the "C" locale, running the Guile REPL
installs the current locale.  [FIXME xref?]

** Support for locale transcoding when reading from and writing to ports

Ports now have an associated character encoding, and port read and write
operations do conversion to and from locales automatically. Ports also
have an associated strategy for how to deal with locale conversion
failures.

See the documentation in the manual for the four new support functions,
`set-port-encoding!', `port-encoding', `set-port-conversion-strategy!',
and `port-conversion-strategy'.

** String and SRFI-13 functions can operate on Unicode strings

** Unicode support for SRFI-14 character sets

The default character sets are no longer locale dependent and contain
characters from the whole Unicode range. There is a new predefined
character set, `char-set:designated', which contains all assigned
Unicode characters. There is a new debugging function, `%char-set-dump'.

** Character functions operate on Unicode characters

`char-upcase' and `char-downcase' use default Unicode casing rules.
Character comparisons such as `char<?' and `char-ci<?' now sort based on
Unicode code points.

** Global variables `scm_charnames' and `scm_charnums' are removed

These variables contained the names of control characters and were
used when writing characters.  While these were global, they were
never intended to be public API.  They have been replaced with private
functions.

** EBCDIC support is removed

There was an EBCDIC compile flag that altered some of the character
processing.  It appeared that full EBCDIC support was never completed
and was unmaintained.

** Compile-time warnings

Guile can warn about potentially unbound free variables. Pass the
-Wunbound-variable on the `guile-tools compile' command line, or add
`#:warnings '(unbound-variable)' to your `compile' or `compile-file'
invocation. Warnings are also enabled by default for expressions entered
at the REPL.

Guile can also warn when you pass the wrong number of arguments to a
procedure, with -Warity-mismatch, or `arity-mismatch' in the
`#:warnings' as above.

Other warnings include `-Wunused-variable' and `-Wunused-toplevel', to
warn about unused local or global (top-level) variables, and `-Wformat',
to check for various errors related to the `format' procedure.

** A new `memoize-symbol' evaluator trap has been added.

This trap can be used for efficiently implementing a Scheme code
coverage.

** Duplicate bindings among used modules are resolved lazily.

This slightly improves program startup times.

** New thread cancellation and thread cleanup API

See `cancel-thread', `set-thread-cleanup!', and `thread-cleanup'.

** New threads are in `(guile-user)' by default, not `(guile)'

It used to be that a new thread entering Guile would do so in the
`(guile)' module, unless this was the first time Guile was initialized,
in which case it was `(guile-user)'. This has been fixed to have all
new threads unknown to Guile default to `(guile-user)'.

** New helpers: `print-exception', `set-exception-printer!'

These functions implement an extensible exception printer.  Guile
registers printers for all of the exceptions it throws.  Users may add
their own printers.  There is also `scm_print_exception', for use by C
programs.  Pleasantly, this allows SRFI-35 and R6RS exceptions to be
printed appropriately.

** GOOPS dispatch in scheme

As an implementation detail, GOOPS dispatch is no longer implemented by
special evaluator bytecodes, but rather directly via a Scheme function
associated with an applicable struct. There is some VM support for the
underlying primitives, like `class-of'.

This change will in the future allow users to customize generic function
dispatch without incurring a performance penalty, and allow us to
implement method combinations.

** Applicable struct support

One may now make structs from Scheme that may be applied as procedures.
To do so, make a struct whose vtable is `<applicable-struct-vtable>'.
That struct will be the vtable of your applicable structs; instances of
that new struct are assumed to have the procedure in their first slot.
`<applicable-struct-vtable>' is like Common Lisp's
`funcallable-standard-class'. Likewise there is
`<applicable-struct-with-setter-vtable>', which looks for the setter in
the second slot. This needs to be better documented.

** GOOPS cleanups.

GOOPS had a number of concepts that were relevant to the days of Tcl,
but not any more: operators and entities, mainly. These objects were
never documented, and it is unlikely that they were ever used. Operators
were a kind of generic specific to the Tcl support. Entities were
replaced by applicable structs, mentioned above.

** New struct slot allocation: "hidden"

A hidden slot is readable and writable, but will not be initialized by a
call to make-struct. For example in your layout you would say "ph"
instead of "pw". Hidden slots are useful for adding new slots to a
vtable without breaking existing invocations to make-struct.

** eqv? not a generic

One used to be able to extend `eqv?' as a primitive-generic, but no
more. Because `eqv?' is in the expansion of `case' (via `memv'), which
should be able to compile to static dispatch tables, it doesn't make
sense to allow extensions that would subvert this optimization.

** `inet-ntop' and `inet-pton' are always available.

Guile now use a portable implementation of `inet_pton'/`inet_ntop', so
there is no more need to use `inet-aton'/`inet-ntoa'. The latter
functions are deprecated.

** `getopt-long' parsing errors throw to `quit', not `misc-error'

This change should inhibit backtraces on argument parsing errors.
`getopt-long' has been modified to print out the error that it throws
itself.

** New primitive: `tmpfile'.
    
See "File System" in the manual.

** Random generator state may be serialized to a datum

`random-state->datum' will serialize a random state to a datum, which
may be written out, read back in later, and revivified using
`datum->random-state'.  See "Random" in the manual, for more details.

** Fix random number generator on 64-bit platforms
    
There was a nasty bug on 64-bit platforms in which asking for a random
integer with a range between 2**32 and 2**64 caused a segfault. After
many embarrassing iterations, this was fixed.

** Fast bit operations.

The bit-twiddling operations `ash', `logand', `logior', and `logxor' now
have dedicated bytecodes. Guile is not just for symbolic computation,
it's for number crunching too.

** Faster SRFI-9 record access

SRFI-9 records are now implemented directly on top of Guile's structs,
and their accessors are defined in such a way that normal call-sites
inline to special VM opcodes, while still allowing for the general case
(e.g. passing a record accessor to `apply').

** R6RS block comment support

Guile now supports R6RS nested block comments. The start of a comment is
marked with `#|', and the end with `|#'.

** `guile-2' cond-expand feature

To test if your code is running under Guile 2.0 (or its alpha releases),
test for the `guile-2' cond-expand feature. Like this:

     (cond-expand (guile-2 (eval-when (compile)
                             ;; This must be evaluated at compile time.
                             (fluid-set! current-reader my-reader)))
                  (guile
                           ;; Earlier versions of Guile do not have a
                           ;; separate compilation phase.
                           (fluid-set! current-reader my-reader)))

** New global variables: %load-compiled-path, %load-compiled-extensions

These are analogous to %load-path and %load-extensions.

** New fluid: `%file-port-name-canonicalization'
    
This fluid parameterizes the file names that are associated with file
ports. If %file-port-name-canonicalization is 'absolute, then file names
are canonicalized to be absolute paths. If it is 'relative, then the
name is canonicalized, but any prefix corresponding to a member of
`%load-path' is stripped off. Otherwise the names are passed through
unchanged.

In addition, the `compile-file' and `compile-and-load' procedures bind
%file-port-name-canonicalization to their `#:canonicalization' keyword
argument, which defaults to 'relative. In this way, one might compile
"../module/ice-9/boot-9.scm", but the path that gets residualized into
the .go is "ice-9/boot-9.scm".

** New procedure, `make-promise'

`(make-promise (lambda () foo))' is equivalent to `(delay foo)'.

** `defined?' may accept a module as its second argument

Previously it only accepted internal structures from the evaluator.

** New entry into %guile-build-info: `ccachedir'

** Fix bug in `module-bound?'.

`module-bound?' was returning true if a module did have a local
variable, but one that was unbound, but another imported module bound
the variable. This was an error, and was fixed.

** `(ice-9 syncase)' has been deprecated.

As syntax-case is available by default, importing `(ice-9 syncase)' has
no effect, and will trigger a deprecation warning.

** New readline history functions

The (ice-9 readline) module now provides add-history, read-history,
write-history and clear-history, which wrap the corresponding GNU
History library functions.

** Removed deprecated uniform array procedures:
   dimensions->uniform-array, list->uniform-array, array-prototype

Instead, use make-typed-array, list->typed-array, or array-type,
respectively.

** Deprecate the old `scm-style-repl'

The following bindings from boot-9 are now found in `(ice-9
scm-style-repl)': `scm-style-repl', `error-catching-loop',
`error-catching-repl', `bad-throw', `scm-repl-silent'
`assert-repl-silence', `repl-print-unspecified',
`assert-repl-print-unspecified', `scm-repl-verbose',
`assert-repl-verbosity', `scm-repl-prompt', `set-repl-prompt!', `repl',
`default-pre-unwind-handler', `handle-system-error',

The following bindings have been deprecated, with no replacement:
`pre-unwind-handler-dispatch'.

The following bindings have been totally removed:
`before-signal-stack'.

Deprecated forwarding shims have been installed so that users that
expect these bindings in the main namespace will still work, but receive
a deprecation warning.

** `set-batch-mode?!' replaced by `ensure-batch-mode!'

"Batch mode" is a flag used to tell a program that it is not running
interactively. One usually turns it on after a fork. It may not be
turned off. `ensure-batch-mode!' deprecates the old `set-batch-mode?!',
because it is a better interface, as it can only turn on batch mode, not
turn it off.

** Deprecate `save-stack', `the-last-stack'

It used to be that the way to debug programs in Guile was to capture the
stack at the time of error, drop back to the REPL, then debug that
stack. But this approach didn't compose, was tricky to get right in the
presence of threads, and was not very powerful.

So `save-stack', `stack-saved?', and `the-last-stack' have been moved to
`(ice-9 save-stack)', with deprecated bindings left in the root module.

** `top-repl' has its own module
    
The `top-repl' binding, called with Guile is run interactively, is now
is its own module, `(ice-9 top-repl)'. A deprecated forwarding shim was
left in the default environment.

** `display-error' takes a frame

The `display-error' / `scm_display_error' helper now takes a frame as an
argument instead of a stack. Stacks are still supported in deprecated
builds. Additionally, `display-error' will again source location
information for the error.

** No more `(ice-9 debug)'
    
This module had some debugging helpers that are no longer applicable to
the current debugging model. Importing this module will produce a
deprecation warning. Users should contact bug-guile for support.

** Remove obsolete debug-options

Removed `breakpoints', `trace', `procnames', `indent', `frames',
`maxdepth', and `debug' debug-options.

** `backtrace' debug option on by default

Given that Guile 2.0 can always give you a backtrace, backtraces are now
on by default.

** `turn-on-debugging' deprecated

** Remove obsolete print-options
    
The `source' and `closure-hook' print options are obsolete, and have
been removed.

** Remove obsolete read-options

The "elisp-strings" and "elisp-vectors" read options were unused and
obsolete, so they have been removed.

** Remove eval-options and trap-options

Eval-options and trap-options are obsolete with the new VM and
evaluator.

** Remove (ice-9 debugger) and (ice-9 debugging)

See "Traps" and "Interactive Debugging" in the manual, for information
on their replacements.

** Remove the GDS Emacs integration

See "Using Guile in Emacs" in the manual, for info on how we think you
should use Guile with Emacs.

** Deprecated: `lazy-catch'

`lazy-catch' was a form that captured the stack at the point of a
`throw', but the dynamic state at the point of the `catch'. It was a bit
crazy. Please change to use `catch', possibly with a throw-handler, or
`with-throw-handler'.

** Deprecated: primitive properties

The `primitive-make-property', `primitive-property-set!',
`primitive-property-ref', and `primitive-property-del!' procedures were
crufty and only used to implement object properties, which has a new,
threadsafe implementation.  Use object properties or weak hash tables
instead.

** Deprecated `@bind' syntax

`@bind' was part of an older implementation of the Emacs Lisp language,
and is no longer used.
    
** Miscellaneous other deprecations

`cuserid' has been deprecated, as it only returns 8 bytes of a user's
login.  Use `(passwd:name (getpwuid (geteuid)))' instead.
    
Additionally, the procedures `apply-to-args', `has-suffix?', `scheme-file-suffix'
`get-option', `for-next-option', `display-usage-report',
`transform-usage-lambda', `collect', and `set-batch-mode?!' have all
been deprecated.

** Add support for unbound fluids
    
See `make-unbound-fluid', `fluid-unset!', and `fluid-bound?' in the
manual.

** Add `variable-unset!'
    
See "Variables" in the manual, for more details.

** Last but not least, the `' macro can be used in lieu of `lambda'

* Changes to the C interface

** Guile now uses libgc, the Boehm-Demers-Weiser garbage collector

The semantics of `scm_gc_malloc ()' have been changed, in a
backward-compatible way.  A new allocation routine,
`scm_gc_malloc_pointerless ()', was added.

Libgc is a conservative GC, which we hope will make interaction with C
code easier and less error-prone.

** New procedures: `scm_to_stringn', `scm_from_stringn'
** New procedures: scm_{to,from}_{utf8,latin1}_symbol{n,}
** New procedures: scm_{to,from}_{utf8,utf32,latin1}_string{n,}
    
These new procedures convert to and from string representations in
particular encodings.

Users should continue to use locale encoding for user input, user
output, or interacting with the C library.

Use the Latin-1 functions for ASCII, and for literals in source code.

Use UTF-8 functions for interaction with modern libraries which deal in
UTF-8, and UTF-32 for interaction with utf32-using libraries.

Otherwise, use scm_to_stringn or scm_from_stringn with a specific
encoding.

** New type definitions for `scm_t_intptr' and friends.

`SCM_T_UINTPTR_MAX', `SCM_T_INTPTR_MIN', `SCM_T_INTPTR_MAX',
`SIZEOF_SCM_T_BITS', `scm_t_intptr' and `scm_t_uintptr' are now
available to C. Have fun!

** The GH interface (deprecated in version 1.6, 2001) was removed.

** Internal `scm_i_' functions now have "hidden" linkage with GCC/ELF

This makes these internal functions technically not callable from
application code.

** Functions for handling `scm_option' now no longer require an argument
indicating length of the `scm_t_option' array.

** Procedures-with-setters are now implemented using applicable structs

From a user's perspective this doesn't mean very much. But if, for some
odd reason, you used the SCM_PROCEDURE_WITH_SETTER_P, SCM_PROCEDURE, or
SCM_SETTER macros, know that they're deprecated now. Also, scm_tc7_pws
is gone.

** Remove old evaluator closures

There used to be ranges of typecodes allocated to interpreted data
structures, but that it no longer the case, given that interpreted
procedure are now just regular VM closures. As a result, there is a
newly free tc3, and a number of removed macros. See the ChangeLog for
details.

** Primitive procedures are now VM trampoline procedures

It used to be that there were something like 12 different typecodes
allocated to primitive procedures, each with its own calling convention.
Now there is only one, the gsubr. This may affect user code if you were
defining a procedure using scm_c_make_subr rather scm_c_make_gsubr. The
solution is to switch to use scm_c_make_gsubr. This solution works well
both with the old 1.8 and and with the current 1.9 branch.

Guile's old evaluator used to have special cases for applying "gsubrs",
primitive procedures with specified numbers of required, optional, and
rest arguments. Now, however, Guile represents gsubrs as normal VM
procedures, with appropriate bytecode to parse out the correct number of
arguments, including optional and rest arguments, and then with a
special bytecode to apply the gsubr.

This allows primitive procedures to appear on the VM stack, allowing
them to be accurately counted in profiles. Also they now have more
debugging information attached to them -- their number of arguments, for
example. In addition, the VM can completely inline the application
mechanics, allowing for faster primitive calls.

However there are some changes on the C level. There is no more
`scm_tc7_gsubr' or `scm_tcs_subrs' typecode for primitive procedures, as
they are just VM procedures. Likewise the macros `SCM_GSUBR_TYPE',
`SCM_GSUBR_MAKTYPE', `SCM_GSUBR_REQ', `SCM_GSUBR_OPT', and
`SCM_GSUBR_REST' are gone, as are `SCM_SUBR_META_INFO', `SCM_SUBR_PROPS'
`SCM_SET_SUBR_GENERIC_LOC', and `SCM_SUBR_ARITY_TO_TYPE'.

Perhaps more significantly, `scm_c_make_subr',
`scm_c_make_subr_with_generic', `scm_c_define_subr', and
`scm_c_define_subr_with_generic'. They all operated on subr typecodes,
and there are no more subr typecodes. Use the scm_c_make_gsubr family
instead.

Normal users of gsubrs should not be affected, though, as the
scm_c_make_gsubr family still is the correct way to create primitive
procedures.

** Remove deprecated array C interfaces

Removed the deprecated array functions `scm_i_arrayp',
`scm_i_array_ndim', `scm_i_array_mem', `scm_i_array_v',
`scm_i_array_base', `scm_i_array_dims', and the deprecated macros
`SCM_ARRAYP', `SCM_ARRAY_NDIM', `SCM_ARRAY_CONTP', `SCM_ARRAY_MEM',
`SCM_ARRAY_V', `SCM_ARRAY_BASE', and `SCM_ARRAY_DIMS'.

** Remove unused snarf macros
    
`SCM_DEFINE1', `SCM_PRIMITIVE_GENERIC_1', `SCM_PROC1, and `SCM_GPROC1'
are no more. Use SCM_DEFINE or SCM_PRIMITIVE_GENERIC instead.

** New functions: `scm_call_n', `scm_c_run_hookn'
    
`scm_call_n' applies to apply a function to an array of arguments.
`scm_c_run_hookn' runs a hook with an array of arguments.

** Some SMOB types changed to have static typecodes

Fluids, dynamic states, and hash tables used to be SMOB objects, but now
they have statically allocated tc7 typecodes.

** Preparations for changing SMOB representation

If things go right, we'll be changing the SMOB representation soon. To
that end, we did a lot of cleanups to calls to e.g. SCM_CELL_WORD_2(x) when
the code meant SCM_SMOB_DATA_2(x); user code will need similar changes
in the future. Code accessing SMOBs using SCM_CELL macros was never
correct, but until now things still worked. Users should be aware of
such changes.

** Changed invocation mechanics of applicable SMOBs

Guile's old evaluator used to have special cases for applying SMOB
objects. Now, with the VM, when Guile sees a SMOB, it looks up a VM
trampoline procedure for it, and use the normal mechanics to apply the
trampoline. This simplifies procedure application in the normal,
non-SMOB case.

The upshot is that the mechanics used to apply a SMOB are different from
1.8. Descriptors no longer have `apply_0', `apply_1', `apply_2', and
`apply_3' functions, and the macros SCM_SMOB_APPLY_0 and friends are now
deprecated. Just use the scm_call_0 family of procedures.

** Removed support shlibs for SRFIs 1, 4, 13, 14, and 60

Though these SRFI support libraries did expose API, they encoded a
strange version string into their library names.  That version was never
programmatically exported, so there was no way people could use the
libs.

This was a fortunate oversight, as it allows us to remove the need for
extra, needless shared libraries --- the C support code for SRFIs 4, 13,
and 14 was already in core --- and allow us to incrementally return the
SRFI implementation to Scheme.

** New C function: scm_module_public_interface

This procedure corresponds to Scheme's `module-public-interface'.

** Undeprecate `scm_the_root_module ()'

It's useful to be able to get the root module from C without doing a
full module lookup.

** Inline vector allocation

Instead of having vectors point out into the heap for their data, their
data is now allocated inline to the vector object itself. The same is
true for bytevectors, by default, though there is an indirection
available which should allow for making a bytevector from an existing
memory region.

** New struct constructors that don't involve making lists

`scm_c_make_struct' and `scm_c_make_structv' are new varargs and array
constructors, respectively, for structs. You might find them useful.

** Stack refactor

In Guile 1.8, there were debugging frames on the C stack. Now there is
no more need to explicitly mark the stack in this way, because Guile has
a VM stack that it knows how to walk, which simplifies the C API
considerably. See the ChangeLog for details; the relevant interface is
in libguile/stacks.h. The Scheme API has not been changed significantly.

** Removal of Guile's primitive object system.

There were a number of pieces in `objects.[ch]' that tried to be a
minimal object system, but were never documented, and were quickly
obseleted by GOOPS' merge into Guile proper. So `scm_make_class_object',
`scm_make_subclass_object', `scm_metaclass_standard', and like symbols
from objects.h are no more. In the very unlikely case in which these
were useful to you, we urge you to contact guile-devel.

** No future.

Actually the future is still in the state that it was, is, and ever
shall be, Amen, except that `futures.c' and `futures.h' are no longer a
part of it. These files were experimental, never compiled, and would be
better implemented in Scheme anyway. In the future, that is.

** Deprecate trampolines

There used to be C functions `scm_trampoline_0', `scm_trampoline_1', and
so on. The point was to do some precomputation on the type of the
procedure, then return a specialized "call" procedure. However this
optimization wasn't actually an optimization, so it is now deprecated.
Just use `scm_call_0', etc instead.

** Deprecated `scm_badargsp'

This function is unused in Guile, but was part of its API.

** Better support for Lisp `nil'.

The bit representation of `nil' has been tweaked so that it is now very
efficient to check e.g. if a value is equal to Scheme's end-of-list or
Lisp's nil. Additionally there are a heap of new, specific predicates
like scm_is_null_or_nil.

** Better integration of Lisp `nil'.

`scm_is_boolean', `scm_is_false', and `scm_is_null' all return true now
for Lisp's `nil'. This shouldn't affect any Scheme code at this point,
but when we start to integrate more with Emacs, it is possible that we
break code that assumes that, for example, `(not x)' implies that `x' is
`eq?' to `#f'. This is not a common assumption. Refactoring affected
code to rely on properties instead of identities will improve code
correctness. See "Nil" in the manual, for more details.

** Support for static allocation of strings, symbols, and subrs.

Calls to snarfing CPP macros like SCM_DEFINE macro will now allocate
much of their associated data as static variables, reducing Guile's
memory footprint.

** `scm_stat' has an additional argument, `exception_on_error'
** `scm_primitive_load_path' has an additional argument `exception_on_not_found'

** `scm_set_port_seek' and `scm_set_port_truncate' use the `scm_t_off' type

Previously they would use the `off_t' type, which is fragile since its
definition depends on the application's value for `_FILE_OFFSET_BITS'.

** The `long_long' C type, deprecated in 1.8, has been removed

** Removed deprecated uniform array procedures: scm_make_uve,
   scm_array_prototype, scm_list_to_uniform_array,
   scm_dimensions_to_uniform_array, scm_make_ra, scm_shap2ra, scm_cvref,
   scm_ra_set_contp, scm_aind, scm_raprin1

These functions have been deprecated since early 2005.

* Changes to the distribution

** Guile's license is now LGPLv3+

In other words the GNU Lesser General Public License, version 3 or
later (at the discretion of each person that chooses to redistribute
part of Guile).

** AM_SILENT_RULES

Guile's build is visually quieter, due to the use of Automake 1.11's
AM_SILENT_RULES. Build as `make V=1' to see all of the output.
    
** GOOPS documentation folded into Guile reference manual

GOOPS, Guile's object system, used to be documented in separate manuals.
This content is now included in Guile's manual directly.

** `guile-config' will be deprecated in favor of `pkg-config'

`guile-config' has been rewritten to get its information from
`pkg-config', so this should be a transparent change.  Note however that
guile.m4 has yet to be modified to call pkg-config instead of
guile-config.

** Guile now provides `guile-2.0.pc' instead of `guile-1.8.pc'

Programs that use `pkg-config' to find Guile or one of its Autoconf
macros should now require `guile-2.0' instead of `guile-1.8'.

** New installation directory: $(pkglibdir)/1.9/ccache

If $(libdir) is /usr/lib, for example, Guile will install its .go files
to /usr/lib/guile/1.9/ccache. These files are architecture-specific.

** Parallel installability fixes

Guile now installs its header files to a effective-version-specific
directory, and includes the effective version (e.g. 2.0) in the library
name (e.g. libguile-2.0.so).

This change should be transparent to users, who should detect Guile via
the guile.m4 macro, or the guile-2.0.pc pkg-config file. It will allow
parallel installs for multiple versions of Guile development
environments.

** Dynamically loadable extensions may be placed in a Guile-specific path

Before, Guile only searched the system library paths for extensions
(e.g. /usr/lib), which meant that the names of Guile extensions had to
be globally unique. Installing them to a Guile-specific extensions
directory is cleaner. Use `pkg-config --variable=extensiondir
guile-2.0' to get the location of the extensions directory.

** User Scheme code may be placed in a version-specific path

Before, there was only one way to install user Scheme code to a
version-specific Guile directory: install to Guile's own path,
e.g. /usr/share/guile/2.0. The site directory,
e.g. /usr/share/guile/site, was unversioned. This has been changed to
add a version-specific site directory, e.g. /usr/share/guile/site/2.0,
searched before the global site directory.

** New dependency: libgc

See http://www.hpl.hp.com/personal/Hans_Boehm/gc/, for more information.

** New dependency: GNU libunistring

See http://www.gnu.org/software/libunistring/, for more information. Our
Unicode support uses routines from libunistring.

** New dependency: libffi

See http://sourceware.org/libffi/, for more information.



Changes in 1.8.8 (since 1.8.7)

* Bugs fixed

** Fix possible buffer overruns when parsing numbers
** Avoid clash with system setjmp/longjmp on IA64
** Fix `wrong type arg' exceptions with IPv6 addresses


Changes in 1.8.7 (since 1.8.6)

* New modules (see the manual for details)

** `(srfi srfi-98)', an interface to access environment variables

* Bugs fixed

** Fix compilation with `--disable-deprecated'
** Fix %fast-slot-ref/set!, to avoid possible segmentation fault
** Fix MinGW build problem caused by HAVE_STRUCT_TIMESPEC confusion
** Fix build problem when scm_t_timespec is different from struct timespec
** Fix build when compiled with -Wundef -Werror
** More build fixes for `alphaev56-dec-osf5.1b' (Tru64)
** Build fixes for `powerpc-ibm-aix5.3.0.0' (AIX 5.3)
** With GCC, always compile with `-mieee' on `alpha*' and `sh*'
** Better diagnose broken `(strftime "%z" ...)' in `time.test' (bug #24130)
** Fix parsing of SRFI-88/postfix keywords longer than 128 characters
** Fix reading of complex numbers where both parts are inexact decimals

** Allow @ macro to work with (ice-9 syncase)

Previously, use of the @ macro in a module whose code is being
transformed by (ice-9 syncase) would cause an "Invalid syntax" error.
Now it works as you would expect (giving the value of the specified
module binding).

** Have `scm_take_locale_symbol ()' return an interned symbol (bug #25865)


Changes in 1.8.6 (since 1.8.5)

* New features (see the manual for details)

** New convenience function `scm_c_symbol_length ()'

** Single stepping through code from Emacs

When you use GDS to evaluate Scheme code from Emacs, you can now use
`C-u' to indicate that you want to single step through that code. See
`Evaluating Scheme Code' in the manual for more details.

** New "guile(1)" man page!

* Changes to the distribution

** Automake's `AM_MAINTAINER_MODE' is no longer used

Thus, the `--enable-maintainer-mode' configure option is no longer
available: Guile is now always configured in "maintainer mode".

** `ChangeLog' files are no longer updated

Instead, changes are detailed in the version control system's logs.  See
the top-level `ChangeLog' files for details.


* Bugs fixed

** `symbol->string' now returns a read-only string, as per R5RS
** Fix incorrect handling of the FLAGS argument of `fold-matches'
** `guile-config link' now prints `-L$libdir' before `-lguile'
** Fix memory corruption involving GOOPS' `class-redefinition'
** Fix possible deadlock in `mutex-lock'
** Fix build issue on Tru64 and ia64-hp-hpux11.23 (`SCM_UNPACK' macro)
** Fix build issue on mips, mipsel, powerpc and ia64 (stack direction)
** Fix build issue on hppa2.0w-hp-hpux11.11 (`dirent64' and `readdir64_r')
** Fix build issue on i386-unknown-freebsd7.0 ("break strict-aliasing rules")
** Fix misleading output from `(help rationalize)'
** Fix build failure on Debian hppa architecture (bad stack growth detection)
** Fix `gcd' when called with a single, negative argument.
** Fix `Stack overflow' errors seen when building on some platforms
** Fix bug when `scm_with_guile ()' was called several times from the
   same thread
** The handler of SRFI-34 `with-exception-handler' is now invoked in the
   dynamic environment of the call to `raise'
** Fix potential deadlock in `make-struct'
** Fix compilation problem with libltdl from Libtool 2.2.x
** Fix sloppy bound checking in `string-{ref,set!}' with the empty string


Changes in 1.8.5 (since 1.8.4)

* Infrastructure changes

** Guile repository switched from CVS to Git

The new repository can be accessed using
"git-clone git://git.sv.gnu.org/guile.git", or can be browsed on-line at
http://git.sv.gnu.org/gitweb/?p=guile.git .  See `README' for details.

** Add support for `pkg-config'

See "Autoconf Support" in the manual for details.

* New modules (see the manual for details)

** `(srfi srfi-88)'

* New features (see the manual for details)

** New `postfix' read option, for SRFI-88 keyword syntax
** Some I/O primitives have been inlined, which improves I/O performance
** New object-based traps infrastructure

This is a GOOPS-based infrastructure that builds on Guile's low-level
evaluator trap calls and facilitates the development of debugging
features like single-stepping, breakpoints, tracing and profiling.
See the `Traps' node of the manual for details.

** New support for working on Guile code from within Emacs

Guile now incorporates the `GDS' library (previously distributed
separately) for working on Guile code from within Emacs.  See the
`Using Guile In Emacs' node of the manual for details.
 
* Bugs fixed

** `scm_add_slot ()' no longer segfaults (fixes bug #22369)
** Fixed `(ice-9 match)' for patterns like `((_ ...) ...)'

Previously, expressions like `(match '((foo) (bar)) (((_ ...) ...) #t))'
would trigger an unbound variable error for `match:andmap'.

** `(oop goops describe)' now properly provides the `describe' feature
** Fixed `args-fold' from `(srfi srfi-37)'

Previously, parsing short option names of argument-less options would
lead to a stack overflow.

** `(srfi srfi-35)' is now visible through `cond-expand'
** Fixed type-checking for the second argument of `eval'
** Fixed type-checking for SRFI-1 `partition'
** Fixed `struct-ref' and `struct-set!' on "light structs"
** Honor struct field access rights in GOOPS
** Changed the storage strategy of source properties, which fixes a deadlock
** Allow compilation of Guile-using programs in C99 mode with GCC 4.3 and later
** Fixed build issue for GNU/Linux on IA64
** Fixed build issues on NetBSD 1.6
** Fixed build issue on Solaris 2.10 x86_64
** Fixed build issue with DEC/Compaq/HP's compiler
** Fixed `scm_from_complex_double' build issue on FreeBSD
** Fixed `alloca' build issue on FreeBSD 6
** Removed use of non-portable makefile constructs
** Fixed shadowing of libc's <random.h> on Tru64, which broke compilation
** Make sure all tests honor `$TMPDIR'


Changes in 1.8.4 (since 1.8.3)

* Bugs fixed

** CR (ASCII 0x0d) is (again) recognized as a token delimiter by the reader
** Fixed a segmentation fault which occurred when displaying the
backtrace of a stack with a promise object (made by `delay') in it.
** Make `accept' leave guile mode while blocking
** `scm_c_read ()' and `scm_c_write ()' now type-check their port argument
** Fixed a build problem on AIX (use of func_data identifier)
** Fixed a segmentation fault which occurred when hashx-ref or hashx-set! was
called with an associator proc that returns neither a pair nor #f.
** Secondary threads now always return a valid module for (current-module).
** Avoid MacOS build problems caused by incorrect combination of "64"
system and library calls.
** `guile-snarf' now honors `$TMPDIR'
** `guile-config compile' now reports CPPFLAGS used at compile-time
** Fixed build with Sun Studio (Solaris 9)
** Fixed wrong-type-arg errors when creating zero length SRFI-4
uniform vectors on AIX.
** Fixed a deadlock that occurs upon GC with multiple threads.
** Fixed compile problem with GCC on Solaris and AIX (use of _Complex_I)
** Fixed autotool-derived build problems on AIX 6.1.
** Fixed NetBSD/alpha support
** Fixed MacOS build problem caused by use of rl_get_keymap(_name)

* New modules (see the manual for details)

** `(srfi srfi-69)'

* Documentation fixes and improvements

** Removed premature breakpoint documentation

The features described are not available in the series of 1.8.x
releases, so the documentation was misleading and has been removed.

** More about Guile's default *random-state* variable

** GOOPS: more about how to use `next-method'

* Changes to the distribution

** Corrected a few files that referred incorrectly to the old GPL + special exception licence

In fact Guile since 1.8.0 has been licensed with the GNU Lesser
General Public License, and the few incorrect files have now been
fixed to agree with the rest of the Guile distribution.

** Removed unnecessary extra copies of COPYING*

The distribution now contains a single COPYING.LESSER at its top level.


Changes in 1.8.3 (since 1.8.2)

* New modules (see the manual for details)

** `(srfi srfi-35)'
** `(srfi srfi-37)'

* Bugs fixed

** The `(ice-9 slib)' module now works as expected
** Expressions like "(set! 'x #t)" no longer yield a crash
** Warnings about duplicate bindings now go to stderr
** A memory leak in `make-socket-address' was fixed
** Alignment issues (e.g., on SPARC) in network routines were fixed
** A threading issue that showed up at least on NetBSD was fixed
** Build problems on Solaris and IRIX fixed

* Implementation improvements

** The reader is now faster, which reduces startup time
** Procedures returned by `record-accessor' and `record-modifier' are faster


Changes in 1.8.2 (since 1.8.1):

* New procedures (see the manual for details)

** set-program-arguments
** make-vtable

* Incompatible changes

** The body of a top-level `define' no longer sees the binding being created

In a top-level `define', the binding being created is no longer visible
from the `define' body.  This breaks code like
"(define foo (begin (set! foo 1) (+ foo 1)))", where `foo' is now
unbound in the body.  However, such code was not R5RS-compliant anyway,
per Section 5.2.1.

* Bugs fixed

** Fractions were not `equal?' if stored in unreduced form.
(A subtle problem, since printing a value reduced it, making it work.)
** srfi-60 `copy-bit' failed on 64-bit systems
** "guile --use-srfi" option at the REPL can replace core functions
(Programs run with that option were ok, but in the interactive REPL
the core bindings got priority, preventing SRFI replacements or
extensions.)
** `regexp-exec' doesn't abort() on #\nul in the input or bad flags arg
** `kill' on mingw throws an error for a PID other than oneself
** Procedure names are attached to procedure-with-setters
** Array read syntax works with negative lower bound
** `array-in-bounds?' fix if an array has different lower bounds on each index
** `*' returns exact 0 for "(* inexact 0)"
This follows what it always did for "(* 0 inexact)".
** SRFI-19: Value returned by `(current-time time-process)' was incorrect
** SRFI-19: `date->julian-day' did not account for timezone offset
** `ttyname' no longer crashes when passed a non-tty argument
** `inet-ntop' no longer crashes on SPARC when passed an `AF_INET' address
** Small memory leaks have been fixed in `make-fluid' and `add-history'
** GOOPS: Fixed a bug in `method-more-specific?'
** Build problems on Solaris fixed
** Build problems on HP-UX IA64 fixed
** Build problems on MinGW fixed


Changes in 1.8.1 (since 1.8.0):

* LFS functions are now used to access 64-bit files on 32-bit systems.

* New procedures (see the manual for details)

** primitive-_exit - [Scheme] the-root-module
** scm_primitive__exit - [C]
** make-completion-function - [Scheme] (ice-9 readline)
** scm_c_locale_stringn_to_number - [C]
** scm_srfi1_append_reverse [C]
** scm_srfi1_append_reverse_x [C]
** scm_log - [C]
** scm_log10 - [C]
** scm_exp - [C]
** scm_sqrt - [C]

* Bugs fixed

** Build problems have been fixed on MacOS, SunOS, and QNX.

** `strftime' fix sign of %z timezone offset.

** A one-dimensional array can now be 'equal?' to a vector.

** Structures, records, and SRFI-9 records can now be compared with `equal?'.

** SRFI-14 standard char sets are recomputed upon a successful `setlocale'.

** `record-accessor' and `record-modifier' now have strict type checks.

Record accessor and modifier procedures now throw an error if the
record type of the record they're given is not the type expected.
(Previously accessors returned #f and modifiers silently did nothing).

** It is now OK to use both autoload and use-modules on a given module.

** `apply' checks the number of arguments more carefully on "0 or 1" funcs.

Previously there was no checking on primatives like make-vector that
accept "one or two" arguments.  Now there is.

** The srfi-1 assoc function now calls its equality predicate properly.

Previously srfi-1 assoc would call the equality predicate with the key
last.  According to the SRFI, the key should be first.

** A bug in n-par-for-each and n-for-each-par-map has been fixed.

** The array-set! procedure no longer segfaults when given a bit vector.

** Bugs in make-shared-array have been fixed.

** string<? and friends now follow char<? etc order on 8-bit chars.

** The format procedure now handles inf and nan values for ~f correctly.

** exact->inexact should no longer overflow when given certain large fractions.

** srfi-9 accessor and modifier procedures now have strict record type checks.

This matches the srfi-9 specification.

** (ice-9 ftw) procedures won't ignore different files with same inode number.

Previously the (ice-9 ftw) procedures would ignore any file that had
the same inode number as a file they had already seen, even if that
file was on a different device.


Changes in 1.8.0 (changes since the 1.6.x series):

* Changes to the distribution

** Guile is now licensed with the GNU Lesser General Public License.

** The manual is now licensed with the GNU Free Documentation License.

** Guile now requires GNU MP (http://swox.com/gmp).

Guile now uses the GNU MP library for arbitrary precision arithmetic.

** Guile now has separate private and public configuration headers.

That is, things like HAVE_STRING_H no longer leak from Guile's
headers.

** Guile now provides and uses an "effective" version number.

Guile now provides scm_effective_version and effective-version
functions which return the "effective" version number.  This is just
the normal full version string without the final micro-version number,
so the current effective-version is "1.8".  The effective version
should remain unchanged during a stable series, and should be used for
items like the versioned share directory name
i.e. /usr/share/guile/1.8.

Providing an unchanging version number during a stable release for
things like the versioned share directory can be particularly
important for Guile "add-on" packages, since it provides a directory
that they can install to that won't be changed out from under them
with each micro release during a stable series.

** Thread implementation has changed.

When you configure "--with-threads=null", you will get the usual
threading API (call-with-new-thread, make-mutex, etc), but you can't
actually create new threads.  Also, "--with-threads=no" is now
equivalent to "--with-threads=null".  This means that the thread API
is always present, although you might not be able to create new
threads.

When you configure "--with-threads=pthreads" or "--with-threads=yes",
you will get threads that are implemented with the portable POSIX
threads.  These threads can run concurrently (unlike the previous
"coop" thread implementation), but need to cooperate for things like
the GC.

The default is "pthreads", unless your platform doesn't have pthreads,
in which case "null" threads are used.

See the manual for details, nodes "Initialization", "Multi-Threading",
"Blocking", and others.

** There is the new notion of 'discouraged' features.

This is a milder form of deprecation.

Things that are discouraged should not be used in new code, but it is
OK to leave them in old code for now.  When a discouraged feature is
used, no warning message is printed like there is for 'deprecated'
features.  Also, things that are merely discouraged are nevertheless
implemented efficiently, while deprecated features can be very slow.

You can omit discouraged features from libguile by configuring it with
the '--disable-discouraged' option.

** Deprecation warnings can be controlled at run-time.

(debug-enable 'warn-deprecated) switches them on and (debug-disable
'warn-deprecated) switches them off.
 
** Support for SRFI 61, extended cond syntax for multiple values has
   been added.

This SRFI is always available.

** Support for require-extension, SRFI-55, has been added.

The SRFI-55 special form `require-extension' has been added.  It is
available at startup, and provides a portable way to load Scheme
extensions.  SRFI-55 only requires support for one type of extension,
"srfi"; so a set of SRFIs may be loaded via (require-extension (srfi 1
13 14)).

** New module (srfi srfi-26) provides support for `cut' and `cute'.

The (srfi srfi-26) module is an implementation of SRFI-26 which
provides the `cut' and `cute' syntax.  These may be used to specialize
parameters without currying.

** New module (srfi srfi-31)

This is an implementation of SRFI-31 which provides a special form
`rec' for recursive evaluation.

** The modules (srfi srfi-13), (srfi srfi-14) and (srfi srfi-4) have
   been merged with the core, making their functionality always
   available.

The modules are still available, tho, and you could use them together
with a renaming import, for example.

** Guile no longer includes its own version of libltdl.

The official version is good enough now.

** The --enable-htmldoc option has been removed from 'configure'.

Support for translating the documentation into HTML is now always
provided.  Use 'make html'.

** New module (ice-9 serialize):

(serialize FORM1 ...) and (parallelize FORM1 ...) are useful when you
don't trust the thread safety of most of your program, but where you
have some section(s) of code which you consider can run in parallel to
other sections.  See ice-9/serialize.scm for more information.

** The configure option '--disable-arrays' has been removed.

Support for arrays and uniform numeric arrays is now always included
in Guile.

* Changes to the stand-alone interpreter

** New command line option `-L'.

This option adds a directory to the front of the load path.

** New command line option `--no-debug'.

Specifying `--no-debug' on the command line will keep the debugging
evaluator turned off, even for interactive sessions.

** User-init file ~/.guile is now loaded with the debugging evaluator.

Previously, the normal evaluator would have been used.  Using the
debugging evaluator gives better error messages.

** The '-e' option now 'read's its argument.

This is to allow the new '(@ MODULE-NAME VARIABLE-NAME)' construct to
be used with '-e'.  For example, you can now write a script like

  #! /bin/sh
  exec guile -e '(@ (demo) main)' -s "$0" "$@"
  !#

  (define-module (demo)
    :export (main))

  (define (main args)
    (format #t "Demo: ~a~%" args))


* Changes to Scheme functions and syntax

** Guardians have changed back to their original semantics

Guardians now behave like described in the paper by Dybvig et al.  In
particular, they no longer make guarantees about the order in which
they return objects, and they can no longer be greedy.

They no longer drop cyclic data structures.

The C function scm_make_guardian has been changed incompatibly and no
longer takes the 'greedy_p' argument.

** New function hashx-remove!

This function completes the set of 'hashx' functions.

** The concept of dynamic roots has been factored into continuation
   barriers and dynamic states.

Each thread has a current dynamic state that carries the values of the
fluids.  You can create and copy dynamic states and use them as the
second argument for 'eval'.  See "Fluids and Dynamic States" in the
manual.

To restrict the influence that captured continuations can have on the
control flow, you can errect continuation barriers.  See "Continuation
Barriers" in the manual.

The function call-with-dynamic-root now essentially temporarily
installs a new dynamic state and errects a continuation barrier.

** The default load path no longer includes "." at the end.

Automatically loading modules from the current directory should not
happen by default.  If you want to allow it in a more controlled
manner, set the environment variable GUILE_LOAD_PATH or the Scheme
variable %load-path.

** The uniform vector and array support has been overhauled.

It now complies with SRFI-4 and the weird prototype based uniform
array creation has been deprecated.  See the manual for more details.

Some non-compatible changes have been made: 
 - characters can no longer be stored into byte arrays.
 - strings and bit vectors are no longer considered to be uniform numeric 
   vectors.
 - array-rank throws an error for non-arrays instead of returning zero.
 - array-ref does no longer accept non-arrays when no indices are given.

There is the new notion of 'generalized vectors' and corresponding
procedures like 'generalized-vector-ref'.  Generalized vectors include
strings, bitvectors, ordinary vectors, and uniform numeric vectors.

Arrays use generalized vectors as their storage, so that you still
have arrays of characters, bits, etc.  However, uniform-array-read!
and uniform-array-write can no longer read/write strings and
bitvectors.

** There is now support for copy-on-write substrings, mutation-sharing
   substrings and read-only strings.

Three new procedures are related to this: substring/shared,
substring/copy, and substring/read-only.  See the manual for more
information.

** Backtraces will now highlight the value that caused the error.

By default, these values are enclosed in "{...}", such as in this
example:

    guile> (car 'a)

    Backtrace:
    In current input:
       1: 0* [car {a}]

    <unnamed port>:1:1: In procedure car in expression (car (quote a)):
    <unnamed port>:1:1: Wrong type (expecting pair): a
    ABORT: (wrong-type-arg)

The prefix and suffix used for highlighting can be set via the two new
printer options 'highlight-prefix' and 'highlight-suffix'.  For
example, putting this into ~/.guile will output the bad value in bold
on an ANSI terminal:

    (print-set! highlight-prefix "\x1b[1m")
    (print-set! highlight-suffix "\x1b[22m")


** 'gettext' support for internationalization has been added.

See the manual for details.

** New syntax '@' and '@@':

You can now directly refer to variables exported from a module by
writing

    (@ MODULE-NAME VARIABLE-NAME)

For example (@ (ice-9 pretty-print) pretty-print) will directly access
the pretty-print variable exported from the (ice-9 pretty-print)
module.  You don't need to 'use' that module first.  You can also use
'@' as a target of 'set!', as in (set! (@ mod var) val).

The related syntax (@@ MODULE-NAME VARIABLE-NAME) works just like '@',
but it can also access variables that have not been exported.  It is
intended only for kluges and temporary fixes and for debugging, not
for ordinary code.

** Keyword syntax has been made more disciplined.

Previously, the name of a keyword was read as a 'token' but printed as
a symbol.  Now, it is read as a general Scheme datum which must be a
symbol.

Previously:

    guile> #:12
    #:#{12}#
    guile> #:#{12}#
    #:#{\#{12}\#}#
    guile> #:(a b c)
    #:#{}#
    ERROR: In expression (a b c):
           Unbound variable: a
    guile> #: foo
    #:#{}#
    ERROR: Unbound variable: foo

Now:

    guile> #:12
    ERROR: Wrong type (expecting symbol): 12
    guile> #:#{12}#
    #:#{12}#
    guile> #:(a b c)
    ERROR: Wrong type (expecting symbol): (a b c)
    guile> #: foo
    #:foo

** The printing of symbols that might look like keywords can be
   controlled.

The new printer option 'quote-keywordish-symbols' controls how symbols
are printed that have a colon as their first or last character.  The
default now is to only quote a symbol with #{...}# when the read
option 'keywords' is not '#f'.  Thus:

    guile> (define foo (string->symbol ":foo"))
    guile> (read-set! keywords #f)
    guile> foo
    :foo
    guile> (read-set! keywords 'prefix)
    guile> foo
    #{:foo}#
    guile> (print-set! quote-keywordish-symbols #f)
    guile> foo
    :foo

** 'while' now provides 'break' and 'continue'

break and continue were previously bound in a while loop, but not
documented, and continue didn't quite work properly.  The undocumented
parameter to break which gave a return value for the while has been
dropped.

** 'call-with-current-continuation' is now also available under the name
   'call/cc'.

** The module system now checks for duplicate bindings.

The module system now can check for name conflicts among imported
bindings.

The behavior can be controlled by specifying one or more 'duplicates'
handlers.  For example, to make Guile return an error for every name
collision, write:

(define-module (foo)
  :use-module (bar)
  :use-module (baz)
  :duplicates check)

The new default behavior of the module system when a name collision
has been detected is to

 1. Give priority to bindings marked as a replacement.
 2. Issue a warning (different warning if overriding core binding).
 3. Give priority to the last encountered binding (this corresponds to
     the old behavior).

If you want the old behavior back without replacements or warnings you
can add the line:

  (default-duplicate-binding-handler 'last)

to your .guile init file.

** New define-module option: :replace

:replace works as :export, but, in addition, marks the binding as a
replacement.

A typical example is `format' in (ice-9 format) which is a replacement
for the core binding `format'.

** Adding prefixes to imported bindings in the module system

There is now a new :use-module option :prefix.  It can be used to add
a prefix to all imported bindings.

  (define-module (foo)
    :use-module ((bar) :prefix bar:))

will import all bindings exported from bar, but rename them by adding
the prefix `bar:'.

** Conflicting generic functions can be automatically merged.

When two imported bindings conflict and they are both generic
functions, the two functions can now be merged automatically.  This is
activated with the 'duplicates' handler 'merge-generics'.

** New function: effective-version

Returns the "effective" version number.  This is just the normal full
version string without the final micro-version number.  See "Changes
to the distribution" above.

** New threading functions: parallel, letpar, par-map, and friends

These are convenient ways to run calculations in parallel in new
threads.  See "Parallel forms" in the manual for details.

** New function 'try-mutex'.

This function will attempt to lock a mutex but will return immediately
instead of blocking and indicate failure.

** Waiting on a condition variable can have a timeout.

The function 'wait-condition-variable' now takes a third, optional
argument that specifies the point in time where the waiting should be
aborted.

** New function 'broadcast-condition-variable'.

** New functions 'all-threads' and 'current-thread'.

** Signals and system asyncs work better with threads.

The function 'sigaction' now takes a fourth, optional, argument that
specifies the thread that the handler should run in.  When the
argument is omitted, the handler will run in the thread that called
'sigaction'.

Likewise, 'system-async-mark' takes a second, optional, argument that
specifies the thread that the async should run in.  When it is
omitted, the async will run in the thread that called
'system-async-mark'.

C code can use the new functions scm_sigaction_for_thread and
scm_system_async_mark_for_thread to pass the new thread argument.

When a thread blocks on a mutex, a condition variable or is waiting
for IO to be possible, it will still execute system asyncs.  This can
be used to interrupt such a thread by making it execute a 'throw', for
example.

** The function 'system-async' is deprecated.

You can now pass any zero-argument procedure to 'system-async-mark'.
The function 'system-async' will just return its argument unchanged
now.

** New functions 'call-with-blocked-asyncs' and
   'call-with-unblocked-asyncs'

The expression (call-with-blocked-asyncs PROC) will call PROC and will
block execution of system asyncs for the current thread by one level
while PROC runs.  Likewise, call-with-unblocked-asyncs will call a
procedure and will unblock the execution of system asyncs by one
level for the current thread.

Only system asyncs are affected by these functions.

** The functions 'mask-signals' and 'unmask-signals' are deprecated.

Use 'call-with-blocked-asyncs' or 'call-with-unblocked-asyncs'
instead.  Those functions are easier to use correctly and can be
nested.

** New function 'unsetenv'.

** New macro 'define-syntax-public'.

It works like 'define-syntax' and also exports the defined macro (but
only on top-level).

** There is support for Infinity and NaNs.

Following PLT Scheme, Guile can now work with infinite numbers, and
'not-a-numbers'.

There is new syntax for numbers: "+inf.0" (infinity), "-inf.0"
(negative infinity), "+nan.0" (not-a-number), and "-nan.0" (same as
"+nan.0").  These numbers are inexact and have no exact counterpart.

Dividing by an inexact zero returns +inf.0 or -inf.0, depending on the
sign of the dividend.  The infinities are integers, and they answer #t
for both 'even?' and 'odd?'. The +nan.0 value is not an integer and is
not '=' to itself, but '+nan.0' is 'eqv?' to itself.

For example

    (/ 1 0.0)
    => +inf.0

    (/ 0 0.0)
    => +nan.0

    (/ 0)
    ERROR: Numerical overflow

Two new predicates 'inf?' and 'nan?' can be used to test for the
special values.

** Inexact zero can have a sign.

Guile can now distinguish between plus and minus inexact zero, if your
platform supports this, too.  The two zeros are equal according to
'=', but not according to 'eqv?'.  For example

    (- 0.0)
    => -0.0

    (= 0.0 (- 0.0))
    => #t

    (eqv? 0.0 (- 0.0))
    => #f

** Guile now has exact rationals.

Guile can now represent fractions such as 1/3 exactly.  Computing with
them is also done exactly, of course:

    (* 1/3 3/2)
    => 1/2

** 'floor', 'ceiling', 'round' and 'truncate' now return exact numbers
   for exact arguments.

For example: (floor 2) now returns an exact 2 where in the past it
returned an inexact 2.0.  Likewise, (floor 5/4) returns an exact 1.

** inexact->exact no longer returns only integers.

Without exact rationals, the closest exact number was always an
integer, but now inexact->exact returns the fraction that is exactly
equal to a floating point number.  For example:

    (inexact->exact 1.234)
    => 694680242521899/562949953421312

When you want the old behavior, use 'round' explicitly:

    (inexact->exact (round 1.234))
    => 1

** New function 'rationalize'.

This function finds a simple fraction that is close to a given real
number.  For example (and compare with inexact->exact above):

    (rationalize (inexact->exact 1.234) 1/2000)
    => 58/47

Note that, as required by R5RS, rationalize returns only then an exact
result when both its arguments are exact.

** 'odd?' and 'even?' work also for inexact integers.

Previously, (odd? 1.0) would signal an error since only exact integers
were recognized as integers.  Now (odd? 1.0) returns #t, (odd? 2.0)
returns #f and (odd? 1.5) signals an error.

** Guile now has uninterned symbols.

The new function 'make-symbol' will return an uninterned symbol.  This
is a symbol that is unique and is guaranteed to remain unique.
However, uninterned symbols can not yet be read back in.

Use the new function 'symbol-interned?' to check whether a symbol is
interned or not.

** pretty-print has more options.

The function pretty-print from the (ice-9 pretty-print) module can now
also be invoked with keyword arguments that control things like
maximum output width.  See the manual for details.

** Variables have no longer a special behavior for `equal?'.

Previously, comparing two variables with `equal?' would recursivly
compare their values.  This is no longer done.  Variables are now only
`equal?' if they are `eq?'.

** `(begin)' is now valid.

You can now use an empty `begin' form.  It will yield #<unspecified>
when evaluated and simply be ignored in a definition context.

** Deprecated: procedure->macro

Change your code to use 'define-macro' or r5rs macros.  Also, be aware
that macro expansion will not be done during evaluation, but prior to
evaluation.

** Soft ports now allow a `char-ready?' procedure

The vector argument to `make-soft-port' can now have a length of
either 5 or 6.  (Previously the length had to be 5.)  The optional 6th
element is interpreted as an `input-waiting' thunk -- i.e. a thunk
that returns the number of characters that can be read immediately
without the soft port blocking.

** Deprecated: undefine

There is no replacement for undefine.

** The functions make-keyword-from-dash-symbol and keyword-dash-symbol
   have been discouraged.

They are relics from a time where a keyword like #:foo was used
directly as a Tcl option "-foo" and thus keywords were internally
stored as a symbol with a starting dash.  We now store a symbol
without the dash.

Use symbol->keyword and keyword->symbol instead.

** The `cheap' debug option is now obsolete

Evaluator trap calls are now unconditionally "cheap" - in other words,
they pass a debug object to the trap handler rather than a full
continuation.  The trap handler code can capture a full continuation
by using `call-with-current-continuation' in the usual way, if it so
desires.

The `cheap' option is retained for now so as not to break existing
code which gets or sets it, but setting it now has no effect.  It will
be removed in the next major Guile release.

** Evaluator trap calls now support `tweaking'

`Tweaking' means that the trap handler code can modify the Scheme
expression that is about to be evaluated (in the case of an
enter-frame trap) or the value that is being returned (in the case of
an exit-frame trap).  The trap handler code indicates that it wants to
do this by returning a pair whose car is the symbol 'instead and whose
cdr is the modified expression or return value.

* Changes to the C interface

** The functions scm_hash_fn_remove_x and scm_hashx_remove_x no longer
   take a 'delete' function argument.

This argument makes no sense since the delete function is used to
remove a pair from an alist, and this must not be configurable.

This is an incompatible change.

** The GH interface is now subject to the deprecation mechanism

The GH interface has been deprecated for quite some time but now it is
actually removed from Guile when it is configured with
--disable-deprecated.

See the manual "Transitioning away from GH" for more information.

** A new family of functions for converting between C values and
   Scheme values has been added.

These functions follow a common naming scheme and are designed to be
easier to use, thread-safe and more future-proof than the older
alternatives.

  - int scm_is_* (...)
 
  These are predicates that return a C boolean: 1 or 0.  Instead of
  SCM_NFALSEP, you can now use scm_is_true, for example.

  - <type> scm_to_<type> (SCM val, ...)

  These are functions that convert a Scheme value into an appropriate
  C value.  For example, you can use scm_to_int to safely convert from
  a SCM to an int.

  - SCM scm_from_<type> (<type> val, ...)

  These functions convert from a C type to a SCM value; for example,
  scm_from_int for ints.

There is a huge number of these functions, for numbers, strings,
symbols, vectors, etc.  They are documented in the reference manual in
the API section together with the types that they apply to.

** New functions for dealing with complex numbers in C have been added.

The new functions are scm_c_make_rectangular, scm_c_make_polar,
scm_c_real_part, scm_c_imag_part, scm_c_magnitude and scm_c_angle.
They work like scm_make_rectangular etc but take or return doubles
directly.

** The function scm_make_complex has been discouraged.

Use scm_c_make_rectangular instead.

** The INUM macros have been deprecated.

A lot of code uses these macros to do general integer conversions,
although the macros only work correctly with fixnums.  Use the
following alternatives.

  SCM_INUMP             ->  scm_is_integer or similar
  SCM_NINUMP            ->  !scm_is_integer or similar
  SCM_MAKINUM           ->  scm_from_int or similar
  SCM_INUM              ->  scm_to_int or similar

  SCM_VALIDATE_INUM_*   ->  Do not use these; scm_to_int, etc. will
                            do the validating for you.

** The scm_num2<type> and scm_<type>2num functions and scm_make_real
   have been discouraged.

Use the newer scm_to_<type> and scm_from_<type> functions instead for
new code.  The functions have been discouraged since they don't fit
the naming scheme.

** The 'boolean' macros SCM_FALSEP etc have been discouraged.

They have strange names, especially SCM_NFALSEP, and SCM_BOOLP
evaluates its argument twice.  Use scm_is_true, etc. instead for new
code.

** The macro SCM_EQ_P has been discouraged.

Use scm_is_eq for new code, which fits better into the naming
conventions.

** The macros SCM_CONSP, SCM_NCONSP, SCM_NULLP, and SCM_NNULLP have
   been discouraged.

Use the function scm_is_pair or scm_is_null instead.

** The functions scm_round and scm_truncate have been deprecated and
   are now available as scm_c_round and scm_c_truncate, respectively.

These functions occupy the names that scm_round_number and
scm_truncate_number should have.

** The functions scm_c_string2str, scm_c_substring2str, and
   scm_c_symbol2str have been deprecated.

Use scm_to_locale_stringbuf or similar instead, maybe together with
scm_substring.

** New functions scm_c_make_string, scm_c_string_length,
   scm_c_string_ref, scm_c_string_set_x, scm_c_substring,
   scm_c_substring_shared, scm_c_substring_copy.

These are like scm_make_string, scm_length, etc. but are slightly
easier to use from C.

** The macros SCM_STRINGP, SCM_STRING_CHARS, SCM_STRING_LENGTH,
   SCM_SYMBOL_CHARS, and SCM_SYMBOL_LENGTH have been deprecated.

They export too many assumptions about the implementation of strings
and symbols that are no longer true in the presence of
mutation-sharing substrings and when Guile switches to some form of
Unicode.

When working with strings, it is often best to use the normal string
functions provided by Guile, such as scm_c_string_ref,
scm_c_string_set_x, scm_string_append, etc.  Be sure to look in the
manual since many more such functions are now provided than
previously.

When you want to convert a SCM string to a C string, use the
scm_to_locale_string function or similar instead.  For symbols, use
scm_symbol_to_string and then work with that string.  Because of the
new string representation, scm_symbol_to_string does not need to copy
and is thus quite efficient.

** Some string, symbol and keyword functions have been discouraged.

They don't fit into the uniform naming scheme and are not explicit
about the character encoding.

Replace according to the following table:

    scm_allocate_string       -> scm_c_make_string
    scm_take_str              -> scm_take_locale_stringn 
    scm_take0str              -> scm_take_locale_string
    scm_mem2string            -> scm_from_locale_stringn
    scm_str2string            -> scm_from_locale_string
    scm_makfrom0str           -> scm_from_locale_string
    scm_mem2symbol            -> scm_from_locale_symboln
    scm_mem2uninterned_symbol -> scm_from_locale_stringn + scm_make_symbol
    scm_str2symbol            -> scm_from_locale_symbol

    SCM_SYMBOL_HASH           -> scm_hashq
    SCM_SYMBOL_INTERNED_P     -> scm_symbol_interned_p

    scm_c_make_keyword        -> scm_from_locale_keyword

** The functions scm_keyword_to_symbol and sym_symbol_to_keyword are
   now also available to C code.

** SCM_KEYWORDP and SCM_KEYWORDSYM have been deprecated.

Use scm_is_keyword and scm_keyword_to_symbol instead, but note that
the latter returns the true name of the keyword, not the 'dash name',
as SCM_KEYWORDSYM used to do.

** A new way to access arrays in a thread-safe and efficient way has
   been added.

See the manual, node "Accessing Arrays From C".

** The old uniform vector and bitvector implementations have been
   unceremoniously removed.

This implementation exposed the details of the tagging system of
Guile.  Use the new C API explained in the manual in node "Uniform
Numeric Vectors" and "Bit Vectors", respectively.

The following macros are gone: SCM_UVECTOR_BASE, SCM_SET_UVECTOR_BASE,
SCM_UVECTOR_MAXLENGTH, SCM_UVECTOR_LENGTH, SCM_MAKE_UVECTOR_TAG,
SCM_SET_UVECTOR_LENGTH, SCM_BITVECTOR_P, SCM_BITVECTOR_BASE,
SCM_SET_BITVECTOR_BASE, SCM_BITVECTOR_MAX_LENGTH,
SCM_BITVECTOR_LENGTH, SCM_MAKE_BITVECTOR_TAG,
SCM_SET_BITVECTOR_LENGTH, SCM_BITVEC_REF, SCM_BITVEC_SET,
SCM_BITVEC_CLR.

** The macros dealing with vectors have been deprecated.

Use the new functions scm_is_vector, scm_vector_elements,
scm_vector_writable_elements, etc, or scm_is_simple_vector,
SCM_SIMPLE_VECTOR_REF, SCM_SIMPLE_VECTOR_SET, etc instead.  See the
manual for more details.

Deprecated are SCM_VECTORP, SCM_VELTS, SCM_VECTOR_MAX_LENGTH,
SCM_VECTOR_LENGTH, SCM_VECTOR_REF, SCM_VECTOR_SET, SCM_WRITABLE_VELTS.

The following macros have been removed: SCM_VECTOR_BASE,
SCM_SET_VECTOR_BASE, SCM_MAKE_VECTOR_TAG, SCM_SET_VECTOR_LENGTH,
SCM_VELTS_AS_STACKITEMS, SCM_SETVELTS, SCM_GC_WRITABLE_VELTS.

** Some C functions and macros related to arrays have been deprecated.

Migrate according to the following table:

    scm_make_uve        -> scm_make_typed_array, scm_make_u8vector etc.
    scm_make_ra         -> scm_make_array
    scm_shap2ra         -> scm_make_array
    scm_cvref           -> scm_c_generalized_vector_ref
    scm_ra_set_contp    -> do not use
    scm_aind            -> scm_array_handle_pos
    scm_raprin1         -> scm_display or scm_write

    SCM_ARRAYP          -> scm_is_array
    SCM_ARRAY_NDIM      -> scm_c_array_rank
    SCM_ARRAY_DIMS      -> scm_array_handle_dims
    SCM_ARRAY_CONTP     -> do not use
    SCM_ARRAY_MEM       -> do not use
    SCM_ARRAY_V         -> scm_array_handle_elements or similar
    SCM_ARRAY_BASE      -> do not use

** SCM_CELL_WORD_LOC has been deprecated.

Use the new macro SCM_CELL_OBJECT_LOC instead, which returns a pointer
to a SCM, as opposed to a pointer to a scm_t_bits.

This was done to allow the correct use of pointers into the Scheme
heap.  Previously, the heap words were of type scm_t_bits and local
variables and function arguments were of type SCM, making it
non-standards-conformant to have a pointer that can point to both.

** New macros SCM_SMOB_DATA_2, SCM_SMOB_DATA_3, etc.

These macros should be used instead of SCM_CELL_WORD_2/3 to access the
second and third words of double smobs.  Likewise for
SCM_SET_SMOB_DATA_2 and SCM_SET_SMOB_DATA_3.

Also, there is SCM_SMOB_FLAGS and SCM_SET_SMOB_FLAGS that should be
used to get and set the 16 exra bits in the zeroth word of a smob.

And finally, there is SCM_SMOB_OBJECT and SCM_SMOB_SET_OBJECT for
accesing the first immediate word of a smob as a SCM value, and there
is SCM_SMOB_OBJECT_LOC for getting a pointer to the first immediate
smob word.  Like wise for SCM_SMOB_OBJECT_2, etc.

** New way to deal with non-local exits and re-entries.

There is a new set of functions that essentially do what
scm_internal_dynamic_wind does, but in a way that is more convenient
for C code in some situations.  Here is a quick example of how to
prevent a potential memory leak:

  void
  foo ()
  {
    char *mem;

    scm_dynwind_begin (0);

    mem = scm_malloc (100);
    scm_dynwind_unwind_handler (free, mem, SCM_F_WIND_EXPLICITLY);

    /* MEM would leak if BAR throws an error.
       SCM_DYNWIND_UNWIND_HANDLER frees it nevertheless.  
     */

    bar ();
  
    scm_dynwind_end ();

    /* Because of SCM_F_WIND_EXPLICITLY, MEM will be freed by 
       SCM_DYNWIND_END as well. 
    */
  }

For full documentation, see the node "Dynamic Wind" in the manual.

** New function scm_dynwind_free

This function calls 'free' on a given pointer when a dynwind context
is left.  Thus the call to scm_dynwind_unwind_handler above could be
replaced with simply scm_dynwind_free (mem).

** New functions scm_c_call_with_blocked_asyncs and
   scm_c_call_with_unblocked_asyncs

Like scm_call_with_blocked_asyncs etc. but for C functions.

** New functions scm_dynwind_block_asyncs and scm_dynwind_unblock_asyncs

In addition to scm_c_call_with_blocked_asyncs you can now also use
scm_dynwind_block_asyncs in a 'dynwind context' (see above).  Likewise for
scm_c_call_with_unblocked_asyncs and scm_dynwind_unblock_asyncs.

** The macros SCM_DEFER_INTS, SCM_ALLOW_INTS, SCM_REDEFER_INTS,
   SCM_REALLOW_INTS have been deprecated.

They do no longer fulfill their original role of blocking signal
delivery.  Depending on what you want to achieve, replace a pair of
SCM_DEFER_INTS and SCM_ALLOW_INTS with a dynwind context that locks a
mutex, blocks asyncs, or both.  See node "Critical Sections" in the
manual.

** The value 'scm_mask_ints' is no longer writable.

Previously, you could set scm_mask_ints directly.  This is no longer
possible.  Use scm_c_call_with_blocked_asyncs and
scm_c_call_with_unblocked_asyncs instead.

** New way to temporarily set the current input, output or error ports

C code can now use scm_dynwind_current_<foo>_port in a 'dynwind
context' (see above).  <foo> is one of "input", "output" or "error".

** New way to temporarily set fluids

C code can now use scm_dynwind_fluid in a 'dynwind context' (see
above) to temporarily set the value of a fluid.

** New types scm_t_intmax and scm_t_uintmax.

On platforms that have them, these types are identical to intmax_t and
uintmax_t, respectively.  On other platforms, they are identical to
the largest integer types that Guile knows about.

** The functions scm_unmemocopy and scm_unmemoize have been removed.

You should not have used them.

** Many public #defines with generic names have been made private.

#defines with generic names like HAVE_FOO or SIZEOF_FOO have been made
private or renamed with a more suitable public name.

** The macro SCM_TYP16S has been deprecated.

This macro is not intended for public use.

** The macro SCM_SLOPPY_INEXACTP has been deprecated.

Use scm_is_true (scm_inexact_p (...)) instead.

** The macro SCM_SLOPPY_REALP has been deprecated.

Use scm_is_real instead.

** The macro SCM_SLOPPY_COMPLEXP has been deprecated.

Use scm_is_complex instead.

** Some preprocessor defines have been deprecated.

These defines indicated whether a certain feature was present in Guile
or not.  Going forward, assume that the features are always present.

The macros are: USE_THREADS, GUILE_ISELECT, READER_EXTENSIONS,
DEBUG_EXTENSIONS, DYNAMIC_LINKING.

The following macros have been removed completely: MEMOIZE_LOCALS,
SCM_RECKLESS, SCM_CAUTIOUS.

** The preprocessor define STACK_DIRECTION has been deprecated.

There should be no need to know about the stack direction for ordinary
programs.

** New function: scm_effective_version

Returns the "effective" version number.  This is just the normal full
version string without the final micro-version number.  See "Changes
to the distribution" above.

** The function scm_call_with_new_thread has a new prototype.

Instead of taking a list with the thunk and handler, these two
arguments are now passed directly:

    SCM scm_call_with_new_thread (SCM thunk, SCM handler);

This is an incompatible change.

** New snarfer macro SCM_DEFINE_PUBLIC.

This is like SCM_DEFINE, but also calls scm_c_export for the defined
function in the init section.

** The snarfer macro SCM_SNARF_INIT is now officially supported.

** Garbage collector rewrite.

The garbage collector is cleaned up a lot, and now uses lazy
sweeping. This is reflected in the output of (gc-stats); since cells
are being freed when they are allocated, the cells-allocated field
stays roughly constant.

For malloc related triggers, the behavior is changed. It uses the same
heuristic as the cell-triggered collections.  It may be tuned with the
environment variables GUILE_MIN_YIELD_MALLOC.  This is the percentage
for minimum yield of malloc related triggers. The default is 40.
GUILE_INIT_MALLOC_LIMIT sets the initial trigger for doing a GC. The
default is 200 kb.

Debugging operations for the freelist have been deprecated, along with
the C variables that control garbage collection.  The environment
variables GUILE_MAX_SEGMENT_SIZE, GUILE_INIT_SEGMENT_SIZE_2,
GUILE_INIT_SEGMENT_SIZE_1, and GUILE_MIN_YIELD_2 should be used.

For understanding the memory usage of a GUILE program, the routine
gc-live-object-stats returns an alist containing the number of live
objects for every type.


** The function scm_definedp has been renamed to scm_defined_p

The name scm_definedp is deprecated.

** The struct scm_cell type has been renamed to scm_t_cell

This is in accordance to Guile's naming scheme for types.  Note that
the name scm_cell is now used for a function that allocates and
initializes a new cell (see below).

** New functions for memory management

A new set of functions for memory management has been added since the
old way (scm_must_malloc, scm_must_free, etc) was error prone and
indeed, Guile itself contained some long standing bugs that could
cause aborts in long running programs.

The new functions are more symmetrical and do not need cooperation
from smob free routines, among other improvements.

The new functions are scm_malloc, scm_realloc, scm_calloc, scm_strdup,
scm_strndup, scm_gc_malloc, scm_gc_calloc, scm_gc_realloc,
scm_gc_free, scm_gc_register_collectable_memory, and
scm_gc_unregister_collectable_memory.  Refer to the manual for more
details and for upgrading instructions.

The old functions for memory management have been deprecated.  They
are: scm_must_malloc, scm_must_realloc, scm_must_free,
scm_must_strdup, scm_must_strndup, scm_done_malloc, scm_done_free.

** Declarations of exported features are marked with SCM_API.

Every declaration of a feature that belongs to the exported Guile API
has been marked by adding the macro "SCM_API" to the start of the
declaration.  This macro can expand into different things, the most
common of which is just "extern" for Unix platforms.  On Win32, it can
be used to control which symbols are exported from a DLL.

If you `#define SCM_IMPORT' before including <libguile.h>, SCM_API
will expand into "__declspec (dllimport) extern", which is needed for
linking to the Guile DLL in Windows.

There are also SCM_RL_IMPORT, SCM_SRFI1314_IMPORT, and
SCM_SRFI4_IMPORT, for the corresponding libraries.

** SCM_NEWCELL and SCM_NEWCELL2 have been deprecated.

Use the new functions scm_cell and scm_double_cell instead.  The old
macros had problems because with them allocation and initialization
was separated and the GC could sometimes observe half initialized
cells.  Only careful coding by the user of SCM_NEWCELL and
SCM_NEWCELL2 could make this safe and efficient.

** CHECK_ENTRY, CHECK_APPLY and CHECK_EXIT have been deprecated.

Use the variables scm_check_entry_p, scm_check_apply_p and scm_check_exit_p
instead.

** SRCBRKP has been deprecated.

Use scm_c_source_property_breakpoint_p instead.

** Deprecated: scm_makmacro

Change your code to use either scm_makmmacro or to define macros in
Scheme, using 'define-macro'.

** New function scm_c_port_for_each.

This function is like scm_port_for_each but takes a pointer to a C
function as the callback instead of a SCM value.

** The names scm_internal_select, scm_thread_sleep, and
   scm_thread_usleep have been discouraged.

Use scm_std_select, scm_std_sleep, scm_std_usleep instead.

** The GC can no longer be blocked.

The global flags scm_gc_heap_lock and scm_block_gc have been removed.
The GC can now run (partially) concurrently with other code and thus
blocking it is not well defined.

** Many definitions have been removed that were previously deprecated.

scm_lisp_nil, scm_lisp_t, s_nil_ify, scm_m_nil_ify, s_t_ify,
scm_m_t_ify, s_0_cond, scm_m_0_cond, s_0_ify, scm_m_0_ify, s_1_ify,
scm_m_1_ify, scm_debug_newcell, scm_debug_newcell2,
scm_tc16_allocated, SCM_SET_SYMBOL_HASH, SCM_IM_NIL_IFY, SCM_IM_T_IFY,
SCM_IM_0_COND, SCM_IM_0_IFY, SCM_IM_1_IFY, SCM_GC_SET_ALLOCATED,
scm_debug_newcell, scm_debug_newcell2, SCM_HUP_SIGNAL, SCM_INT_SIGNAL,
SCM_FPE_SIGNAL, SCM_BUS_SIGNAL, SCM_SEGV_SIGNAL, SCM_ALRM_SIGNAL,
SCM_GC_SIGNAL, SCM_TICK_SIGNAL, SCM_SIG_ORD, SCM_ORD_SIG,
SCM_NUM_SIGS, scm_top_level_lookup_closure_var,
*top-level-lookup-closure*, scm_system_transformer, scm_eval_3,
scm_eval2, root_module_lookup_closure, SCM_SLOPPY_STRINGP,
SCM_RWSTRINGP, scm_read_only_string_p, scm_make_shared_substring,
scm_tc7_substring, sym_huh, SCM_VARVCELL, SCM_UDVARIABLEP,
SCM_DEFVARIABLEP, scm_mkbig, scm_big2inum, scm_adjbig, scm_normbig,
scm_copybig, scm_2ulong2big, scm_dbl2big, scm_big2dbl, SCM_FIXNUM_BIT,
SCM_SETCHARS, SCM_SLOPPY_SUBSTRP, SCM_SUBSTR_STR, SCM_SUBSTR_OFFSET,
SCM_LENGTH_MAX, SCM_SETLENGTH, SCM_ROSTRINGP, SCM_ROLENGTH,
SCM_ROCHARS, SCM_ROUCHARS, SCM_SUBSTRP, SCM_COERCE_SUBSTR,
scm_sym2vcell, scm_intern, scm_intern0, scm_sysintern, scm_sysintern0,
scm_sysintern0_no_module_lookup, scm_init_symbols_deprecated,
scm_vector_set_length_x, scm_contregs, scm_debug_info,
scm_debug_frame, SCM_DSIDEVAL, SCM_CONST_LONG, SCM_VCELL,
SCM_GLOBAL_VCELL, SCM_VCELL_INIT, SCM_GLOBAL_VCELL_INIT,
SCM_HUGE_LENGTH, SCM_VALIDATE_STRINGORSUBSTR, SCM_VALIDATE_ROSTRING,
SCM_VALIDATE_ROSTRING_COPY, SCM_VALIDATE_NULLORROSTRING_COPY,
SCM_VALIDATE_RWSTRING, DIGITS, scm_small_istr2int, scm_istr2int,
scm_istr2flo, scm_istring2number, scm_istr2int, scm_istr2flo,
scm_istring2number, scm_vtable_index_vcell, scm_si_vcell, SCM_ECONSP,
SCM_NECONSP, SCM_GLOC_VAR, SCM_GLOC_VAL, SCM_GLOC_SET_VAL,
SCM_GLOC_VAL_LOC, scm_make_gloc, scm_gloc_p, scm_tc16_variable,
SCM_CHARS, SCM_LENGTH, SCM_SET_STRING_CHARS, SCM_SET_STRING_LENGTH.

* Changes to bundled modules

** (ice-9 debug)

Using the (ice-9 debug) module no longer automatically switches Guile
to use the debugging evaluator.  If you want to switch to the
debugging evaluator (which is needed for backtrace information if you
hit an error), please add an explicit "(debug-enable 'debug)" to your
code just after the code to use (ice-9 debug).


Changes since Guile 1.4:

* Changes to the distribution

** A top-level TODO file is included.

** Guile now uses a versioning scheme similar to that of the Linux kernel.

Guile now always uses three numbers to represent the version,
i.e. "1.6.5".  The first number, 1, is the major version number, the
second number, 6, is the minor version number, and the third number,
5, is the micro version number.  Changes in major version number
indicate major changes in Guile.

Minor version numbers that are even denote stable releases, and odd
minor version numbers denote development versions (which may be
unstable).  The micro version number indicates a minor sub-revision of
a given MAJOR.MINOR release.

In keeping with the new scheme, (minor-version) and scm_minor_version
no longer return everything but the major version number.  They now
just return the minor version number.  Two new functions
(micro-version) and scm_micro_version have been added to report the
micro version number.

In addition, ./GUILE-VERSION now defines GUILE_MICRO_VERSION.

** New preprocessor definitions are available for checking versions.

version.h now #defines SCM_MAJOR_VERSION, SCM_MINOR_VERSION, and
SCM_MICRO_VERSION to the appropriate integer values.

** Guile now actively warns about deprecated features.

The new configure option `--enable-deprecated=LEVEL' and the
environment variable GUILE_WARN_DEPRECATED control this mechanism.
See INSTALL and README for more information.

** Guile is much more likely to work on 64-bit architectures.

Guile now compiles and passes "make check" with only two UNRESOLVED GC
cases on Alpha and ia64 based machines now.  Thanks to John Goerzen
for the use of a test machine, and thanks to Stefan Jahn for ia64
patches.

** New functions: setitimer and getitimer.

These implement a fairly direct interface to the libc functions of the
same name.

** The #. reader extension is now disabled by default.

For safety reasons, #. evaluation is disabled by default.  To
re-enable it, set the fluid read-eval? to #t.  For example:

  (fluid-set! read-eval? #t)

but make sure you realize the potential security risks involved.  With
read-eval?  enabled, reading a data file from an untrusted source can
be dangerous.

** New SRFI modules have been added:

SRFI-0 `cond-expand' is now supported in Guile, without requiring
using a module.

(srfi srfi-1) is a library containing many useful pair- and list-processing
  procedures.

(srfi srfi-2) exports and-let*.

(srfi srfi-4) implements homogeneous numeric vector datatypes.

(srfi srfi-6) is a dummy module for now, since guile already provides
  all of the srfi-6 procedures by default: open-input-string,
  open-output-string, get-output-string.

(srfi srfi-8) exports receive.

(srfi srfi-9) exports define-record-type.

(srfi srfi-10) exports define-reader-ctor and implements the reader
  extension #,().

(srfi srfi-11) exports let-values and let*-values.

(srfi srfi-13) implements the SRFI String Library.

(srfi srfi-14) implements the SRFI Character-Set Library.

(srfi srfi-17) implements setter and getter-with-setter and redefines
  some accessor procedures as procedures with getters. (such as car,
  cdr, vector-ref etc.)

(srfi srfi-19) implements the SRFI Time/Date Library.

** New scripts / "executable modules"

Subdirectory "scripts" contains Scheme modules that are packaged to
also be executable as scripts.  At this time, these scripts are available:

     display-commentary
     doc-snarf
     generate-autoload
     punify
     read-scheme-source
     use2dot

See README there for more info.

These scripts can be invoked from the shell with the new program
"guile-tools", which keeps track of installation directory for you.
For example:

     $ guile-tools display-commentary srfi/*.scm

guile-tools is copied to the standard $bindir on "make install".

** New module (ice-9 stack-catch):

stack-catch is like catch, but saves the current state of the stack in
the fluid the-last-stack.  This fluid can be useful when using the
debugger and when re-throwing an error.

** The module (ice-9 and-let*) has been renamed to (ice-9 and-let-star)

This has been done to prevent problems on lesser operating systems
that can't tolerate `*'s in file names.  The exported macro continues
to be named `and-let*', of course.

On systems that support it, there is also a compatibility module named
(ice-9 and-let*).  It will go away in the next release.

** New modules (oop goops) etc.:

  (oop goops)
  (oop goops describe)
  (oop goops save)
  (oop goops active-slot)
  (oop goops composite-slot)

The Guile Object Oriented Programming System (GOOPS) has been
integrated into Guile.  For further information, consult the GOOPS
manual and tutorial in the `doc' directory.

** New module (ice-9 rdelim).

This exports the following procedures which were previously defined
in the default environment:

read-line read-line! read-delimited read-delimited! %read-delimited!
%read-line write-line

For backwards compatibility the definitions are still imported into the
default environment in this version of Guile.  However you should add:

(use-modules (ice-9 rdelim))

to any program which uses the definitions, since this may change in
future.

Alternatively, if guile-scsh is installed, the (scsh rdelim) module
can be used for similar functionality.

** New module (ice-9 rw)

This is a subset of the (scsh rw) module from guile-scsh.  Currently
it defines two procedures:

*** New function: read-string!/partial str [port_or_fdes [start [end]]]

     Read characters from a port or file descriptor into a string STR.
     A port must have an underlying file descriptor -- a so-called
     fport.  This procedure is scsh-compatible and can efficiently read
     large strings.

*** New function: write-string/partial str [port_or_fdes [start [end]]]

     Write characters from a string STR to a port or file descriptor.
     A port must have an underlying file descriptor -- a so-called
     fport.  This procedure is mostly compatible and can efficiently
     write large strings.

** New module (ice-9 match)

This module includes Andrew K. Wright's pattern matcher.  See
ice-9/match.scm for brief description or

    http://www.star-lab.com/wright/code.html

for complete documentation.

** New module (ice-9 buffered-input)

This module provides procedures to construct an input port from an
underlying source of input that reads and returns its input in chunks.
The underlying input source is a Scheme procedure, specified by the
caller, which the port invokes whenever it needs more input.

This is useful when building an input port whose back end is Readline
or a UI element such as the GtkEntry widget.

** Documentation

The reference and tutorial documentation that was previously
distributed separately, as `guile-doc', is now included in the core
Guile distribution.  The documentation consists of the following
manuals.

- The Guile Tutorial (guile-tut.texi) contains a tutorial introduction
  to using Guile.

- The Guile Reference Manual (guile.texi) contains (or is intended to
  contain) reference documentation on all aspects of Guile.

- The GOOPS Manual (goops.texi) contains both tutorial-style and
  reference documentation for using GOOPS, Guile's Object Oriented
  Programming System.

- The Revised^5 Report on the Algorithmic Language Scheme
  (r5rs.texi).

See the README file in the `doc' directory for more details.

** There are a couple of examples in the examples/ directory now.

* Changes to the stand-alone interpreter

** New command line option `--use-srfi'

Using this option, SRFI modules can be loaded on startup and be
available right from the beginning.  This makes programming portable
Scheme programs easier.

The option `--use-srfi' expects a comma-separated list of numbers,
each representing a SRFI number to be loaded into the interpreter
before starting evaluating a script file or the REPL.  Additionally,
the feature identifier for the loaded SRFIs is recognized by
`cond-expand' when using this option.

Example:
$ guile --use-srfi=8,13
guile> (receive (x z) (values 1 2) (+ 1 2))
3
guile> (string-pad "bla" 20)
"                 bla"

** Guile now always starts up in the `(guile-user)' module.

Previously, scripts executed via the `-s' option would run in the
`(guile)' module and the repl would run in the `(guile-user)' module.
Now every user action takes place in the `(guile-user)' module by
default.

* Changes to Scheme functions and syntax

** Character classifiers work for non-ASCII characters.

The predicates `char-alphabetic?', `char-numeric?',
`char-whitespace?', `char-lower?', `char-upper?' and `char-is-both?'
no longer check whether their arguments are ASCII characters.
Previously, a character would only be considered alphabetic when it
was also ASCII, for example.

** Previously deprecated Scheme functions have been removed:

  tag - no replacement.
  fseek - replaced by seek.
  list* - replaced by cons*.

** It's now possible to create modules with controlled environments

Example:

(use-modules (ice-9 safe))
(define m (make-safe-module))
;;; m will now be a module containing only a safe subset of R5RS
(eval '(+ 1 2) m) --> 3
(eval 'load m) --> ERROR: Unbound variable: load

** Evaluation of "()", the empty list, is now an error.

Previously, the expression "()" evaluated to the empty list.  This has
been changed to signal a "missing expression" error.  The correct way
to write the empty list as a literal constant is to use quote: "'()".

** New concept of `Guile Extensions'.

A Guile Extension is just a ordinary shared library that can be linked
at run-time.  We found it advantageous to give this simple concept a
dedicated name to distinguish the issues related to shared libraries
from the issues related to the module system.

*** New function: load-extension

Executing (load-extension lib init) is mostly equivalent to

   (dynamic-call init (dynamic-link lib))

except when scm_register_extension has been called previously.
Whenever appropriate, you should use `load-extension' instead of
dynamic-link and dynamic-call.

*** New C function: scm_c_register_extension

This function registers a initialization function for use by
`load-extension'.  Use it when you don't want specific extensions to
be loaded as shared libraries (for example on platforms that don't
support dynamic linking).

** Auto-loading of compiled-code modules is deprecated.

Guile used to be able to automatically find and link a shared
library to satisfy requests for a module.  For example, the module
`(foo bar)' could be implemented by placing a shared library named
"foo/libbar.so" (or with a different extension) in a directory on the
load path of Guile.

This has been found to be too tricky, and is no longer supported.  The
shared libraries are now called "extensions".  You should now write a
small Scheme file that calls `load-extension' to load the shared
library and initialize it explicitly.

The shared libraries themselves should be installed in the usual
places for shared libraries, with names like "libguile-foo-bar".

For example, place this into a file "foo/bar.scm"

    (define-module (foo bar))

    (load-extension "libguile-foo-bar" "foobar_init")

** Backward incompatible change: eval EXP ENVIRONMENT-SPECIFIER

`eval' is now R5RS, that is it takes two arguments.
The second argument is an environment specifier, i.e. either

  (scheme-report-environment 5)
  (null-environment 5)
  (interaction-environment)

or

  any module.

** The module system has been made more disciplined.

The function `eval' will save and restore the current module around
the evaluation of the specified expression.  While this expression is
evaluated, `(current-module)' will now return the right module, which
is the module specified as the second argument to `eval'.

A consequence of this change is that `eval' is not particularly
useful when you want allow the evaluated code to change what module is
designated as the current module and have this change persist from one
call to `eval' to the next.  The read-eval-print-loop is an example
where `eval' is now inadequate.  To compensate, there is a new
function `primitive-eval' that does not take a module specifier and
that does not save/restore the current module.  You should use this
function together with `set-current-module', `current-module', etc
when you want to have more control over the state that is carried from
one eval to the next.

Additionally, it has been made sure that forms that are evaluated at
the top level are always evaluated with respect to the current module.
Previously, subforms of top-level forms such as `begin', `case',
etc. did not respect changes to the current module although these
subforms are at the top-level as well.

To prevent strange behavior, the forms `define-module',
`use-modules', `use-syntax', and `export' have been restricted to only
work on the top level.  The forms `define-public' and
`defmacro-public' only export the new binding on the top level.  They
behave just like `define' and `defmacro', respectively, when they are
used in a lexical environment.

Also, `export' will no longer silently re-export bindings imported
from a used module.  It will emit a `deprecation' warning and will
cease to perform any re-export in the next version.  If you actually
want to re-export bindings, use the new `re-export' in place of
`export'.  The new `re-export' will not make copies of variables when
rexporting them, as `export' did wrongly.

** Module system now allows selection and renaming of imported bindings

Previously, when using `use-modules' or the `#:use-module' clause in
the `define-module' form, all the bindings (association of symbols to
values) for imported modules were added to the "current module" on an
as-is basis.  This has been changed to allow finer control through two
new facilities: selection and renaming.

You can now select which of the imported module's bindings are to be
visible in the current module by using the `:select' clause.  This
clause also can be used to rename individual bindings.  For example:

  ;; import all bindings no questions asked
  (use-modules (ice-9 common-list))

  ;; import four bindings, renaming two of them;
  ;; the current module sees: every some zonk-y zonk-n
  (use-modules ((ice-9 common-list)
                :select (every some
                         (remove-if     . zonk-y)
			 (remove-if-not . zonk-n))))

You can also programmatically rename all selected bindings using the
`:renamer' clause, which specifies a proc that takes a symbol and
returns another symbol.  Because it is common practice to use a prefix,
we now provide the convenience procedure `symbol-prefix-proc'.  For
example:

  ;; import four bindings, renaming two of them specifically,
  ;; and all four w/ prefix "CL:";
  ;; the current module sees: CL:every CL:some CL:zonk-y CL:zonk-n
  (use-modules ((ice-9 common-list)
                :select (every some
                         (remove-if     . zonk-y)
			 (remove-if-not . zonk-n))
                :renamer (symbol-prefix-proc 'CL:)))

  ;; import four bindings, renaming two of them specifically,
  ;; and all four by upcasing.
  ;; the current module sees: EVERY SOME ZONK-Y ZONK-N
  (define (upcase-symbol sym)
    (string->symbol (string-upcase (symbol->string sym))))

  (use-modules ((ice-9 common-list)
                :select (every some
                         (remove-if     . zonk-y)
			 (remove-if-not . zonk-n))
                :renamer upcase-symbol))

Note that programmatic renaming is done *after* individual renaming.
Also, the above examples show `use-modules', but the same facilities are
available for the `#:use-module' clause of `define-module'.

See manual for more info.

** The semantics of guardians have changed.

The changes are for the most part compatible.  An important criterion
was to keep the typical usage of guardians as simple as before, but to
make the semantics safer and (as a result) more useful.

*** All objects returned from guardians are now properly alive.

It is now guaranteed that any object referenced by an object returned
from a guardian is alive.  It's now impossible for a guardian to
return a "contained" object before its "containing" object.

One incompatible (but probably not very important) change resulting
from this is that it is no longer possible to guard objects that
indirectly reference themselves (i.e. are parts of cycles).  If you do
so accidentally, you'll get a warning.

*** There are now two types of guardians: greedy and sharing.

If you call (make-guardian #t) or just (make-guardian), you'll get a
greedy guardian, and for (make-guardian #f) a sharing guardian.

Greedy guardians are the default because they are more "defensive".
You can only greedily guard an object once.  If you guard an object
more than once, once in a greedy guardian and the rest of times in
sharing guardians, then it is guaranteed that the object won't be
returned from sharing guardians as long as it is greedily guarded
and/or alive.

Guardians returned by calls to `make-guardian' can now take one more
optional parameter, which says whether to throw an error in case an
attempt is made to greedily guard an object that is already greedily
guarded.  The default is true, i.e. throw an error.  If the parameter
is false, the guardian invocation returns #t if guarding was
successful and #f if it wasn't.

Also, since greedy guarding is, in effect, a side-effecting operation
on objects, a new function is introduced: `destroy-guardian!'.
Invoking this function on a guardian renders it unoperative and, if
the guardian is greedy, clears the "greedily guarded" property of the
objects that were guarded by it, thus undoing the side effect.

Note that all this hair is hardly very important, since guardian
objects are usually permanent.

** Continuations created by call-with-current-continuation now accept
any number of arguments, as required by R5RS.

** New function `issue-deprecation-warning'

This function is used to display the deprecation messages that are
controlled by GUILE_WARN_DEPRECATION as explained in the README.

  (define (id x)
    (issue-deprecation-warning "`id' is deprecated.  Use `identity' instead.")
    (identity x))

  guile> (id 1)
  ;; `id' is deprecated.  Use `identity' instead.
  1
  guile> (id 1)
  1

** New syntax `begin-deprecated'

When deprecated features are included (as determined by the configure
option --enable-deprecated), `begin-deprecated' is identical to
`begin'.  When deprecated features are excluded, it always evaluates
to `#f', ignoring the body forms.

** New function `make-object-property'

This function returns a new `procedure with setter' P that can be used
to attach a property to objects.  When calling P as

   (set! (P obj) val)

where `obj' is any kind of object, it attaches `val' to `obj' in such
a way that it can be retrieved by calling P as

    (P obj)

This function will replace procedure properties, symbol properties and
source properties eventually.

** Module (ice-9 optargs) now uses keywords instead of `#&'.

Instead of #&optional, #&key, etc you should now use #:optional,
#:key, etc.  Since #:optional is a keyword, you can write it as just
:optional when (read-set! keywords 'prefix) is active.

The old reader syntax `#&' is still supported, but deprecated.  It
will be removed in the next release.

** New define-module option: pure

Tells the module system not to include any bindings from the root
module.

Example:

(define-module (totally-empty-module)
  :pure)

** New define-module option: export NAME1 ...

Export names NAME1 ...

This option is required if you want to be able to export bindings from
a module which doesn't import one of `define-public' or `export'.

Example:

    (define-module (foo)
      :pure
      :use-module (ice-9 r5rs)
      :export (bar))

    ;;; Note that we're pure R5RS below this point!

    (define (bar)
      ...)

** New function: object->string OBJ

Return a Scheme string obtained by printing a given object.

** New function: port? X

Returns a boolean indicating whether X is a port.  Equivalent to
`(or (input-port? X) (output-port? X))'.

** New function: file-port?

Determines whether a given object is a port that is related to a file.

** New function: port-for-each proc

Apply PROC to each port in the Guile port table in turn.  The return
value is unspecified.  More specifically, PROC is applied exactly once
to every port that exists in the system at the time PORT-FOR-EACH is
invoked.  Changes to the port table while PORT-FOR-EACH is running
have no effect as far as PORT-FOR-EACH is concerned.

** New function: dup2 oldfd newfd

A simple wrapper for the `dup2' system call.  Copies the file
descriptor OLDFD to descriptor number NEWFD, replacing the
previous meaning of NEWFD.  Both OLDFD and NEWFD must be integers.
Unlike for dup->fdes or primitive-move->fdes, no attempt is made
to move away ports which are using NEWFD.  The return value is
unspecified.

** New function: close-fdes fd

A simple wrapper for the `close' system call.  Close file
descriptor FD, which must be an integer.  Unlike close (*note
close: Ports and File Descriptors.), the file descriptor will be
closed even if a port is using it.  The return value is
unspecified.

** New function: crypt password salt

Encrypts `password' using the standard unix password encryption
algorithm.

** New function: chroot path

Change the root directory of the running process to `path'.

** New functions: getlogin, cuserid

Return the login name or the user name of the current effective user
id, respectively.

** New functions: getpriority which who, setpriority which who prio

Get or set the priority of the running process.

** New function: getpass prompt

Read a password from the terminal, first displaying `prompt' and
disabling echoing.

** New function: flock file operation

Set/remove an advisory shared or exclusive lock on `file'.

** New functions: sethostname name, gethostname

Set or get the hostname of the machine the current process is running
on.

** New function: mkstemp! tmpl

mkstemp creates a new unique file in the file system and returns a
new buffered port open for reading and writing to the file.  TMPL
is a string specifying where the file should be created: it must
end with `XXXXXX' and will be changed in place to return the name
of the temporary file.

** New function: open-input-string string

Return an input string port which delivers the characters from
`string'.  This procedure, together with `open-output-string' and
`get-output-string' implements SRFI-6.

** New function: open-output-string

Return an output string port which collects all data written to it.
The data can then be retrieved by `get-output-string'.

** New function: get-output-string

Return the contents of an output string port.

** New function: identity

Return the argument.

** socket, connect, accept etc., now have support for IPv6.  IPv6 addresses
   are represented in Scheme as integers with normal host byte ordering.

** New function: inet-pton family address

Convert a printable string network address into an integer.  Note that
unlike the C version of this function, the result is an integer with
normal host byte ordering.  FAMILY can be `AF_INET' or `AF_INET6'.
e.g.,

    (inet-pton AF_INET "127.0.0.1") => 2130706433
    (inet-pton AF_INET6 "::1") => 1

** New function: inet-ntop family address

Convert an integer network address into a printable string.  Note that
unlike the C version of this function, the input is an integer with
normal host byte ordering.  FAMILY can be `AF_INET' or `AF_INET6'.
e.g.,

    (inet-ntop AF_INET 2130706433) => "127.0.0.1"
    (inet-ntop AF_INET6 (- (expt 2 128) 1)) =>
          ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

** Deprecated: id

Use `identity' instead.

** Deprecated: -1+

Use `1-' instead.

** Deprecated: return-it

Do without it.

** Deprecated: string-character-length

Use `string-length' instead.

** Deprecated: flags

Use `logior' instead.

** Deprecated: close-all-ports-except.

This was intended for closing ports in a child process after a fork,
but it has the undesirable side effect of flushing buffers.
port-for-each is more flexible.

** The (ice-9 popen) module now attempts to set up file descriptors in
the child process from the current Scheme ports, instead of using the
current values of file descriptors 0, 1, and 2 in the parent process.

** Removed function:  builtin-weak-bindings

There is no such concept as a weak binding any more.

** Removed constants:  bignum-radix, scm-line-incrementors

** define-method: New syntax mandatory.

The new method syntax is now mandatory:

(define-method (NAME ARG-SPEC ...) BODY ...)
(define-method (NAME ARG-SPEC ... . REST-ARG) BODY ...)

  ARG-SPEC ::= ARG-NAME | (ARG-NAME TYPE)
  REST-ARG ::= ARG-NAME

If you have old code using the old syntax, import
(oop goops old-define-method) before (oop goops) as in:

  (use-modules (oop goops old-define-method) (oop goops))

** Deprecated function: builtin-variable
   Removed function: builtin-bindings

There is no longer a distinction between builtin or other variables.
Use module system operations for all variables.

** Lazy-catch handlers are no longer allowed to return.

That is, a call to `throw', `error', etc is now guaranteed to not
return.

** Bugfixes for (ice-9 getopt-long)

This module is now tested using test-suite/tests/getopt-long.test.
The following bugs have been fixed:

*** Parsing for options that are specified to have `optional' args now checks
if the next element is an option instead of unconditionally taking it as the
option arg.

*** An error is now thrown for `--opt=val' when the option description
does not specify `(value #t)' or `(value optional)'.  This condition used to
be accepted w/o error, contrary to the documentation.

*** The error message for unrecognized options is now more informative.
It used to be "not a record", an artifact of the implementation.

*** The error message for `--opt' terminating the arg list (no value), when
`(value #t)' is specified, is now more informative.  It used to be "not enough
args".

*** "Clumped" single-char args now preserve trailing string, use it as arg.
The expansion used to be like so:

    ("-abc5d" "--xyz") => ("-a" "-b" "-c" "--xyz")

Note that the "5d" is dropped.  Now it is like so:

    ("-abc5d" "--xyz") => ("-a" "-b" "-c" "5d" "--xyz")

This enables single-char options to have adjoining arguments as long as their
constituent characters are not potential single-char options.

** (ice-9 session) procedure `arity' now works with (ice-9 optargs) `lambda*'

The `lambda*' and derivative forms in (ice-9 optargs) now set a procedure
property `arglist', which can be retrieved by `arity'.  The result is that
`arity' can give more detailed information than before:

Before:

	guile> (use-modules (ice-9 optargs))
	guile> (define* (foo #:optional a b c) a)
	guile> (arity foo)
	0 or more arguments in `lambda*:G0'.

After:

        guile> (arity foo)
        3 optional arguments: `a', `b' and `c'.
        guile> (define* (bar a b #:key c d #:allow-other-keys) a)
        guile> (arity bar)
        2 required arguments: `a' and `b', 2 keyword arguments: `c'
        and `d', other keywords allowed.
        guile> (define* (baz a b #:optional c #:rest r) a)
        guile> (arity baz)
        2 required arguments: `a' and `b', 1 optional argument: `c',
        the rest in `r'.

* Changes to the C interface

** Types have been renamed from scm_*_t to scm_t_*.

This has been done for POSIX sake.  It reserves identifiers ending
with "_t".  What a concept.

The old names are still available with status `deprecated'.

** scm_t_bits (former scm_bits_t) is now a unsigned type.

** Deprecated features have been removed.

*** Macros removed

  SCM_INPORTP, SCM_OUTPORTP SCM_ICHRP, SCM_ICHR, SCM_MAKICHR
  SCM_SETJMPBUF SCM_NSTRINGP SCM_NRWSTRINGP SCM_NVECTORP SCM_DOUBLE_CELLP

*** C Functions removed

  scm_sysmissing scm_tag scm_tc16_flo scm_tc_flo
  scm_fseek - replaced by scm_seek.
  gc-thunk - replaced by after-gc-hook.
  gh_int2scmb - replaced by gh_bool2scm.
  scm_tc_dblr - replaced by scm_tc16_real.
  scm_tc_dblc - replaced by scm_tc16_complex.
  scm_list_star - replaced by scm_cons_star.

** Deprecated: scm_makfromstr

Use scm_mem2string instead.

** Deprecated: scm_make_shared_substring

Explicit shared substrings will disappear from Guile.

Instead, "normal" strings will be implemented using sharing
internally, combined with a copy-on-write strategy.

** Deprecated: scm_read_only_string_p

The concept of read-only strings will disappear in next release of
Guile.

** Deprecated: scm_sloppy_memq, scm_sloppy_memv, scm_sloppy_member

Instead, use scm_c_memq or scm_memq, scm_memv, scm_member.

** New functions: scm_call_0, scm_call_1, scm_call_2, scm_call_3

Call a procedure with the indicated number of arguments.  See "Fly
Evaluation" in the manual.

** New functions: scm_apply_0, scm_apply_1, scm_apply_2, scm_apply_3

Call a procedure with the indicated number of arguments and a list of
further arguments.  See "Fly Evaluation" in the manual.

** New functions: scm_list_1, scm_list_2, scm_list_3, scm_list_4, scm_list_5

Create a list of the given number of elements.  See "List
Constructors" in the manual.

** Renamed function: scm_listify has been replaced by scm_list_n.

** Deprecated macros: SCM_LIST0, SCM_LIST1, SCM_LIST2, SCM_LIST3, SCM_LIST4,
SCM_LIST5, SCM_LIST6, SCM_LIST7, SCM_LIST8, SCM_LIST9.

Use functions scm_list_N instead.

** New function: scm_c_read (SCM port, void *buffer, scm_sizet size)

Used by an application to read arbitrary number of bytes from a port.
Same semantics as libc read, except that scm_c_read only returns less
than SIZE bytes if at end-of-file.

Warning: Doesn't update port line and column counts!

** New function: scm_c_write (SCM port, const void *ptr, scm_sizet size)

Used by an application to write arbitrary number of bytes to an SCM
port.  Similar semantics as libc write.  However, unlike libc
write, scm_c_write writes the requested number of bytes and has no
return value.

Warning: Doesn't update port line and column counts!

** New function: scm_init_guile ()

In contrast to scm_boot_guile, scm_init_guile will return normally
after initializing Guile.  It is not available on all systems, tho.

** New functions: scm_str2symbol, scm_mem2symbol

The function scm_str2symbol takes a const char* pointing to a zero-terminated
field of characters and creates a scheme symbol object from that C string.
The function scm_mem2symbol takes a const char* and a number of characters and
creates a symbol from the characters in that memory area.

** New functions: scm_primitive_make_property
                  scm_primitive_property_ref
                  scm_primitive_property_set_x
                  scm_primitive_property_del_x

These functions implement a new way to deal with object properties.
See libguile/properties.c for their documentation.

** New function: scm_done_free (long size)

This function is the inverse of scm_done_malloc.  Use it to report the
amount of smob memory you free.  The previous method, which involved
calling scm_done_malloc with negative argument, was somewhat
unintuitive (and is still available, of course).

** New function: scm_c_memq (SCM obj, SCM list)

This function provides a fast C level alternative for scm_memq for the case
that the list parameter is known to be a proper list.  The function is a
replacement for scm_sloppy_memq, but is stricter in its requirements on its
list input parameter, since for anything else but a proper list the function's
behaviour is undefined - it may even crash or loop endlessly.  Further, for
the case that the object is not found in the list, scm_c_memq returns #f which
is similar to scm_memq, but different from scm_sloppy_memq's behaviour.

** New functions: scm_remember_upto_here_1, scm_remember_upto_here_2,
scm_remember_upto_here

These functions replace the function scm_remember.

** Deprecated function:  scm_remember

Use one of the new functions scm_remember_upto_here_1,
scm_remember_upto_here_2 or scm_remember_upto_here instead.

** New function: scm_allocate_string

This function replaces the function scm_makstr.

** Deprecated function:  scm_makstr

Use the new function scm_allocate_string instead.

** New global variable scm_gc_running_p introduced.

Use this variable to find out if garbage collection is being executed.  Up to
now applications have used scm_gc_heap_lock to test if garbage collection was
running, which also works because of the fact that up to know only the garbage
collector has set this variable.  But, this is an implementation detail that
may change.  Further, scm_gc_heap_lock is not set throughout gc, thus the use
of this variable is (and has been) not fully safe anyway.

** New macros:  SCM_BITVECTOR_MAX_LENGTH, SCM_UVECTOR_MAX_LENGTH

Use these instead of SCM_LENGTH_MAX.

** New macros:  SCM_CONTINUATION_LENGTH, SCM_CCLO_LENGTH, SCM_STACK_LENGTH,
SCM_STRING_LENGTH, SCM_SYMBOL_LENGTH, SCM_UVECTOR_LENGTH,
SCM_BITVECTOR_LENGTH, SCM_VECTOR_LENGTH.

Use these instead of SCM_LENGTH.

** New macros:  SCM_SET_CONTINUATION_LENGTH, SCM_SET_STRING_LENGTH,
SCM_SET_SYMBOL_LENGTH, SCM_SET_VECTOR_LENGTH, SCM_SET_UVECTOR_LENGTH,
SCM_SET_BITVECTOR_LENGTH

Use these instead of SCM_SETLENGTH

** New macros:  SCM_STRING_CHARS, SCM_SYMBOL_CHARS, SCM_CCLO_BASE,
SCM_VECTOR_BASE, SCM_UVECTOR_BASE, SCM_BITVECTOR_BASE, SCM_COMPLEX_MEM,
SCM_ARRAY_MEM

Use these instead of SCM_CHARS, SCM_UCHARS, SCM_ROCHARS, SCM_ROUCHARS or
SCM_VELTS.

** New macros:  SCM_SET_BIGNUM_BASE, SCM_SET_STRING_CHARS,
SCM_SET_SYMBOL_CHARS, SCM_SET_UVECTOR_BASE, SCM_SET_BITVECTOR_BASE,
SCM_SET_VECTOR_BASE

Use these instead of SCM_SETCHARS.

** New macro:  SCM_BITVECTOR_P

** New macro:  SCM_STRING_COERCE_0TERMINATION_X

Use instead of SCM_COERCE_SUBSTR.

** New macros:  SCM_DIR_OPEN_P, SCM_DIR_FLAG_OPEN

For directory objects, use these instead of SCM_OPDIRP and SCM_OPN.

** Deprecated macros:  SCM_OUTOFRANGE, SCM_NALLOC, SCM_HUP_SIGNAL,
SCM_INT_SIGNAL, SCM_FPE_SIGNAL, SCM_BUS_SIGNAL, SCM_SEGV_SIGNAL,
SCM_ALRM_SIGNAL, SCM_GC_SIGNAL, SCM_TICK_SIGNAL, SCM_SIG_ORD,
SCM_ORD_SIG, SCM_NUM_SIGS, SCM_SYMBOL_SLOTS, SCM_SLOTS, SCM_SLOPPY_STRINGP,
SCM_VALIDATE_STRINGORSUBSTR, SCM_FREEP, SCM_NFREEP, SCM_CHARS, SCM_UCHARS,
SCM_VALIDATE_ROSTRING, SCM_VALIDATE_ROSTRING_COPY,
SCM_VALIDATE_NULLORROSTRING_COPY, SCM_ROLENGTH, SCM_LENGTH, SCM_HUGE_LENGTH,
SCM_SUBSTRP, SCM_SUBSTR_STR, SCM_SUBSTR_OFFSET, SCM_COERCE_SUBSTR,
SCM_ROSTRINGP, SCM_RWSTRINGP, SCM_VALIDATE_RWSTRING, SCM_ROCHARS,
SCM_ROUCHARS, SCM_SETLENGTH, SCM_SETCHARS, SCM_LENGTH_MAX, SCM_GC8MARKP,
SCM_SETGC8MARK, SCM_CLRGC8MARK, SCM_GCTYP16, SCM_GCCDR, SCM_SUBR_DOC,
SCM_OPDIRP, SCM_VALIDATE_OPDIR, SCM_WTA, RETURN_SCM_WTA, SCM_CONST_LONG,
SCM_WNA, SCM_FUNC_NAME, SCM_VALIDATE_NUMBER_COPY,
SCM_VALIDATE_NUMBER_DEF_COPY, SCM_SLOPPY_CONSP, SCM_SLOPPY_NCONSP,
SCM_SETAND_CDR, SCM_SETOR_CDR, SCM_SETAND_CAR, SCM_SETOR_CAR

Use SCM_ASSERT_RANGE or SCM_VALIDATE_XXX_RANGE instead of SCM_OUTOFRANGE.
Use scm_memory_error instead of SCM_NALLOC.
Use SCM_STRINGP instead of SCM_SLOPPY_STRINGP.
Use SCM_VALIDATE_STRING instead of SCM_VALIDATE_STRINGORSUBSTR.
Use SCM_FREE_CELL_P instead of SCM_FREEP/SCM_NFREEP
Use a type specific accessor macro instead of SCM_CHARS/SCM_UCHARS.
Use a type specific accessor instead of SCM(_|_RO|_HUGE_)LENGTH.
Use SCM_VALIDATE_(SYMBOL|STRING) instead of SCM_VALIDATE_ROSTRING.
Use SCM_STRING_COERCE_0TERMINATION_X instead of SCM_COERCE_SUBSTR.
Use SCM_STRINGP or SCM_SYMBOLP instead of SCM_ROSTRINGP.
Use SCM_STRINGP instead of SCM_RWSTRINGP.
Use SCM_VALIDATE_STRING instead of SCM_VALIDATE_RWSTRING.
Use SCM_STRING_CHARS instead of SCM_ROCHARS.
Use SCM_STRING_UCHARS instead of SCM_ROUCHARS.
Use a type specific setter macro instead of SCM_SETLENGTH.
Use a type specific setter macro instead of SCM_SETCHARS.
Use a type specific length macro instead of SCM_LENGTH_MAX.
Use SCM_GCMARKP instead of SCM_GC8MARKP.
Use SCM_SETGCMARK instead of SCM_SETGC8MARK.
Use SCM_CLRGCMARK instead of SCM_CLRGC8MARK.
Use SCM_TYP16 instead of SCM_GCTYP16.
Use SCM_CDR instead of SCM_GCCDR.
Use SCM_DIR_OPEN_P instead of SCM_OPDIRP.
Use SCM_MISC_ERROR or SCM_WRONG_TYPE_ARG instead of SCM_WTA.
Use SCM_MISC_ERROR or SCM_WRONG_TYPE_ARG instead of RETURN_SCM_WTA.
Use SCM_VCELL_INIT instead of SCM_CONST_LONG.
Use SCM_WRONG_NUM_ARGS instead of SCM_WNA.
Use SCM_CONSP instead of SCM_SLOPPY_CONSP.
Use !SCM_CONSP instead of SCM_SLOPPY_NCONSP.

** Removed function:  scm_struct_init

** Removed variable:  scm_symhash_dim

** Renamed function: scm_make_cont has been replaced by
scm_make_continuation, which has a different interface.

** Deprecated function:  scm_call_catching_errors

Use scm_catch or scm_lazy_catch from throw.[ch] instead.

** Deprecated function:  scm_strhash

Use scm_string_hash instead.

** Deprecated function:  scm_vector_set_length_x

Instead, create a fresh vector of the desired size and copy the contents.

** scm_gensym has changed prototype

scm_gensym now only takes one argument.

** Deprecated type tags:  scm_tc7_ssymbol, scm_tc7_msymbol, scm_tcs_symbols,
scm_tc7_lvector

There is now only a single symbol type scm_tc7_symbol.
The tag scm_tc7_lvector was not used anyway.

** Deprecated function:  scm_make_smob_type_mfpe, scm_set_smob_mfpe.

Use scm_make_smob_type and scm_set_smob_XXX instead.

** New function scm_set_smob_apply.

This can be used to set an apply function to a smob type.

** Deprecated function:  scm_strprint_obj

Use scm_object_to_string instead.

** Deprecated function:  scm_wta

Use scm_wrong_type_arg, or another appropriate error signalling function
instead.

** Explicit support for obarrays has been deprecated.

Use `scm_str2symbol' and the generic hashtable functions instead.

** The concept of `vcells' has been deprecated.

The data type `variable' is now used exclusively.  `Vcells' have been
a low-level concept so you are likely not affected by this change.

*** Deprecated functions: scm_sym2vcell, scm_sysintern,
    scm_sysintern0, scm_symbol_value0, scm_intern, scm_intern0.

Use scm_c_define or scm_c_lookup instead, as appropriate.

*** New functions: scm_c_module_lookup, scm_c_lookup,
    scm_c_module_define, scm_c_define, scm_module_lookup, scm_lookup,
    scm_module_define, scm_define.

These functions work with variables instead of with vcells.

** New functions for creating and defining `subr's and `gsubr's.

The new functions more clearly distinguish between creating a subr (or
gsubr) object and adding it to the current module.

These new functions are available: scm_c_make_subr, scm_c_define_subr,
scm_c_make_subr_with_generic, scm_c_define_subr_with_generic,
scm_c_make_gsubr, scm_c_define_gsubr, scm_c_make_gsubr_with_generic,
scm_c_define_gsubr_with_generic.

** Deprecated functions: scm_make_subr, scm_make_subr_opt,
   scm_make_subr_with_generic, scm_make_gsubr,
   scm_make_gsubr_with_generic.

Use the new ones from above instead.

** C interface to the module system has changed.

While we suggest that you avoid as many explicit module system
operations from C as possible for the time being, the C interface has
been made more similar to the high-level Scheme module system.

*** New functions: scm_c_define_module, scm_c_use_module,
    scm_c_export, scm_c_resolve_module.

They mostly work like their Scheme namesakes.  scm_c_define_module
takes a function that is called a context where the new module is
current.

*** Deprecated functions: scm_the_root_module, scm_make_module,
    scm_ensure_user_module, scm_load_scheme_module.

Use the new functions instead.

** Renamed function: scm_internal_with_fluids becomes
   scm_c_with_fluids.

scm_internal_with_fluids is available as a deprecated function.

** New function: scm_c_with_fluid.

Just like scm_c_with_fluids, but takes one fluid and one value instead
of lists of same.

** Deprecated typedefs: long_long, ulong_long.

They are of questionable utility and they pollute the global
namespace.

** Deprecated typedef: scm_sizet

It is of questionable utility now that Guile requires ANSI C, and is
oddly named.

** Deprecated typedefs: scm_port_rw_active, scm_port,
   scm_ptob_descriptor, scm_debug_info, scm_debug_frame, scm_fport,
   scm_option, scm_rstate, scm_rng, scm_array, scm_array_dim.

Made more compliant with the naming policy by adding a _t at the end.

** Deprecated functions: scm_mkbig, scm_big2num, scm_adjbig,
   scm_normbig, scm_copybig, scm_2ulong2big, scm_dbl2big, scm_big2dbl

With the exception of the mysterious scm_2ulong2big, they are still
available under new names (scm_i_mkbig etc).  These functions are not
intended to be used in user code.  You should avoid dealing with
bignums directly, and should deal with numbers in general (which can
be bignums).

** Change in behavior: scm_num2long, scm_num2ulong

The scm_num2[u]long functions don't any longer accept an inexact
argument.  This change in behavior is motivated by concordance with
R5RS: It is more common that a primitive doesn't want to accept an
inexact for an exact.

** New functions: scm_short2num, scm_ushort2num, scm_int2num,
   scm_uint2num, scm_size2num, scm_ptrdiff2num, scm_num2short,
   scm_num2ushort, scm_num2int, scm_num2uint, scm_num2ptrdiff,
   scm_num2size.

These are conversion functions between the various ANSI C integral
types and Scheme numbers.  NOTE: The scm_num2xxx functions don't
accept an inexact argument.

** New functions: scm_float2num, scm_double2num,
   scm_num2float, scm_num2double.

These are conversion functions between the two ANSI C float types and
Scheme numbers.

** New number validation macros:
   SCM_NUM2{SIZE,PTRDIFF,SHORT,USHORT,INT,UINT}[_DEF]

See above.

** New functions: scm_gc_protect_object, scm_gc_unprotect_object

These are just nicer-named old scm_protect_object and
scm_unprotect_object.

** Deprecated functions: scm_protect_object, scm_unprotect_object

** New functions: scm_gc_[un]register_root, scm_gc_[un]register_roots

These functions can be used to register pointers to locations that
hold SCM values.

** Deprecated function: scm_create_hook.

Its sins are: misleading name, non-modularity and lack of general
usefulness.


Changes since Guile 1.3.4:

* Changes to the distribution

** Trees from nightly snapshots and CVS now require you to run autogen.sh.

We've changed the way we handle generated files in the Guile source
repository.  As a result, the procedure for building trees obtained
from the nightly FTP snapshots or via CVS has changed:
- You must have appropriate versions of autoconf, automake, and
  libtool installed on your system.  See README for info on how to
  obtain these programs.
- Before configuring the tree, you must first run the script
  `autogen.sh' at the top of the source tree.

The Guile repository used to contain not only source files, written by
humans, but also some generated files, like configure scripts and
Makefile.in files.  Even though the contents of these files could be
derived mechanically from other files present, we thought it would
make the tree easier to build if we checked them into CVS.

However, this approach means that minor differences between
developer's installed tools and habits affected the whole team.
So we have removed the generated files from the repository, and
added the autogen.sh script, which will reconstruct them
appropriately.


** configure now has experimental options to remove support for certain
features:

--disable-arrays     omit array and uniform array support
--disable-posix      omit posix interfaces
--disable-networking omit networking interfaces
--disable-regex      omit regular expression interfaces

These are likely to become separate modules some day.

** New configure option --enable-debug-freelist

This enables a debugging version of SCM_NEWCELL(), and also registers
an extra primitive, the setter `gc-set-debug-check-freelist!'.

Configure with the --enable-debug-freelist option to enable
the gc-set-debug-check-freelist! primitive, and then use:

(gc-set-debug-check-freelist! #t)  # turn on checking of the freelist
(gc-set-debug-check-freelist! #f)  # turn off checking

Checking of the freelist forces a traversal of the freelist and
a garbage collection before each allocation of a cell.  This can
slow down the interpreter dramatically, so the setter should be used to
turn on this extra processing only when necessary.

** New configure option --enable-debug-malloc

Include code for debugging of calls to scm_must_malloc/realloc/free.

Checks that

1. objects freed by scm_must_free has been mallocated by scm_must_malloc
2. objects reallocated by scm_must_realloc has been allocated by
   scm_must_malloc
3. reallocated objects are reallocated with the same what string

But, most importantly, it records the number of allocated objects of
each kind.  This is useful when searching for memory leaks.

A Guile compiled with this option provides the primitive
`malloc-stats' which returns an alist with pairs of kind and the
number of objects of that kind.

** All includes are now referenced relative to the root directory

Since some users have had problems with mixups between Guile and
system headers, we have decided to always refer to Guile headers via
their parent directories.  This essentially creates a "private name
space" for Guile headers.  This means that the compiler only is given
-I options for the root build and root source directory.

** Header files kw.h and genio.h have been removed.

** The module (ice-9 getopt-gnu-style) has been removed.

** New module (ice-9 documentation)

Implements the interface to documentation strings associated with
objects.

** New module (ice-9 time)

Provides a macro `time', which displays execution time of a given form.

** New module (ice-9 history)

Loading this module enables value history in the repl.

* Changes to the stand-alone interpreter

** New command line option --debug

Start Guile with debugging evaluator and backtraces enabled.

This is useful when debugging your .guile init file or scripts.

** New help facility

Usage: (help NAME) gives documentation about objects named NAME (a symbol)
       (help REGEXP) ditto for objects with names matching REGEXP (a string)
       (help 'NAME) gives documentation for NAME, even if it is not an object
       (help ,EXPR) gives documentation for object returned by EXPR
       (help (my module)) gives module commentary for `(my module)'
       (help) gives this text

`help' searches among bindings exported from loaded modules, while
`apropos' searches among bindings visible from the "current" module.

Examples: (help help)
          (help cons)
          (help "output-string")

** `help' and `apropos' now prints full module names

** Dynamic linking now uses libltdl from the libtool package.

The old system dependent code for doing dynamic linking has been
replaced with calls to the libltdl functions which do all the hairy
details for us.

The major improvement is that you can now directly pass libtool
library names like "libfoo.la" to `dynamic-link' and `dynamic-link'
will be able to do the best shared library job you can get, via
libltdl.

The way dynamic libraries are found has changed and is not really
portable across platforms, probably.  It is therefore recommended to
use absolute filenames when possible.

If you pass a filename without an extension to `dynamic-link', it will
try a few appropriate ones.  Thus, the most platform ignorant way is
to specify a name like "libfoo", without any directories and
extensions.

** Guile COOP threads are now compatible with LinuxThreads

Previously, COOP threading wasn't possible in applications linked with
Linux POSIX threads due to their use of the stack pointer to find the
thread context.  This has now been fixed with a workaround which uses
the pthreads to allocate the stack.

** New primitives: `pkgdata-dir', `site-dir', `library-dir'

** Positions of erring expression in scripts

With version 1.3.4, the location of the erring expression in Guile
scipts is no longer automatically reported.  (This should have been
documented before the 1.3.4 release.)

You can get this information by enabling recording of positions of
source expressions and running the debugging evaluator.  Put this at
the top of your script (or in your "site" file):

  (read-enable 'positions)
  (debug-enable 'debug)

** Backtraces in scripts

It is now possible to get backtraces in scripts.

Put

  (debug-enable 'debug 'backtrace)

at the top of the script.

(The first options enables the debugging evaluator.
 The second enables backtraces.)

** Part of module system symbol lookup now implemented in C

The eval closure of most modules is now implemented in C.  Since this
was one of the bottlenecks for loading speed, Guile now loads code
substantially faster than before.

** Attempting to get the value of an unbound variable now produces
an exception with a key of 'unbound-variable instead of 'misc-error.

** The initial default output port is now unbuffered if it's using a
tty device.  Previously in this situation it was line-buffered.

** New hook: after-gc-hook

after-gc-hook takes over the role of gc-thunk.  This hook is run at
the first SCM_TICK after a GC.  (Thus, the code is run at the same
point during evaluation as signal handlers.)

Note that this hook should be used only for diagnostic and debugging
purposes.  It is not certain that it will continue to be well-defined
when this hook is run in the future.

C programmers: Note the new C level hooks scm_before_gc_c_hook,
scm_before_sweep_c_hook, scm_after_gc_c_hook.

** Improvements to garbage collector

Guile 1.4 has a new policy for triggering heap allocation and
determining the sizes of heap segments.  It fixes a number of problems
in the old GC.

1. The new policy can handle two separate pools of cells
   (2-word/4-word) better.  (The old policy would run wild, allocating
   more and more memory for certain programs.)

2. The old code would sometimes allocate far too much heap so that the
   Guile process became gigantic.  The new code avoids this.

3. The old code would sometimes allocate too little so that few cells
   were freed at GC so that, in turn, too much time was spent in GC.

4. The old code would often trigger heap allocation several times in a
   row.  (The new scheme predicts how large the segments needs to be
   in order not to need further allocation.)

All in all, the new GC policy will make larger applications more
efficient.

The new GC scheme also is prepared for POSIX threading.  Threads can
allocate private pools of cells ("clusters") with just a single
function call.  Allocation of single cells from such a cluster can
then proceed without any need of inter-thread synchronization.

** New environment variables controlling GC parameters

GUILE_MAX_SEGMENT_SIZE          Maximal segment size
                                (default = 2097000)

Allocation of 2-word cell heaps:

GUILE_INIT_SEGMENT_SIZE_1       Size of initial heap segment in bytes
                                (default = 360000)

GUILE_MIN_YIELD_1               Minimum number of freed cells at each
                                GC in percent of total heap size
                                (default = 40)

Allocation of 4-word cell heaps
(used for real numbers and misc other objects):

GUILE_INIT_SEGMENT_SIZE_2, GUILE_MIN_YIELD_2

(See entry "Way for application to customize GC parameters" under
 section "Changes to the scm_ interface" below.)

** Guile now implements reals using 4-word cells

This speeds up computation with reals.  (They were earlier allocated
with `malloc'.)  There is still some room for optimizations, however.

** Some further steps toward POSIX thread support have been taken

*** Guile's critical sections (SCM_DEFER/ALLOW_INTS)
don't have much effect any longer, and many of them will be removed in
next release.

*** Signals
are only handled at the top of the evaluator loop, immediately after
I/O, and in scm_equalp.

*** The GC can allocate thread private pools of pairs.

* Changes to Scheme functions and syntax

** close-input-port and close-output-port are now R5RS

These procedures have been turned into primitives and have R5RS behaviour.

** New procedure: simple-format PORT MESSAGE ARG1 ...

(ice-9 boot) makes `format' an alias for `simple-format' until possibly
extended by the more sophisticated version in (ice-9 format)

(simple-format port message . args)
Write MESSAGE to DESTINATION, defaulting to `current-output-port'.
MESSAGE can contain ~A (was %s) and ~S (was %S) escapes.  When printed,
the escapes are replaced with corresponding members of ARGS:
~A formats using `display' and ~S formats using `write'.
If DESTINATION is #t, then use the `current-output-port',
if DESTINATION is #f, then return a string containing the formatted text.
Does not add a trailing newline."

** string-ref: the second argument is no longer optional.

** string, list->string: no longer accept strings in their arguments,
only characters, for compatibility with R5RS.

** New procedure: port-closed? PORT
Returns #t if PORT is closed or #f if it is open.

** Deprecated: list*

The list* functionality is now provided by cons* (SRFI-1 compliant)

** New procedure: cons* ARG1 ARG2 ... ARGn

Like `list', but the last arg provides the tail of the constructed list,
returning (cons ARG1 (cons ARG2 (cons ... ARGn))).

Requires at least one argument.  If given one argument, that argument
is returned as result.

This function is called `list*' in some other Schemes and in Common LISP.

** Removed deprecated: serial-map, serial-array-copy!, serial-array-map!

** New procedure: object-documentation OBJECT

Returns the documentation string associated with OBJECT.  The
procedure uses a caching mechanism so that subsequent lookups are
faster.

Exported by (ice-9 documentation).

** module-name now returns full names of modules

Previously, only the last part of the name was returned (`session' for
`(ice-9 session)').  Ex: `(ice-9 session)'.

* Changes to the gh_ interface

** Deprecated: gh_int2scmb

Use gh_bool2scm instead.

* Changes to the scm_ interface

** Guile primitives now carry docstrings!

Thanks to Greg Badros!

** Guile primitives are defined in a new way: SCM_DEFINE/SCM_DEFINE1/SCM_PROC

Now Guile primitives are defined using the SCM_DEFINE/SCM_DEFINE1/SCM_PROC
macros and must contain a docstring that is extracted into foo.doc using a new
guile-doc-snarf script (that uses guile-doc-snarf.awk).

However, a major overhaul of these macros is scheduled for the next release of
guile.

** Guile primitives use a new technique for validation of arguments

SCM_VALIDATE_* macros are defined to ease the redundancy and improve
the readability of argument checking.

** All (nearly?) K&R prototypes for functions replaced with ANSI C equivalents.

** New macros: SCM_PACK, SCM_UNPACK

Compose/decompose an SCM value.

The SCM type is now treated as an abstract data type and may be defined as a
long, a void* or as a struct, depending on the architecture and compile time
options. This makes it easier to find several types of bugs, for example when
SCM values are treated as integers without conversion.  Values of the SCM type
should be treated as "atomic" values.  These macros are used when
composing/decomposing an SCM value, either because you want to access
individual bits, or because you want to treat it as an integer value.

E.g., in order to set bit 7 in an SCM value x, use the expression

  SCM_PACK (SCM_UNPACK (x) | 0x80)

** The name property of hooks is deprecated.
Thus, the use of SCM_HOOK_NAME and scm_make_hook_with_name is deprecated.

You can emulate this feature by using object properties.

** Deprecated macros: SCM_INPORTP, SCM_OUTPORTP, SCM_CRDY, SCM_ICHRP,
SCM_ICHR, SCM_MAKICHR, SCM_SETJMPBUF, SCM_NSTRINGP, SCM_NRWSTRINGP,
SCM_NVECTORP

These macros will be removed in a future release of Guile.

** The following types, functions and macros from numbers.h are deprecated:
scm_dblproc, SCM_UNEGFIXABLE, SCM_FLOBUFLEN, SCM_INEXP, SCM_CPLXP, SCM_REAL,
SCM_IMAG, SCM_REALPART, scm_makdbl, SCM_SINGP, SCM_NUM2DBL, SCM_NO_BIGDIG

** Port internals: the rw_random variable in the scm_port structure
must be set to non-zero in any random access port.  In recent Guile
releases it was only set for bidirectional random-access ports.

** Port internals: the seek ptob procedure is now responsible for
resetting the buffers if required.  The change was made so that in the
special case of reading the current position (i.e., seek p 0 SEEK_CUR)
the fport and strport ptobs can avoid resetting the buffers,
in particular to avoid discarding unread chars.  An existing port
type can be fixed by adding something like the following to the
beginning of the ptob seek procedure:

      if (pt->rw_active == SCM_PORT_READ)
	scm_end_input (object);
      else if (pt->rw_active == SCM_PORT_WRITE)
	ptob->flush (object);

although to actually avoid resetting the buffers and discard unread
chars requires further hacking that depends on the characteristics
of the ptob.

** Deprecated functions: scm_fseek, scm_tag

These functions are no longer used and will be removed in a future version.

** The scm_sysmissing procedure is no longer used in libguile.
Unless it turns out to be unexpectedly useful to somebody, it will be
removed in a future version.

** The format of error message strings has changed

The two C procedures: scm_display_error and scm_error, as well as the
primitive `scm-error', now use scm_simple_format to do their work.
This means that the message strings of all code must be updated to use
~A where %s was used before, and ~S where %S was used before.

During the period when there still are a lot of old Guiles out there,
you might want to support both old and new versions of Guile.

There are basically two methods to achieve this.  Both methods use
autoconf.  Put

  AC_CHECK_FUNCS(scm_simple_format)

in your configure.in.

Method 1: Use the string concatenation features of ANSI C's
          preprocessor.

In C:

#ifdef HAVE_SCM_SIMPLE_FORMAT
#define FMT_S "~S"
#else
#define FMT_S "%S"
#endif

Then represent each of your error messages using a preprocessor macro:

#define E_SPIDER_ERROR "There's a spider in your " ## FMT_S ## "!!!"

In Scheme:

(define fmt-s (if (defined? 'simple-format) "~S" "%S"))
(define make-message string-append)

(define e-spider-error (make-message "There's a spider in your " fmt-s "!!!"))

Method 2: Use the oldfmt function found in doc/oldfmt.c.

In C:

scm_misc_error ("picnic", scm_c_oldfmt0 ("There's a spider in your ~S!!!"),
                ...);

In Scheme:

(scm-error 'misc-error "picnic" (oldfmt "There's a spider in your ~S!!!")
           ...)


** Deprecated: coop_mutex_init, coop_condition_variable_init

Don't use the functions coop_mutex_init and
coop_condition_variable_init.  They will change.

Use scm_mutex_init and scm_cond_init instead.

** New function: int scm_cond_timedwait (scm_cond_t *COND, scm_mutex_t *MUTEX, const struct timespec *ABSTIME)
     `scm_cond_timedwait' atomically unlocks MUTEX and waits on
     COND, as `scm_cond_wait' does, but it also bounds the duration
     of the wait. If COND has not been signaled before time ABSTIME,
     the mutex MUTEX is re-acquired and `scm_cond_timedwait'
     returns the error code `ETIMEDOUT'.

     The ABSTIME parameter specifies an absolute time, with the same
     origin as `time' and `gettimeofday': an ABSTIME of 0 corresponds
     to 00:00:00 GMT, January 1, 1970.

** New function: scm_cond_broadcast (scm_cond_t *COND)
     `scm_cond_broadcast' restarts all the threads that are waiting
     on the condition variable COND. Nothing happens if no threads are
     waiting on COND.

** New function: scm_key_create (scm_key_t *KEY, void (*destr_function) (void *))
     `scm_key_create' allocates a new TSD key. The key is stored in
     the location pointed to by KEY. There is no limit on the number
     of keys allocated at a given time. The value initially associated
     with the returned key is `NULL' in all currently executing threads.

     The DESTR_FUNCTION argument, if not `NULL', specifies a destructor
     function associated with the key. When a thread terminates,
     DESTR_FUNCTION is called on the value associated with the key in
     that thread. The DESTR_FUNCTION is not called if a key is deleted
     with `scm_key_delete' or a value is changed with
     `scm_setspecific'.  The order in which destructor functions are
     called at thread termination time is unspecified.

     Destructors are not yet implemented.

** New function: scm_setspecific (scm_key_t KEY, const void *POINTER)
     `scm_setspecific' changes the value associated with KEY in the
     calling thread, storing the given POINTER instead.

** New function: scm_getspecific (scm_key_t KEY)
     `scm_getspecific' returns the value currently associated with
     KEY in the calling thread.

** New function: scm_key_delete (scm_key_t KEY)
     `scm_key_delete' deallocates a TSD key. It does not check
     whether non-`NULL' values are associated with that key in the
     currently executing threads, nor call the destructor function
     associated with the key.

** New function: scm_c_hook_init (scm_c_hook_t *HOOK, void *HOOK_DATA, scm_c_hook_type_t TYPE)

Initialize a C level hook HOOK with associated HOOK_DATA and type
TYPE.  (See scm_c_hook_run ().)

** New function: scm_c_hook_add (scm_c_hook_t *HOOK, scm_c_hook_function_t FUNC, void *FUNC_DATA, int APPENDP)

Add hook function FUNC with associated FUNC_DATA to HOOK.  If APPENDP
is true, add it last, otherwise first.  The same FUNC can be added
multiple times if FUNC_DATA differ and vice versa.

** New function: scm_c_hook_remove (scm_c_hook_t *HOOK, scm_c_hook_function_t FUNC, void *FUNC_DATA)

Remove hook function FUNC with associated FUNC_DATA from HOOK.  A
function is only removed if both FUNC and FUNC_DATA matches.

** New function: void *scm_c_hook_run (scm_c_hook_t *HOOK, void *DATA)

Run hook HOOK passing DATA to the hook functions.

If TYPE is SCM_C_HOOK_NORMAL, all hook functions are run.  The value
returned is undefined.

If TYPE is SCM_C_HOOK_OR, hook functions are run until a function
returns a non-NULL value.  This value is returned as the result of
scm_c_hook_run.  If all functions return NULL, NULL is returned.

If TYPE is SCM_C_HOOK_AND, hook functions are run until a function
returns a NULL value, and NULL is returned.  If all functions returns
a non-NULL value, the last value is returned.

** New C level GC hooks

Five new C level hooks has been added to the garbage collector.

  scm_before_gc_c_hook
  scm_after_gc_c_hook

are run before locking and after unlocking the heap.  The system is
thus in a mode where evaluation can take place.  (Except that
scm_before_gc_c_hook must not allocate new cells.)

  scm_before_mark_c_hook
  scm_before_sweep_c_hook
  scm_after_sweep_c_hook

are run when the heap is locked.  These are intended for extension of
the GC in a modular fashion.  Examples are the weaks and guardians
modules.

** Way for application to customize GC parameters

The application can set up other default values for the GC heap
allocation parameters

  GUILE_INIT_HEAP_SIZE_1, GUILE_MIN_YIELD_1,
  GUILE_INIT_HEAP_SIZE_2, GUILE_MIN_YIELD_2,
  GUILE_MAX_SEGMENT_SIZE,

by setting

  scm_default_init_heap_size_1, scm_default_min_yield_1,
  scm_default_init_heap_size_2, scm_default_min_yield_2,
  scm_default_max_segment_size

respectively before callong scm_boot_guile.

(See entry "New environment variables ..." in section
"Changes to the stand-alone interpreter" above.)

** scm_protect_object/scm_unprotect_object now nest

This means that you can call scm_protect_object multiple times on an
object and count on the object being protected until
scm_unprotect_object has been call the same number of times.

The functions also have better time complexity.

Still, it is usually possible to structure the application in a way
that you don't need to use these functions.  For example, if you use a
protected standard Guile list to keep track of live objects rather
than some custom data type, objects will die a natural death when they
are no longer needed.

** Deprecated type tags:  scm_tc16_flo, scm_tc_flo, scm_tc_dblr, scm_tc_dblc

Guile does not provide the float representation for inexact real numbers any
more.  Now, only doubles are used to represent inexact real numbers.  Further,
the tag names scm_tc_dblr and scm_tc_dblc have been changed to scm_tc16_real
and scm_tc16_complex, respectively.

** Removed deprecated type scm_smobfuns

** Removed deprecated function scm_newsmob

** Warning: scm_make_smob_type_mfpe might become deprecated in a future release

There is an ongoing discussion among the developers whether to
deprecate `scm_make_smob_type_mfpe' or not.  Please use the current
standard interface (scm_make_smob_type, scm_set_smob_XXX) in new code
until this issue has been settled.

** Removed deprecated type tag scm_tc16_kw

** Added type tag scm_tc16_keyword

(This was introduced already in release 1.3.4 but was not documented
 until now.)

** gdb_print now prints "*** Guile not initialized ***" until Guile initialized

* Changes to system call interfaces:

** The "select" procedure now tests port buffers for the ability to
provide input or accept output.  Previously only the underlying file
descriptors were checked.

** New variable PIPE_BUF: the maximum number of bytes that can be
atomically written to a pipe.

** If a facility is not available on the system when Guile is
compiled, the corresponding primitive procedure will not be defined.
Previously it would have been defined but would throw a system-error
exception if called.  Exception handlers which catch this case may
need minor modification: an error will be thrown with key
'unbound-variable instead of 'system-error.  Alternatively it's
now possible to use `defined?' to check whether the facility is
available.

** Procedures which depend on the timezone should now give the correct
result on systems which cache the TZ environment variable, even if TZ
is changed without calling tzset.

* Changes to the networking interfaces:

** New functions: htons, ntohs, htonl, ntohl: for converting short and
long integers between network and host format.  For now, it's not
particularly convenient to do this kind of thing, but consider:

(define write-network-long
  (lambda (value port)
    (let ((v (make-uniform-vector 1 1 0)))
      (uniform-vector-set! v 0 (htonl value))
      (uniform-vector-write v port))))

(define read-network-long
  (lambda (port)
    (let ((v (make-uniform-vector 1 1 0)))
      (uniform-vector-read! v port)
      (ntohl (uniform-vector-ref v 0)))))

** If inet-aton fails, it now throws an error with key 'misc-error
instead of 'system-error, since errno is not relevant.

** Certain gethostbyname/gethostbyaddr failures now throw errors with
specific keys instead of 'system-error.  The latter is inappropriate
since errno will not have been set.  The keys are:
'host-not-found, 'try-again, 'no-recovery and 'no-data.

** sethostent, setnetent, setprotoent, setservent: now take an
optional argument STAYOPEN, which specifies whether the database
remains open after a database entry is accessed randomly (e.g., using
gethostbyname for the hosts database.)  The default is #f.  Previously
#t was always used.


Changes since Guile 1.3.2:

* Changes to the stand-alone interpreter

** Debugger

An initial version of the Guile debugger written by Chris Hanson has
been added.  The debugger is still under development but is included
in the distribution anyway since it is already quite useful.

Type

  (debug)

after an error to enter the debugger.  Type `help' inside the debugger
for a description of available commands.

If you prefer to have stack frames numbered and printed in
anti-chronological order and prefer up in the stack to be down on the
screen as is the case in gdb, you can put

  (debug-enable 'backwards)

in your .guile startup file.  (However, this means that Guile can't
use indentation to indicate stack level.)

The debugger is autoloaded into Guile at the first use.

** Further enhancements to backtraces

There is a new debug option `width' which controls the maximum width
on the screen of printed stack frames.  Fancy printing parameters
("level" and "length" as in Common LISP) are adaptively adjusted for
each stack frame to give maximum information while still fitting
within the bounds.  If the stack frame can't be made to fit by
adjusting parameters, it is simply cut off at the end.  This is marked
with a `$'.

** Some modules are now only loaded when the repl is started

The modules (ice-9 debug), (ice-9 session), (ice-9 threads) and (ice-9
regex) are now loaded into (guile-user) only if the repl has been
started.  The effect is that the startup time for scripts has been
reduced to 30% of what it was previously.

Correctly written scripts load the modules they require at the top of
the file and should not be affected by this change.

** Hooks are now represented as smobs

* Changes to Scheme functions and syntax

** Readline support has changed again.

The old (readline-activator) module is gone.  Use (ice-9 readline)
instead, which now contains all readline functionality.  So the code
to activate readline is now

    (use-modules (ice-9 readline))
    (activate-readline)

This should work at any time, including from the guile prompt.

To avoid confusion about the terms of Guile's license, please only
enable readline for your personal use; please don't make it the
default for others.  Here is why we make this rather odd-sounding
request:

Guile is normally licensed under a weakened form of the GNU General
Public License, which allows you to link code with Guile without
placing that code under the GPL.  This exception is important to some
people.

However, since readline is distributed under the GNU General Public
License, when you link Guile with readline, either statically or
dynamically, you effectively change Guile's license to the strict GPL.
Whenever you link any strictly GPL'd code into Guile, uses of Guile
which are normally permitted become forbidden.  This is a rather
non-obvious consequence of the licensing terms.

So, to make sure things remain clear, please let people choose for
themselves whether to link GPL'd libraries like readline with Guile.

** regexp-substitute/global has changed slightly, but incompatibly.

If you include a function in the item list, the string of the match
object it receives is the same string passed to
regexp-substitute/global, not some suffix of that string.
Correspondingly, the match's positions are relative to the entire
string, not the suffix.

If the regexp can match the empty string, the way matches are chosen
from the string has changed.  regexp-substitute/global recognizes the
same set of matches that list-matches does; see below.

** New function: list-matches REGEXP STRING [FLAGS]

Return a list of match objects, one for every non-overlapping, maximal
match of REGEXP in STRING.  The matches appear in left-to-right order.
list-matches only reports matches of the empty string if there are no
other matches which begin on, end at, or include the empty match's
position.

If present, FLAGS is passed as the FLAGS argument to regexp-exec.

** New function: fold-matches REGEXP STRING INIT PROC [FLAGS]

For each match of REGEXP in STRING, apply PROC to the match object,
and the last value PROC returned, or INIT for the first call.  Return
the last value returned by PROC.  We apply PROC to the matches as they
appear from left to right.

This function recognizes matches according to the same criteria as
list-matches.

Thus, you could define list-matches like this:

  (define (list-matches regexp string . flags)
    (reverse! (apply fold-matches regexp string '() cons flags)))

If present, FLAGS is passed as the FLAGS argument to regexp-exec.

** Hooks

*** New function: hook? OBJ

Return #t if OBJ is a hook, otherwise #f.

*** New function: make-hook-with-name NAME [ARITY]

Return a hook with name NAME and arity ARITY.  The default value for
ARITY is 0.  The only effect of NAME is that it will appear when the
hook object is printed to ease debugging.

*** New function: hook-empty? HOOK

Return #t if HOOK doesn't contain any procedures, otherwise #f.

*** New function: hook->list HOOK

Return a list of the procedures that are called when run-hook is
applied to HOOK.

** `map' signals an error if its argument lists are not all the same length.

This is the behavior required by R5RS, so this change is really a bug
fix.  But it seems to affect a lot of people's code, so we're
mentioning it here anyway.

** Print-state handling has been made more transparent

Under certain circumstances, ports are represented as a port with an
associated print state.  Earlier, this pair was represented as a pair
(see "Some magic has been added to the printer" below).  It is now
indistinguishable (almost; see `get-print-state') from a port on the
user level.

*** New function: port-with-print-state OUTPUT-PORT PRINT-STATE

Return a new port with the associated print state PRINT-STATE.

*** New function: get-print-state OUTPUT-PORT

Return the print state associated with this port if it exists,
otherwise return #f.

*** New function: directory-stream? OBJECT

Returns true iff OBJECT is a directory stream --- the sort of object
returned by `opendir'.

** New function: using-readline?

Return #t if readline is in use in the current repl.

** structs will be removed in 1.4

Structs will be replaced in Guile 1.4.  We will merge GOOPS into Guile
and use GOOPS objects as the fundamental record type.

* Changes to the scm_ interface

** structs will be removed in 1.4

The entire current struct interface (struct.c, struct.h) will be
replaced in Guile 1.4.  We will merge GOOPS into libguile and use
GOOPS objects as the fundamental record type.

** The internal representation of subr's has changed

Instead of giving a hint to the subr name, the CAR field of the subr
now contains an index to a subr entry in scm_subr_table.

*** New variable: scm_subr_table

An array of subr entries.  A subr entry contains the name, properties
and documentation associated with the subr.  The properties and
documentation slots are not yet used.

** A new scheme for "forwarding" calls to a builtin to a generic function

It is now possible to extend the functionality of some Guile
primitives by letting them defer a call to a GOOPS generic function on
argument mismatch.  This means that there is no loss of efficiency in
normal evaluation.

Example:

  (use-modules (oop goops)) ; Must be GOOPS version 0.2.
  (define-method + ((x <string>) (y <string>))
    (string-append x y))

+ will still be as efficient as usual in numerical calculations, but
can also be used for concatenating strings.

Who will be the first one to extend Guile's numerical tower to
rationals?  :)  [OK, there a few other things to fix before this can
be made in a clean way.]

*** New snarf macros for defining primitives: SCM_GPROC, SCM_GPROC1

  New macro: SCM_GPROC (CNAME, SNAME, REQ, OPT, VAR, CFUNC, GENERIC)

  New macro: SCM_GPROC1 (CNAME, SNAME, TYPE, CFUNC, GENERIC)

These do the same job as SCM_PROC and SCM_PROC1, but they also define
a variable GENERIC which can be used by the dispatch macros below.

[This is experimental code which may change soon.]

*** New macros for forwarding control to a generic on arg type error

  New macro: SCM_WTA_DISPATCH_1 (GENERIC, ARG1, POS, SUBR)

  New macro: SCM_WTA_DISPATCH_2 (GENERIC, ARG1, ARG2, POS, SUBR)

These correspond to the scm_wta function call, and have the same
behaviour until the user has called the GOOPS primitive
`enable-primitive-generic!'.  After that, these macros will apply the
generic function GENERIC to the argument(s) instead of calling
scm_wta.

[This is experimental code which may change soon.]

*** New macros for argument testing with generic dispatch

  New macro: SCM_GASSERT1 (COND, GENERIC, ARG1, POS, SUBR)

  New macro: SCM_GASSERT2 (COND, GENERIC, ARG1, ARG2, POS, SUBR)

These correspond to the SCM_ASSERT macro, but will defer control to
GENERIC on error after `enable-primitive-generic!' has been called.

[This is experimental code which may change soon.]

** New function: SCM scm_eval_body (SCM body, SCM env)

Evaluates the body of a special form.

** The internal representation of struct's has changed

Previously, four slots were allocated for the procedure(s) of entities
and operators.  The motivation for this representation had to do with
the structure of the evaluator, the wish to support tail-recursive
generic functions, and efficiency.  Since the generic function
dispatch mechanism has changed, there is no longer a need for such an
expensive representation, and the representation has been simplified.

This should not make any difference for most users.

** GOOPS support has been cleaned up.

Some code has been moved from eval.c to objects.c and code in both of
these compilation units has been cleaned up and better structured.

*** New functions for applying generic functions

  New function: SCM scm_apply_generic (GENERIC, ARGS)
  New function: SCM scm_call_generic_0 (GENERIC)
  New function: SCM scm_call_generic_1 (GENERIC, ARG1)
  New function: SCM scm_call_generic_2 (GENERIC, ARG1, ARG2)
  New function: SCM scm_call_generic_3 (GENERIC, ARG1, ARG2, ARG3)

** Deprecated function: scm_make_named_hook

It is now replaced by:

** New function: SCM scm_create_hook (const char *name, int arity)

Creates a hook in the same way as make-hook above but also
binds a variable named NAME to it.

This is the typical way of creating a hook from C code.

Currently, the variable is created in the "current" module.
This might change when we get the new module system.

[The behaviour is identical to scm_make_named_hook.]



Changes since Guile 1.3:

* Changes to mailing lists

** Some of the Guile mailing lists have moved to sourceware.cygnus.com.

See the README file to find current addresses for all the Guile
mailing lists.

* Changes to the distribution

** Readline support is no longer included with Guile by default.

Based on the different license terms of Guile and Readline, we
concluded that Guile should not *by default* cause the linking of
Readline into an application program.  Readline support is now offered
as a separate module, which is linked into an application only when
you explicitly specify it.

Although Guile is GNU software, its distribution terms add a special
exception to the usual GNU General Public License (GPL).  Guile's
license includes a clause that allows you to link Guile with non-free
programs.  We add this exception so as not to put Guile at a
disadvantage vis-a-vis other extensibility packages that support other
languages.

In contrast, the GNU Readline library is distributed under the GNU
General Public License pure and simple.  This means that you may not
link Readline, even dynamically, into an application unless it is
distributed under a free software license that is compatible the GPL.

Because of this difference in distribution terms, an application that
can use Guile may not be able to use Readline.  Now users will be
explicitly offered two independent decisions about the use of these
two packages.

You can activate the readline support by issuing

    (use-modules (readline-activator))
    (activate-readline)

from your ".guile" file, for example.

* Changes to the stand-alone interpreter

** All builtins now print as primitives.
Previously builtin procedures not belonging to the fundamental subr
types printed as #<compiled closure #<primitive-procedure gsubr-apply>>.
Now, they print as #<primitive-procedure NAME>.

** Backtraces slightly more intelligible.
gsubr-apply and macro transformer application frames no longer appear
in backtraces.

* Changes to Scheme functions and syntax

** Guile now correctly handles internal defines by rewriting them into
their equivalent letrec.  Previously, internal defines would
incrementally add to the innermost environment, without checking
whether the restrictions specified in RnRS were met.  This lead to the
correct behaviour when these restriction actually were met, but didn't
catch all illegal uses.  Such an illegal use could lead to crashes of
the Guile interpreter or or other unwanted results.  An example of
incorrect internal defines that made Guile behave erratically:

  (let ()
    (define a 1)
    (define (b) a)
    (define c (1+ (b)))
    (define d 3)

    (b))

  => 2

The problem with this example is that the definition of `c' uses the
value of `b' directly.  This confuses the meoization machine of Guile
so that the second call of `b' (this time in a larger environment that
also contains bindings for `c' and `d') refers to the binding of `c'
instead of `a'.  You could also make Guile crash with a variation on
this theme:

    (define (foo flag)
      (define a 1)
      (define (b flag) (if flag a 1))
      (define c (1+ (b flag)))
      (define d 3)

      (b #t))

    (foo #f)
    (foo #t)

From now on, Guile will issue an `Unbound variable: b' error message
for both examples.

** Hooks

A hook contains a list of functions which should be called on
particular occasions in an existing program.  Hooks are used for
customization.

A window manager might have a hook before-window-map-hook.  The window
manager uses the function run-hooks to call all functions stored in
before-window-map-hook each time a window is mapped.  The user can
store functions in the hook using add-hook!.

In Guile, hooks are first class objects.

*** New function: make-hook [N_ARGS]

Return a hook for hook functions which can take N_ARGS arguments.
The default value for N_ARGS is 0.

(See also scm_make_named_hook below.)

*** New function: add-hook! HOOK PROC [APPEND_P]

Put PROC at the beginning of the list of functions stored in HOOK.
If APPEND_P is supplied, and non-false, put PROC at the end instead.

PROC must be able to take the number of arguments specified when the
hook was created.

If PROC already exists in HOOK, then remove it first.

*** New function: remove-hook! HOOK PROC

Remove PROC from the list of functions in HOOK.

*** New function: reset-hook! HOOK

Clear the list of hook functions stored in HOOK.

*** New function: run-hook HOOK ARG1 ...

Run all hook functions stored in HOOK with arguments ARG1 ... .
The number of arguments supplied must correspond to the number given
when the hook was created.

** The function `dynamic-link' now takes optional keyword arguments.
   The only keyword argument that is currently defined is `:global
   BOOL'.  With it, you can control whether the shared library will be
   linked in global mode or not.  In global mode, the symbols from the
   linked library can be used to resolve references from other
   dynamically linked libraries.  In non-global mode, the linked
   library is essentially invisible and can only be accessed via
   `dynamic-func', etc.  The default is now to link in global mode.
   Previously, the default has been non-global mode.

   The `#:global' keyword is only effective on platforms that support
   the dlopen family of functions.

** New function `provided?'

 - Function: provided? FEATURE
     Return true iff FEATURE is supported by this installation of
     Guile.  FEATURE must be a symbol naming a feature; the global
     variable `*features*' is a list of available features.

** Changes to the module (ice-9 expect):

*** The expect-strings macro now matches `$' in a regular expression
    only at a line-break or end-of-file by default.  Previously it would
    match the end of the string accumulated so far. The old behaviour
    can be obtained by setting the variable `expect-strings-exec-flags'
    to 0.

*** The expect-strings macro now uses a variable `expect-strings-exec-flags'
    for the regexp-exec flags.  If `regexp/noteol' is included, then `$'
    in a regular expression will still match before a line-break or
    end-of-file.  The default is `regexp/noteol'.

*** The expect-strings macro now uses a variable
    `expect-strings-compile-flags' for the flags to be supplied to
    `make-regexp'.  The default is `regexp/newline', which was previously
    hard-coded.

*** The expect macro now supplies two arguments to a match procedure:
    the current accumulated string and a flag to indicate whether
    end-of-file has been reached.  Previously only the string was supplied.
    If end-of-file is reached, the match procedure will be called an
    additional time with the same accumulated string as the previous call
    but with the flag set.

** New module (ice-9 format), implementing the Common Lisp `format' function.

This code, and the documentation for it that appears here, was
borrowed from SLIB, with minor adaptations for Guile.

 - Function: format DESTINATION FORMAT-STRING . ARGUMENTS
     An almost complete implementation of Common LISP format description
     according to the CL reference book `Common LISP' from Guy L.
     Steele, Digital Press.  Backward compatible to most of the
     available Scheme format implementations.

     Returns `#t', `#f' or a string; has side effect of printing
     according to FORMAT-STRING.  If DESTINATION is `#t', the output is
     to the current output port and `#t' is returned.  If DESTINATION
     is `#f', a formatted string is returned as the result of the call.
     NEW: If DESTINATION is a string, DESTINATION is regarded as the
     format string; FORMAT-STRING is then the first argument and the
     output is returned as a string. If DESTINATION is a number, the
     output is to the current error port if available by the
     implementation. Otherwise DESTINATION must be an output port and
     `#t' is returned.

     FORMAT-STRING must be a string.  In case of a formatting error
     format returns `#f' and prints a message on the current output or
     error port.  Characters are output as if the string were output by
     the `display' function with the exception of those prefixed by a
     tilde (~).  For a detailed description of the FORMAT-STRING syntax
     please consult a Common LISP format reference manual.  For a test
     suite to verify this format implementation load `formatst.scm'.
     Please send bug reports to `lutzeb@cs.tu-berlin.de'.

     Note: `format' is not reentrant, i.e. only one `format'-call may
     be executed at a time.


*** Format Specification (Format version 3.0)

   Please consult a Common LISP format reference manual for a detailed
description of the format string syntax.  For a demonstration of the
implemented directives see `formatst.scm'.

   This implementation supports directive parameters and modifiers (`:'
and `@' characters). Multiple parameters must be separated by a comma
(`,').  Parameters can be numerical parameters (positive or negative),
character parameters (prefixed by a quote character (`''), variable
parameters (`v'), number of rest arguments parameter (`#'), empty and
default parameters.  Directive characters are case independent. The
general form of a directive is:

DIRECTIVE ::= ~{DIRECTIVE-PARAMETER,}[:][@]DIRECTIVE-CHARACTER

DIRECTIVE-PARAMETER ::= [ [-|+]{0-9}+ | 'CHARACTER | v | # ]

*** Implemented CL Format Control Directives

   Documentation syntax: Uppercase characters represent the
corresponding control directive characters. Lowercase characters
represent control directive parameter descriptions.

`~A'
     Any (print as `display' does).
    `~@A'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARA'
          full padding.

`~S'
     S-expression (print as `write' does).
    `~@S'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARS'
          full padding.

`~D'
     Decimal.
    `~@D'
          print number sign always.

    `~:D'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARD'
          padding.

`~X'
     Hexadecimal.
    `~@X'
          print number sign always.

    `~:X'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARX'
          padding.

`~O'
     Octal.
    `~@O'
          print number sign always.

    `~:O'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARO'
          padding.

`~B'
     Binary.
    `~@B'
          print number sign always.

    `~:B'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARB'
          padding.

`~NR'
     Radix N.
    `~N,MINCOL,PADCHAR,COMMACHARR'
          padding.

`~@R'
     print a number as a Roman numeral.

`~:@R'
     print a number as an "old fashioned" Roman numeral.

`~:R'
     print a number as an ordinal English number.

`~:@R'
     print a number as a cardinal English number.

`~P'
     Plural.
    `~@P'
          prints `y' and `ies'.

    `~:P'
          as `~P but jumps 1 argument backward.'

    `~:@P'
          as `~@P but jumps 1 argument backward.'

`~C'
     Character.
    `~@C'
          prints a character as the reader can understand it (i.e. `#\'
          prefixing).

    `~:C'
          prints a character as emacs does (eg. `^C' for ASCII 03).

`~F'
     Fixed-format floating-point (prints a flonum like MMM.NNN).
    `~WIDTH,DIGITS,SCALE,OVERFLOWCHAR,PADCHARF'
    `~@F'
          If the number is positive a plus sign is printed.

`~E'
     Exponential floating-point (prints a flonum like MMM.NNN`E'EE).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARE'
    `~@E'
          If the number is positive a plus sign is printed.

`~G'
     General floating-point (prints a flonum either fixed or
     exponential).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARG'
    `~@G'
          If the number is positive a plus sign is printed.

`~$'
     Dollars floating-point (prints a flonum in fixed with signs
     separated).
    `~DIGITS,SCALE,WIDTH,PADCHAR$'
    `~@$'
          If the number is positive a plus sign is printed.

    `~:@$'
          A sign is always printed and appears before the padding.

    `~:$'
          The sign appears before the padding.

`~%'
     Newline.
    `~N%'
          print N newlines.

`~&'
     print newline if not at the beginning of the output line.
    `~N&'
          prints `~&' and then N-1 newlines.

`~|'
     Page Separator.
    `~N|'
          print N page separators.

`~~'
     Tilde.
    `~N~'
          print N tildes.

`~'<newline>
     Continuation Line.
    `~:'<newline>
          newline is ignored, white space left.

    `~@'<newline>
          newline is left, white space ignored.

`~T'
     Tabulation.
    `~@T'
          relative tabulation.

    `~COLNUM,COLINCT'
          full tabulation.

`~?'
     Indirection (expects indirect arguments as a list).
    `~@?'
          extracts indirect arguments from format arguments.

`~(STR~)'
     Case conversion (converts by `string-downcase').
    `~:(STR~)'
          converts by `string-capitalize'.

    `~@(STR~)'
          converts by `string-capitalize-first'.

    `~:@(STR~)'
          converts by `string-upcase'.

`~*'
     Argument Jumping (jumps 1 argument forward).
    `~N*'
          jumps N arguments forward.

    `~:*'
          jumps 1 argument backward.

    `~N:*'
          jumps N arguments backward.

    `~@*'
          jumps to the 0th argument.

    `~N@*'
          jumps to the Nth argument (beginning from 0)

`~[STR0~;STR1~;...~;STRN~]'
     Conditional Expression (numerical clause conditional).
    `~N['
          take argument from N.

    `~@['
          true test conditional.

    `~:['
          if-else-then conditional.

    `~;'
          clause separator.

    `~:;'
          default clause follows.

`~{STR~}'
     Iteration (args come from the next argument (a list)).
    `~N{'
          at most N iterations.

    `~:{'
          args from next arg (a list of lists).

    `~@{'
          args from the rest of arguments.

    `~:@{'
          args from the rest args (lists).

`~^'
     Up and out.
    `~N^'
          aborts if N = 0

    `~N,M^'
          aborts if N = M

    `~N,M,K^'
          aborts if N <= M <= K

*** Not Implemented CL Format Control Directives

`~:A'
     print `#f' as an empty list (see below).

`~:S'
     print `#f' as an empty list (see below).

`~<~>'
     Justification.

`~:^'
     (sorry I don't understand its semantics completely)

*** Extended, Replaced and Additional Control Directives

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHD'
`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHX'
`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHO'
`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHB'
`~N,MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHR'
     COMMAWIDTH is the number of characters between two comma
     characters.

`~I'
     print a R4RS complex number as `~F~@Fi' with passed parameters for
     `~F'.

`~Y'
     Pretty print formatting of an argument for scheme code lists.

`~K'
     Same as `~?.'

`~!'
     Flushes the output if format DESTINATION is a port.

`~_'
     Print a `#\space' character
    `~N_'
          print N `#\space' characters.

`~/'
     Print a `#\tab' character
    `~N/'
          print N `#\tab' characters.

`~NC'
     Takes N as an integer representation for a character. No arguments
     are consumed. N is converted to a character by `integer->char'.  N
     must be a positive decimal number.

`~:S'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~:A'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~Q'
     Prints information and a copyright notice on the format
     implementation.
    `~:Q'
          prints format version.

`~F, ~E, ~G, ~$'
     may also print number strings, i.e. passing a number as a string
     and format it accordingly.

*** Configuration Variables

   The format module exports some configuration variables to suit the
systems and users needs. There should be no modification necessary for
the configuration that comes with Guile.  Format detects automatically
if the running scheme system implements floating point numbers and
complex numbers.

format:symbol-case-conv
     Symbols are converted by `symbol->string' so the case type of the
     printed symbols is implementation dependent.
     `format:symbol-case-conv' is a one arg closure which is either
     `#f' (no conversion), `string-upcase', `string-downcase' or
     `string-capitalize'. (default `#f')

format:iobj-case-conv
     As FORMAT:SYMBOL-CASE-CONV but applies for the representation of
     implementation internal objects. (default `#f')

format:expch
     The character prefixing the exponent value in `~E' printing.
     (default `#\E')

*** Compatibility With Other Format Implementations

SLIB format 2.x:
     See `format.doc'.

SLIB format 1.4:
     Downward compatible except for padding support and `~A', `~S',
     `~P', `~X' uppercase printing.  SLIB format 1.4 uses C-style
     `printf' padding support which is completely replaced by the CL
     `format' padding style.

MIT C-Scheme 7.1:
     Downward compatible except for `~', which is not documented
     (ignores all characters inside the format string up to a newline
     character).  (7.1 implements `~a', `~s', ~NEWLINE, `~~', `~%',
     numerical and variable parameters and `:/@' modifiers in the CL
     sense).

Elk 1.5/2.0:
     Downward compatible except for `~A' and `~S' which print in
     uppercase.  (Elk implements `~a', `~s', `~~', and `~%' (no
     directive parameters or modifiers)).

Scheme->C 01nov91:
     Downward compatible except for an optional destination parameter:
     S2C accepts a format call without a destination which returns a
     formatted string. This is equivalent to a #f destination in S2C.
     (S2C implements `~a', `~s', `~c', `~%', and `~~' (no directive
     parameters or modifiers)).


** Changes to string-handling functions.

These functions were added to support the (ice-9 format) module, above.

*** New function: string-upcase STRING
*** New function: string-downcase STRING

These are non-destructive versions of the existing string-upcase! and
string-downcase! functions.

*** New function: string-capitalize! STRING
*** New function: string-capitalize STRING

These functions convert the first letter of each word in the string to
upper case.  Thus:

      (string-capitalize "howdy there")
      => "Howdy There"

As with the other functions, string-capitalize! modifies the string in
place, while string-capitalize returns a modified copy of its argument.

*** New function: string-ci->symbol STRING

Return a symbol whose name is STRING, but having the same case as if
the symbol had be read by `read'.

Guile can be configured to be sensitive or insensitive to case
differences in Scheme identifiers.  If Guile is case-insensitive, all
symbols are converted to lower case on input.  The `string-ci->symbol'
function returns a symbol whose name in STRING, transformed as Guile
would if STRING were input.

*** New function: substring-move! STRING1 START END STRING2 START

Copy the substring of STRING1 from START (inclusive) to END
(exclusive) to STRING2 at START.  STRING1 and STRING2 may be the same
string, and the source and destination areas may overlap; in all
cases, the function behaves as if all the characters were copied
simultanously.

*** Extended functions: substring-move-left! substring-move-right!

These functions now correctly copy arbitrarily overlapping substrings;
they are both synonyms for substring-move!.


** New module (ice-9 getopt-long), with the function `getopt-long'.

getopt-long is a function for parsing command-line arguments in a
manner consistent with other GNU programs.

(getopt-long ARGS GRAMMAR)
Parse the arguments ARGS according to the argument list grammar GRAMMAR.

ARGS should be a list of strings.  Its first element should be the
name of the program; subsequent elements should be the arguments
that were passed to the program on the command line.  The
`program-arguments' procedure returns a list of this form.

GRAMMAR is a list of the form:
((OPTION (PROPERTY VALUE) ...) ...)

Each OPTION should be a symbol.  `getopt-long' will accept a
command-line option named `--OPTION'.
Each option can have the following (PROPERTY VALUE) pairs:

  (single-char CHAR) --- Accept `-CHAR' as a single-character
            equivalent to `--OPTION'.  This is how to specify traditional
            Unix-style flags.
  (required? BOOL) --- If BOOL is true, the option is required.
            getopt-long will raise an error if it is not found in ARGS.
  (value BOOL) --- If BOOL is #t, the option accepts a value; if
            it is #f, it does not; and if it is the symbol
            `optional', the option may appear in ARGS with or
            without a value.
  (predicate FUNC) --- If the option accepts a value (i.e. you
            specified `(value #t)' for this option), then getopt
            will apply FUNC to the value, and throw an exception
            if it returns #f.  FUNC should be a procedure which
            accepts a string and returns a boolean value; you may
            need to use quasiquotes to get it into GRAMMAR.

The (PROPERTY VALUE) pairs may occur in any order, but each
property may occur only once.  By default, options do not have
single-character equivalents, are not required, and do not take
values.

In ARGS, single-character options may be combined, in the usual
Unix fashion: ("-x" "-y") is equivalent to ("-xy").  If an option
accepts values, then it must be the last option in the
combination; the value is the next argument.  So, for example, using
the following grammar:
     ((apples    (single-char #\a))
      (blimps    (single-char #\b) (value #t))
      (catalexis (single-char #\c) (value #t)))
the following argument lists would be acceptable:
   ("-a" "-b" "bang" "-c" "couth")     ("bang" and "couth" are the values
                                        for "blimps" and "catalexis")
   ("-ab" "bang" "-c" "couth")         (same)
   ("-ac" "couth" "-b" "bang")         (same)
   ("-abc" "couth" "bang")             (an error, since `-b' is not the
                                        last option in its combination)

If an option's value is optional, then `getopt-long' decides
whether it has a value by looking at what follows it in ARGS.  If
the next element is a string, and it does not appear to be an
option itself, then that string is the option's value.

The value of a long option can appear as the next element in ARGS,
or it can follow the option name, separated by an `=' character.
Thus, using the same grammar as above, the following argument lists
are equivalent:
  ("--apples" "Braeburn" "--blimps" "Goodyear")
  ("--apples=Braeburn" "--blimps" "Goodyear")
  ("--blimps" "Goodyear" "--apples=Braeburn")

If the option "--" appears in ARGS, argument parsing stops there;
subsequent arguments are returned as ordinary arguments, even if
they resemble options.  So, in the argument list:
        ("--apples" "Granny Smith" "--" "--blimp" "Goodyear")
`getopt-long' will recognize the `apples' option as having the
value "Granny Smith", but it will not recognize the `blimp'
option; it will return the strings "--blimp" and "Goodyear" as
ordinary argument strings.

The `getopt-long' function returns the parsed argument list as an
assocation list, mapping option names --- the symbols from GRAMMAR
--- onto their values, or #t if the option does not accept a value.
Unused options do not appear in the alist.

All arguments that are not the value of any option are returned
as a list, associated with the empty list.

`getopt-long' throws an exception if:
- it finds an unrecognized option in ARGS
- a required option is omitted
- an option that requires an argument doesn't get one
- an option that doesn't accept an argument does get one (this can
  only happen using the long option `--opt=value' syntax)
- an option predicate fails

So, for example:

(define grammar
  `((lockfile-dir (required? #t)
                  (value #t)
                  (single-char #\k)
                  (predicate ,file-is-directory?))
    (verbose (required? #f)
             (single-char #\v)
             (value #f))
    (x-includes (single-char #\x))
    (rnet-server (single-char #\y)
                 (predicate ,string?))))

(getopt-long '("my-prog" "-vk" "/tmp" "foo1" "--x-includes=/usr/include"
               "--rnet-server=lamprod" "--" "-fred" "foo2" "foo3")
               grammar)
=> ((() "foo1" "-fred" "foo2" "foo3")
    (rnet-server . "lamprod")
    (x-includes . "/usr/include")
    (lockfile-dir . "/tmp")
    (verbose . #t))

** The (ice-9 getopt-gnu-style) module is obsolete; use (ice-9 getopt-long).

It will be removed in a few releases.

** New syntax: lambda*
** New syntax: define*
** New syntax: define*-public
** New syntax: defmacro*
** New syntax: defmacro*-public
Guile now supports optional arguments.

`lambda*', `define*', `define*-public', `defmacro*' and
`defmacro*-public' are identical to the non-* versions except that
they use an extended type of parameter list that has the following BNF
syntax (parentheses are literal, square brackets indicate grouping,
and `*', `+' and `?' have the usual meaning):

   ext-param-list ::= ( [identifier]* [#&optional [ext-var-decl]+]?
      [#&key [ext-var-decl]+ [#&allow-other-keys]?]?
      [[#&rest identifier]|[. identifier]]? ) | [identifier]

   ext-var-decl ::= identifier | ( identifier expression )

The semantics are best illustrated with the following documentation
and examples for `lambda*':

 lambda* args . body
   lambda extended for optional and keyword arguments

 lambda* creates a procedure that takes optional arguments. These
 are specified by putting them inside brackets at the end of the
 paramater list, but before any dotted rest argument. For example,
   (lambda* (a b #&optional c d . e) '())
 creates a procedure with fixed arguments a and b, optional arguments c
 and d, and rest argument e. If the optional arguments are omitted
 in a call, the variables for them are unbound in the procedure. This
 can be checked with the bound? macro.

 lambda* can also take keyword arguments. For example, a procedure
 defined like this:
   (lambda* (#&key xyzzy larch) '())
 can be called with any of the argument lists (#:xyzzy 11)
 (#:larch 13) (#:larch 42 #:xyzzy 19) (). Whichever arguments
 are given as keywords are bound to values.

 Optional and keyword arguments can also be given default values
 which they take on when they are not present in a call, by giving a
 two-item list in place of an optional argument, for example in:
   (lambda* (foo #&optional (bar 42) #&key (baz 73)) (list foo bar baz))
 foo is a fixed argument, bar is an optional argument with default
 value 42, and baz is a keyword argument with default value 73.
 Default value expressions are not evaluated unless they are needed
 and until the procedure is called.

 lambda* now supports two more special parameter list keywords.

 lambda*-defined procedures now throw an error by default if a
 keyword other than one of those specified is found in the actual
 passed arguments. However, specifying #&allow-other-keys
 immediately after the kyword argument declarations restores the
 previous behavior of ignoring unknown keywords. lambda* also now
 guarantees that if the same keyword is passed more than once, the
 last one passed is the one that takes effect. For example,
  ((lambda* (#&key (heads 0) (tails 0)) (display (list heads tails)))
    #:heads 37 #:tails 42 #:heads 99)
 would result in (99 47) being displayed.

 #&rest is also now provided as a synonym for the dotted syntax rest
 argument. The argument lists (a . b) and (a #&rest b) are equivalent in
 all respects to lambda*. This is provided for more similarity to DSSSL,
 MIT-Scheme and Kawa among others, as well as for refugees from other
 Lisp dialects.

Further documentation may be found in the optargs.scm file itself.

The optional argument module also exports the macros `let-optional',
`let-optional*', `let-keywords', `let-keywords*' and `bound?'. These
are not documented here because they may be removed in the future, but
full documentation is still available in optargs.scm.

** New syntax: and-let*
Guile now supports the `and-let*' form, described in the draft SRFI-2.

Syntax: (land* (<clause> ...) <body> ...)
Each <clause> should have one of the following forms:
  (<variable> <expression>)
  (<expression>)
  <bound-variable>
Each <variable> or <bound-variable> should be an identifier.  Each
<expression> should be a valid expression.  The <body> should be a
possibly empty sequence of expressions, like the <body> of a
lambda form.

Semantics: A LAND* expression is evaluated by evaluating the
<expression> or <bound-variable> of each of the <clause>s from
left to right.  The value of the first <expression> or
<bound-variable> that evaluates to a false value is returned; the
remaining <expression>s and <bound-variable>s are not evaluated.
The <body> forms are evaluated iff all the <expression>s and
<bound-variable>s evaluate to true values.

The <expression>s and the <body> are evaluated in an environment
binding each <variable> of the preceding (<variable> <expression>)
clauses to the value of the <expression>.  Later bindings
shadow earlier bindings.

Guile's and-let* macro was contributed by Michael Livshin.

** New sorting functions

*** New function: sorted? SEQUENCE LESS?
Returns `#t' when the sequence argument is in non-decreasing order
according to LESS? (that is, there is no adjacent pair `... x y
...' for which `(less? y x)').

Returns `#f' when the sequence contains at least one out-of-order
pair.  It is an error if the sequence is neither a list nor a
vector.

*** New function: merge LIST1 LIST2 LESS?
LIST1 and LIST2 are sorted lists.
Returns the sorted list of all elements in LIST1 and LIST2.

Assume that the elements a and b1 in LIST1 and b2 in LIST2 are "equal"
in the sense that (LESS? x y) --> #f for x, y in {a, b1, b2},
and that a < b1 in LIST1.  Then a < b1 < b2 in the result.
(Here "<" should read "comes before".)

*** New procedure: merge! LIST1 LIST2 LESS?
Merges two lists, re-using the pairs of LIST1 and LIST2 to build
the result.  If the code is compiled, and LESS? constructs no new
pairs, no pairs at all will be allocated.  The first pair of the
result will be either the first pair of LIST1 or the first pair of
LIST2.

*** New function: sort SEQUENCE LESS?
Accepts either a list or a vector, and returns a new sequence
which is sorted.  The new sequence is the same type as the input.
Always `(sorted? (sort sequence less?) less?)'.  The original
sequence is not altered in any way.  The new sequence shares its
elements with the old one; no elements are copied.

*** New procedure: sort! SEQUENCE LESS
Returns its sorted result in the original boxes.  No new storage is
allocated at all.  Proper usage: (set! slist (sort! slist <))

*** New function: stable-sort SEQUENCE LESS?
Similar to `sort' but stable.  That is, if "equal" elements are
ordered a < b in the original sequence, they will have the same order
in the result.

*** New function: stable-sort! SEQUENCE LESS?
Similar to `sort!' but stable.
Uses temporary storage when sorting vectors.

*** New functions: sort-list, sort-list!
Added for compatibility with scsh.

** New built-in random number support

*** New function: random N [STATE]
Accepts a positive integer or real N and returns a number of the
same type between zero (inclusive) and N (exclusive).  The values
returned have a uniform distribution.

The optional argument STATE must be of the type produced by
`copy-random-state' or `seed->random-state'.  It defaults to the value
of the variable `*random-state*'.  This object is used to maintain the
state of the pseudo-random-number generator and is altered as a side
effect of the `random' operation.

*** New variable: *random-state*
Holds a data structure that encodes the internal state of the
random-number generator that `random' uses by default.  The nature
of this data structure is implementation-dependent.  It may be
printed out and successfully read back in, but may or may not
function correctly as a random-number state object in another
implementation.

*** New function: copy-random-state [STATE]
Returns a new object of type suitable for use as the value of the
variable `*random-state*' and as a second argument to `random'.
If argument STATE is given, a copy of it is returned.  Otherwise a
copy of `*random-state*' is returned.

*** New function: seed->random-state SEED
Returns a new object of type suitable for use as the value of the
variable `*random-state*' and as a second argument to `random'.
SEED is a string or a number.  A new state is generated and
initialized using SEED.

*** New function: random:uniform [STATE]
Returns an uniformly distributed inexact real random number in the
range between 0 and 1.

*** New procedure: random:solid-sphere! VECT [STATE]
Fills VECT with inexact real random numbers the sum of whose
squares is less than 1.0.  Thinking of VECT as coordinates in
space of dimension N = `(vector-length VECT)', the coordinates are
uniformly distributed within the unit N-shere.  The sum of the
squares of the numbers is returned.  VECT can be either a vector
or a uniform vector of doubles.

*** New procedure: random:hollow-sphere! VECT [STATE]
Fills VECT with inexact real random numbers the sum of whose squares
is equal to 1.0.  Thinking of VECT as coordinates in space of
dimension n = `(vector-length VECT)', the coordinates are uniformly
distributed over the surface of the unit n-shere.  VECT can be either
a vector or a uniform vector of doubles.

*** New function: random:normal [STATE]
Returns an inexact real in a normal distribution with mean 0 and
standard deviation 1.  For a normal distribution with mean M and
standard deviation D use `(+ M (* D (random:normal)))'.

*** New procedure: random:normal-vector! VECT [STATE]
Fills VECT with inexact real random numbers which are independent and
standard normally distributed (i.e., with mean 0 and variance 1).
VECT can be either a vector or a uniform vector of doubles.

*** New function: random:exp STATE
Returns an inexact real in an exponential distribution with mean 1.
For an exponential distribution with mean U use (* U (random:exp)).

** The range of logand, logior, logxor, logtest, and logbit? have changed.

These functions now operate on numbers in the range of a C unsigned
long.

These functions used to operate on numbers in the range of a C signed
long; however, this seems inappropriate, because Guile integers don't
overflow.

** New function: make-guardian
This is an implementation of guardians as described in
R. Kent Dybvig, Carl Bruggeman, and David Eby (1993) "Guardians in a
Generation-Based Garbage Collector" ACM SIGPLAN Conference on
Programming Language Design and Implementation, June 1993
ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/guardians.ps.gz

** New functions: delq1!, delv1!, delete1!
These procedures behave similar to delq! and friends but delete only
one object if at all.

** New function: unread-string STRING PORT
Unread STRING to PORT, that is, push it back onto the port so that
next read operation will work on the pushed back characters.

** unread-char can now be called multiple times
If unread-char is called multiple times, the unread characters will be
read again in last-in first-out order.

** the procedures uniform-array-read! and uniform-array-write! now
work on any kind of port, not just ports which are open on a file.

** Now 'l' in a port mode requests line buffering.

** The procedure truncate-file now works on string ports as well
as file ports.  If the size argument is omitted, the current
file position is used.

** new procedure: seek PORT/FDES OFFSET WHENCE
The arguments are the same as for the old fseek procedure, but it
works on string ports as well as random-access file ports.

** the fseek procedure now works on string ports, since it has been
redefined using seek.

** the setvbuf procedure now uses a default size if mode is _IOFBF and
size is not supplied.

** the newline procedure no longer flushes the port if it's not
line-buffered: previously it did if it was the current output port.

** open-pipe and close-pipe are no longer primitive procedures, but
an emulation can be obtained using `(use-modules (ice-9 popen))'.

** the freopen procedure has been removed.

** new procedure: drain-input PORT
Drains PORT's read buffers (including any pushed-back characters)
and returns the contents as a single string.

** New function: map-in-order PROC LIST1 LIST2 ...
Version of `map' which guarantees that the procedure is applied to the
lists in serial order.

** Renamed `serial-array-copy!' and `serial-array-map!' to
`array-copy-in-order!' and `array-map-in-order!'.  The old names are
now obsolete and will go away in release 1.5.

** New syntax: collect BODY1 ...
Version of `begin' which returns a list of the results of the body
forms instead of the result of the last body form.  In contrast to
`begin', `collect' allows an empty body.

** New functions: read-history FILENAME, write-history FILENAME
Read/write command line history from/to file.  Returns #t on success
and #f if an error occured.

** `ls' and `lls' in module (ice-9 ls) now handle no arguments.

These procedures return a list of definitions available in the specified
argument, a relative module reference.  In the case of no argument,
`(current-module)' is now consulted for definitions to return, instead
of simply returning #f, the former behavior.

** The #/ syntax for lists is no longer supported.

Earlier versions of Scheme accepted this syntax, but printed a
warning.

** Guile no longer consults the SCHEME_LOAD_PATH environment variable.

Instead, you should set GUILE_LOAD_PATH to tell Guile where to find
modules.

* Changes to the gh_ interface

** gh_scm2doubles

Now takes a second argument which is the result array.  If this
pointer is NULL, a new array is malloced (the old behaviour).

** gh_chars2byvect, gh_shorts2svect, gh_floats2fvect, gh_scm2chars,
   gh_scm2shorts, gh_scm2longs, gh_scm2floats

New functions.

* Changes to the scm_ interface

** Function: scm_make_named_hook (char* name, int n_args)

Creates a hook in the same way as make-hook above but also
binds a variable named NAME to it.

This is the typical way of creating a hook from C code.

Currently, the variable is created in the "current" module.  This
might change when we get the new module system.

** The smob interface

The interface for creating smobs has changed.  For documentation, see
data-rep.info (made from guile-core/doc/data-rep.texi).

*** Deprecated function: SCM scm_newsmob (scm_smobfuns *)

>>> This function will be removed in 1.3.4. <<<

It is replaced by:

*** Function: SCM scm_make_smob_type (const char *name, scm_sizet size)
This function adds a new smob type, named NAME, with instance size
SIZE to the system.  The return value is a tag that is used in
creating instances of the type.  If SIZE is 0, then no memory will
be allocated when instances of the smob are created, and nothing
will be freed by the default free function.

*** Function: void scm_set_smob_mark (long tc, SCM (*mark) (SCM))
This function sets the smob marking procedure for the smob type
specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Function: void scm_set_smob_free (long tc, SCM (*mark) (SCM))
This function sets the smob freeing procedure for the smob type
specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Function: void scm_set_smob_print (tc, print)

 - Function: void scm_set_smob_print (long tc,
			              scm_sizet (*print) (SCM,
						          SCM,
							  scm_print_state *))

This function sets the smob printing procedure for the smob type
specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Function: void scm_set_smob_equalp (long tc, SCM (*equalp) (SCM, SCM))
This function sets the smob equality-testing predicate for the
smob type specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Macro: void SCM_NEWSMOB (SCM var, long tc, void *data)
Make VALUE contain a smob instance of the type with type code TC and
smob data DATA.  VALUE must be previously declared as C type `SCM'.

*** Macro: fn_returns SCM_RETURN_NEWSMOB (long tc, void *data)
This macro expands to a block of code that creates a smob instance
of the type with type code TC and smob data DATA, and returns that
`SCM' value.  It should be the last piece of code in a block.

** The interfaces for using I/O ports and implementing port types
(ptobs) have changed significantly.  The new interface is based on
shared access to buffers and a new set of ptob procedures.

*** scm_newptob has been removed

It is replaced by:

*** Function: SCM scm_make_port_type (type_name, fill_buffer, write_flush)

- Function: SCM scm_make_port_type (char *type_name,
                                    int (*fill_buffer) (SCM port),
                                    void (*write_flush) (SCM port));

Similarly to the new smob interface, there is a set of function
setters by which the user can customize the behaviour of his port
type.  See ports.h (scm_set_port_XXX).

** scm_strport_to_string: New function: creates a new string from
a string port's buffer.

** Plug in interface for random number generators
The variable `scm_the_rng' in random.c contains a value and three
function pointers which together define the current random number
generator being used by the Scheme level interface and the random
number library functions.

The user is free to replace the default generator with the generator
of his own choice.

*** Variable: size_t scm_the_rng.rstate_size
The size of the random state type used by the current RNG
measured in chars.

*** Function: unsigned long scm_the_rng.random_bits (scm_rstate *STATE)
Given the random STATE, return 32 random bits.

*** Function: void scm_the_rng.init_rstate (scm_rstate *STATE, chars *S, int N)
Seed random state STATE using string S of length N.

*** Function: scm_rstate *scm_the_rng.copy_rstate (scm_rstate *STATE)
Given random state STATE, return a malloced copy.

** Default RNG
The default RNG is the MWC (Multiply With Carry) random number
generator described by George Marsaglia at the Department of
Statistics and Supercomputer Computations Research Institute, The
Florida State University (http://stat.fsu.edu/~geo).

It uses 64 bits, has a period of 4578426017172946943 (4.6e18), and
passes all tests in the DIEHARD test suite
(http://stat.fsu.edu/~geo/diehard.html).  The generation of 32 bits
costs one multiply and one add on platforms which either supports long
longs (gcc does this on most systems) or have 64 bit longs.  The cost
is four multiply on other systems but this can be optimized by writing
scm_i_uniform32 in assembler.

These functions are provided through the scm_the_rng interface for use
by libguile and the application.

*** Function: unsigned long scm_i_uniform32 (scm_i_rstate *STATE)
Given the random STATE, return 32 random bits.
Don't use this function directly.  Instead go through the plugin
interface (see "Plug in interface" above).

*** Function: void scm_i_init_rstate (scm_i_rstate *STATE, char *SEED, int N)
Initialize STATE using SEED of length N.

*** Function: scm_i_rstate *scm_i_copy_rstate (scm_i_rstate *STATE)
Return a malloc:ed copy of STATE.  This function can easily be re-used
in the interfaces to other RNGs.

** Random number library functions
These functions use the current RNG through the scm_the_rng interface.
It might be a good idea to use these functions from your C code so
that only one random generator is used by all code in your program.

The default random state is stored in:

*** Variable: SCM scm_var_random_state
Contains the vcell of the Scheme variable "*random-state*" which is
used as default state by all random number functions in the Scheme
level interface.

Example:

  double x = scm_c_uniform01 (SCM_RSTATE (SCM_CDR (scm_var_random_state)));

*** Function: scm_rstate *scm_c_default_rstate (void)
This is a convenience function which returns the value of
scm_var_random_state.  An error message is generated if this value
isn't a random state.

*** Function: scm_rstate *scm_c_make_rstate (char *SEED, int LENGTH)
Make a new random state from the string SEED of length LENGTH.

It is generally not a good idea to use multiple random states in a
program.  While subsequent random numbers generated from one random
state are guaranteed to be reasonably independent, there is no such
guarantee for numbers generated from different random states.

*** Macro: unsigned long scm_c_uniform32 (scm_rstate *STATE)
Return 32 random bits.

*** Function: double scm_c_uniform01 (scm_rstate *STATE)
Return a sample from the uniform(0,1) distribution.

*** Function: double scm_c_normal01 (scm_rstate *STATE)
Return a sample from the normal(0,1) distribution.

*** Function: double scm_c_exp1 (scm_rstate *STATE)
Return a sample from the exp(1) distribution.

*** Function: unsigned long scm_c_random (scm_rstate *STATE, unsigned long M)
Return a sample from the discrete uniform(0,M) distribution.

*** Function: SCM scm_c_random_bignum (scm_rstate *STATE, SCM M)
Return a sample from the discrete uniform(0,M) distribution.
M must be a bignum object.  The returned value may be an INUM.



Changes in Guile 1.3 (released Monday, October 19, 1998):

* Changes to the distribution

** We renamed the SCHEME_LOAD_PATH environment variable to GUILE_LOAD_PATH.
To avoid conflicts, programs should name environment variables after
themselves, except when there's a common practice establishing some
other convention.

For now, Guile supports both GUILE_LOAD_PATH and SCHEME_LOAD_PATH,
giving the former precedence, and printing a warning message if the
latter is set.  Guile 1.4 will not recognize SCHEME_LOAD_PATH at all.

** The header files related to multi-byte characters have been removed.
They were: libguile/extchrs.h and libguile/mbstrings.h.  Any C code
which referred to these explicitly will probably need to be rewritten,
since the support for the variant string types has been removed; see
below.

** The header files append.h and sequences.h have been removed.  These
files implemented non-R4RS operations which would encourage
non-portable programming style and less easy-to-read code.

* Changes to the stand-alone interpreter

** New procedures have been added to implement a "batch mode":

*** Function: batch-mode?

    Returns a boolean indicating whether the interpreter is in batch
    mode.

*** Function: set-batch-mode?! ARG

    If ARG is true, switches the interpreter to batch mode.  The `#f'
    case has not been implemented.

** Guile now provides full command-line editing, when run interactively.
To use this feature, you must have the readline library installed.
The Guile build process will notice it, and automatically include
support for it.

The readline library is available via anonymous FTP from any GNU
mirror site; the canonical location is "ftp://prep.ai.mit.edu/pub/gnu".

** the-last-stack is now a fluid.

* Changes to the procedure for linking libguile with your programs

** You can now use the `guile-config' utility to build programs that use Guile.

Guile now includes a command-line utility called `guile-config', which
can provide information about how to compile and link programs that
use Guile.

*** `guile-config compile' prints any C compiler flags needed to use Guile.
You should include this command's output on the command line you use
to compile C or C++ code that #includes the Guile header files.  It's
usually just a `-I' flag to help the compiler find the Guile headers.


*** `guile-config link' prints any linker flags necessary to link with Guile.

This command writes to its standard output a list of flags which you
must pass to the linker to link your code against the Guile library.
The flags include '-lguile' itself, any other libraries the Guile
library depends upon, and any `-L' flags needed to help the linker
find those libraries.

For example, here is a Makefile rule that builds a program named 'foo'
from the object files ${FOO_OBJECTS}, and links them against Guile:

  foo: ${FOO_OBJECTS}
	  ${CC} ${CFLAGS} ${FOO_OBJECTS} `guile-config link` -o foo

Previous Guile releases recommended that you use autoconf to detect
which of a predefined set of libraries were present on your system.
It is more robust to use `guile-config', since it records exactly which
libraries the installed Guile library requires.

This was originally called `build-guile', but was renamed to
`guile-config' before Guile 1.3 was released, to be consistent with
the analogous script for the GTK+ GUI toolkit, which is called
`gtk-config'.


** Use the GUILE_FLAGS macro in your configure.in file to find Guile.

If you are using the GNU autoconf package to configure your program,
you can use the GUILE_FLAGS autoconf macro to call `guile-config'
(described above) and gather the necessary values for use in your
Makefiles.

The GUILE_FLAGS macro expands to configure script code which runs the
`guile-config' script, to find out where Guile's header files and
libraries are installed.  It sets two variables, marked for
substitution, as by AC_SUBST.

  GUILE_CFLAGS --- flags to pass to a C or C++ compiler to build
    code that uses Guile header files.  This is almost always just a
    -I flag.

  GUILE_LDFLAGS --- flags to pass to the linker to link a
    program against Guile.  This includes `-lguile' for the Guile
    library itself, any libraries that Guile itself requires (like
    -lqthreads), and so on.  It may also include a -L flag to tell the
    compiler where to find the libraries.

GUILE_FLAGS is defined in the file guile.m4, in the top-level
directory of the Guile distribution.  You can copy it into your
package's aclocal.m4 file, and then use it in your configure.in file.

If you are using the `aclocal' program, distributed with GNU automake,
to maintain your aclocal.m4 file, the Guile installation process
installs guile.m4 where aclocal will find it.  All you need to do is
use GUILE_FLAGS in your configure.in file, and then run `aclocal';
this will copy the definition of GUILE_FLAGS into your aclocal.m4
file.


* Changes to Scheme functions and syntax

** Multi-byte strings have been removed, as have multi-byte and wide
ports.  We felt that these were the wrong approach to
internationalization support.

** New function: readline [PROMPT]
Read a line from the terminal, and allow the user to edit it,
prompting with PROMPT.  READLINE provides a large set of Emacs-like
editing commands, lets the user recall previously typed lines, and
works on almost every kind of terminal, including dumb terminals.

READLINE assumes that the cursor is at the beginning of the line when
it is invoked.  Thus, you can't print a prompt yourself, and then call
READLINE; you need to package up your prompt as a string, pass it to
the function, and let READLINE print the prompt itself.  This is
because READLINE needs to know the prompt's screen width.

For Guile to provide this function, you must have the readline
library, version 2.1 or later, installed on your system.  Readline is
available via anonymous FTP from prep.ai.mit.edu in pub/gnu, or from
any GNU mirror site.

See also ADD-HISTORY function.

** New function: add-history STRING
Add STRING as the most recent line in the history used by the READLINE
command.  READLINE does not add lines to the history itself; you must
call ADD-HISTORY to make previous input available to the user.

** The behavior of the read-line function has changed.

This function now uses standard C library functions to read the line,
for speed.  This means that it doesn not respect the value of
scm-line-incrementors; it assumes that lines are delimited with
#\newline.

(Note that this is read-line, the function that reads a line of text
from a port, not readline, the function that reads a line from a
terminal, providing full editing capabilities.)

** New module (ice-9 getopt-gnu-style): Parse command-line arguments.

This module provides some simple argument parsing.  It exports one
function:

Function: getopt-gnu-style ARG-LS
    Parse a list of program arguments into an alist of option
    descriptions.

    Each item in the list of program arguments is examined to see if
    it meets the syntax of a GNU long-named option.  An argument like
    `--MUMBLE' produces an element of the form (MUMBLE . #t) in the
    returned alist, where MUMBLE is a keyword object with the same
    name as the argument.  An argument like `--MUMBLE=FROB' produces
    an element of the form (MUMBLE . FROB), where FROB is a string.

    As a special case, the returned alist also contains a pair whose
    car is the symbol `rest'.  The cdr of this pair is a list
    containing all the items in the argument list that are not options
    of the form mentioned above.

    The argument `--' is treated specially: all items in the argument
    list appearing after such an argument are not examined, and are
    returned in the special `rest' list.

    This function does not parse normal single-character switches.
    You will need to parse them out of the `rest' list yourself.

** The read syntax for byte vectors and short vectors has changed.

Instead of #bytes(...), write #y(...).

Instead of #short(...), write #h(...).

This may seem nutty, but, like the other uniform vectors, byte vectors
and short vectors want to have the same print and read syntax (and,
more basic, want to have read syntax!).  Changing the read syntax to
use multiple characters after the hash sign breaks with the
conventions used in R5RS and the conventions used for the other
uniform vectors.  It also introduces complexity in the current reader,
both on the C and Scheme levels.  (The Right solution is probably to
change the syntax and prototypes for uniform vectors entirely.)


** The new module (ice-9 session) provides useful interactive functions.

*** New procedure: (apropos REGEXP OPTION ...)

Display a list of top-level variables whose names match REGEXP, and
the modules they are imported from.  Each OPTION should be one of the
following symbols:

  value  --- Show the value of each matching variable.
  shadow --- Show bindings shadowed by subsequently imported modules.
  full   --- Same as both `shadow' and `value'.

For example:

    guile> (apropos "trace" 'full)
    debug: trace    #<procedure trace args>
    debug: untrace  #<procedure untrace args>
    the-scm-module: display-backtrace       #<compiled-closure #<primitive-procedure gsubr-apply>>
    the-scm-module: before-backtrace-hook   ()
    the-scm-module: backtrace       #<primitive-procedure backtrace>
    the-scm-module: after-backtrace-hook    ()
    the-scm-module: has-shown-backtrace-hint?       #f
    guile>

** There are new functions and syntax for working with macros.

Guile implements macros as a special object type.  Any variable whose
top-level binding is a macro object acts as a macro.  The macro object
specifies how the expression should be transformed before evaluation.

*** Macro objects now print in a reasonable way, resembling procedures.

*** New function: (macro? OBJ)
True iff OBJ is a macro object.

*** New function: (primitive-macro? OBJ)
Like (macro? OBJ), but true only if OBJ is one of the Guile primitive
macro transformers, implemented in eval.c rather than Scheme code.

Why do we have this function?
- For symmetry with procedure? and primitive-procedure?,
- to allow custom print procedures to tell whether a macro is
  primitive, and display it differently, and
- to allow compilers and user-written evaluators to distinguish
  builtin special forms from user-defined ones, which could be
  compiled.

*** New function: (macro-type OBJ)
Return a value indicating what kind of macro OBJ is.  Possible return
values are:

    The symbol `syntax' --- a macro created by procedure->syntax.
    The symbol `macro' --- a macro created by procedure->macro.
    The symbol `macro!' --- a macro created by procedure->memoizing-macro.
    The boolean #f --- if OBJ is not a macro object.

*** New function: (macro-name MACRO)
Return the name of the macro object MACRO's procedure, as returned by
procedure-name.

*** New function: (macro-transformer MACRO)
Return the transformer procedure for MACRO.

*** New syntax: (use-syntax MODULE ... TRANSFORMER)

Specify a new macro expander to use in the current module.  Each
MODULE is a module name, with the same meaning as in the `use-modules'
form; each named module's exported bindings are added to the current
top-level environment.  TRANSFORMER is an expression evaluated in the
resulting environment which must yield a procedure to use as the
module's eval transformer: every expression evaluated in this module
is passed to this function, and the result passed to the Guile
interpreter.

*** macro-eval! is removed.  Use local-eval instead.

** Some magic has been added to the printer to better handle user
written printing routines (like record printers, closure printers).

The problem is that these user written routines must have access to
the current `print-state' to be able to handle fancy things like
detection of circular references.  These print-states have to be
passed to the builtin printing routines (display, write, etc) to
properly continue the print chain.

We didn't want to change all existing print code so that it
explicitly passes thru a print state in addition to a port.  Instead,
we extented the possible values that the builtin printing routines
accept as a `port'.  In addition to a normal port, they now also take
a pair of a normal port and a print-state.  Printing will go to the
port and the print-state will be used to control the detection of
circular references, etc.  If the builtin function does not care for a
print-state, it is simply ignored.

User written callbacks are now called with such a pair as their
`port', but because every function now accepts this pair as a PORT
argument, you don't have to worry about that.  In fact, it is probably
safest to not check for these pairs.

However, it is sometimes necessary to continue a print chain on a
different port, for example to get a intermediate string
representation of the printed value, mangle that string somehow, and
then to finally print the mangled string.  Use the new function

    inherit-print-state OLD-PORT NEW-PORT

for this.  It constructs a new `port' that prints to NEW-PORT but
inherits the print-state of OLD-PORT.

** struct-vtable-offset renamed to vtable-offset-user

** New constants: vtable-index-layout, vtable-index-vtable, vtable-index-printer

** There is now a third optional argument to make-vtable-vtable
   (and fourth to make-struct) when constructing new types (vtables).
   This argument initializes field vtable-index-printer of the vtable.

** The detection of circular references has been extended to structs.
That is, a structure that -- in the process of being printed -- prints
itself does not lead to infinite recursion.

** There is now some basic support for fluids.  Please read
"libguile/fluid.h" to find out more. It is accessible from Scheme with
the following functions and macros:

Function: make-fluid

    Create a new fluid object.  Fluids are not special variables or
    some other extension to the semantics of Scheme, but rather
    ordinary Scheme objects.  You can store them into variables (that
    are still lexically scoped, of course) or into any other place you
    like.  Every fluid has a initial value of `#f'.

Function: fluid? OBJ

    Test whether OBJ is a fluid.

Function: fluid-ref FLUID
Function: fluid-set! FLUID VAL

    Access/modify the fluid FLUID.  Modifications are only visible
    within the current dynamic root (that includes threads).

Function: with-fluids* FLUIDS VALUES THUNK

    FLUIDS is a list of fluids and VALUES a corresponding list of
    values for these fluids.  Before THUNK gets called the values are
    installed in the fluids and the old values of the fluids are
    saved in the VALUES list.  When the flow of control leaves THUNK
    or reenters it, the values get swapped again.  You might think of
    this as a `safe-fluid-excursion'.  Note that the VALUES list is
    modified by `with-fluids*'.

Macro: with-fluids ((FLUID VALUE) ...) FORM ...

    The same as `with-fluids*' but with a different syntax.  It looks
    just like `let', but both FLUID and VALUE are evaluated.  Remember,
    fluids are not special variables but ordinary objects.  FLUID
    should evaluate to a fluid.

** Changes to system call interfaces:

*** close-port, close-input-port and close-output-port now return a
boolean instead of an `unspecified' object.  #t means that the port
was successfully closed, while #f means it was already closed.  It is
also now possible for these procedures to raise an exception if an
error occurs (some errors from write can be delayed until close.)

*** the first argument to chmod, fcntl, ftell and fseek can now be a
file descriptor.

*** the third argument to fcntl is now optional.

*** the first argument to chown can now be a file descriptor or a port.

*** the argument to stat can now be a port.

*** The following new procedures have been added (most use scsh
interfaces):

*** procedure: close PORT/FD
     Similar to close-port (*note close-port: Closing Ports.), but also
     works on file descriptors.  A side effect of closing a file
     descriptor is that any ports using that file descriptor are moved
     to a different file descriptor and have their revealed counts set
     to zero.

*** procedure: port->fdes PORT
     Returns the integer file descriptor underlying PORT.  As a side
     effect the revealed count of PORT is incremented.

*** procedure: fdes->ports FDES
     Returns a list of existing ports which have FDES as an underlying
     file descriptor, without changing their revealed counts.

*** procedure: fdes->inport FDES
     Returns an existing input port which has FDES as its underlying
     file descriptor, if one exists, and increments its revealed count.
     Otherwise, returns a new input port with a revealed count of 1.

*** procedure: fdes->outport FDES
     Returns an existing output port which has FDES as its underlying
     file descriptor, if one exists, and increments its revealed count.
     Otherwise, returns a new output port with a revealed count of 1.

   The next group of procedures perform a `dup2' system call, if NEWFD
(an integer) is supplied, otherwise a `dup'.  The file descriptor to be
duplicated can be supplied as an integer or contained in a port.  The
type of value returned varies depending on which procedure is used.

   All procedures also have the side effect when performing `dup2' that
any ports using NEWFD are moved to a different file descriptor and have
their revealed counts set to zero.

*** procedure: dup->fdes PORT/FD [NEWFD]
     Returns an integer file descriptor.

*** procedure: dup->inport PORT/FD [NEWFD]
     Returns a new input port using the new file descriptor.

*** procedure: dup->outport PORT/FD [NEWFD]
     Returns a new output port using the new file descriptor.

*** procedure: dup PORT/FD [NEWFD]
     Returns a new port if PORT/FD is a port, with the same mode as the
     supplied port, otherwise returns an integer file descriptor.

*** procedure: dup->port PORT/FD MODE [NEWFD]
     Returns a new port using the new file descriptor.  MODE supplies a
     mode string for the port (*note open-file: File Ports.).

*** procedure: setenv NAME VALUE
     Modifies the environment of the current process, which is also the
     default environment inherited by child processes.

     If VALUE is `#f', then NAME is removed from the environment.
     Otherwise, the string NAME=VALUE is added to the environment,
     replacing any existing string with name matching NAME.

     The return value is unspecified.

*** procedure: truncate-file OBJ SIZE
     Truncates the file referred to by OBJ to at most SIZE bytes.  OBJ
     can be a string containing a file name or an integer file
     descriptor or port open for output on the file.  The underlying
     system calls are `truncate' and `ftruncate'.

     The return value is unspecified.

*** procedure: setvbuf PORT MODE [SIZE]
     Set the buffering mode for PORT.  MODE can be:
    `_IONBF'
          non-buffered

    `_IOLBF'
          line buffered

    `_IOFBF'
          block buffered, using a newly allocated buffer of SIZE bytes.
          However if SIZE is zero or unspecified, the port will be made
          non-buffered.

     This procedure should not be used after I/O has been performed with
     the port.

     Ports are usually block buffered by default, with a default buffer
     size.  Procedures e.g., *Note open-file: File Ports, which accept a
     mode string allow `0' to be added to request an unbuffered port.

*** procedure: fsync PORT/FD
     Copies any unwritten data for the specified output file descriptor
     to disk.  If PORT/FD is a port, its buffer is flushed before the
     underlying file descriptor is fsync'd.  The return value is
     unspecified.

*** procedure: open-fdes PATH FLAGS [MODES]
     Similar to `open' but returns a file descriptor instead of a port.

*** procedure: execle PATH ENV [ARG] ...
     Similar to `execl', but the environment of the new process is
     specified by ENV, which must be a list of strings as returned by
     the `environ' procedure.

     This procedure is currently implemented using the `execve' system
     call, but we call it `execle' because of its Scheme calling
     interface.

*** procedure: strerror ERRNO
     Returns the Unix error message corresponding to ERRNO, an integer.

*** procedure: primitive-exit [STATUS]
     Terminate the current process without unwinding the Scheme stack.
     This is would typically be useful after a fork.  The exit status
     is STATUS if supplied, otherwise zero.

*** procedure: times
     Returns an object with information about real and processor time.
     The following procedures accept such an object as an argument and
     return a selected component:

    `tms:clock'
          The current real time, expressed as time units relative to an
          arbitrary base.

    `tms:utime'
          The CPU time units used by the calling process.

    `tms:stime'
          The CPU time units used by the system on behalf of the
          calling process.

    `tms:cutime'
          The CPU time units used by terminated child processes of the
          calling process, whose status has been collected (e.g., using
          `waitpid').

    `tms:cstime'
          Similarly, the CPU times units used by the system on behalf of
          terminated child processes.

** Removed: list-length
** Removed: list-append, list-append!
** Removed: list-reverse, list-reverse!

** array-map renamed to array-map!

** serial-array-map renamed to serial-array-map!

** catch doesn't take #f as first argument any longer

Previously, it was possible to pass #f instead of a key to `catch'.
That would cause `catch' to pass a jump buffer object to the procedure
passed as second argument.  The procedure could then use this jump
buffer objekt as an argument to throw.

This mechanism has been removed since its utility doesn't motivate the
extra complexity it introduces.

** The `#/' notation for lists now provokes a warning message from Guile.
This syntax will be removed from Guile in the near future.

To disable the warning message, set the GUILE_HUSH environment
variable to any non-empty value.

** The newline character now prints as `#\newline', following the
normal Scheme notation, not `#\nl'.

* Changes to the gh_ interface

** The gh_enter function now takes care of loading the Guile startup files.
gh_enter works by calling scm_boot_guile; see the remarks below.

** Function: void gh_write (SCM x)

Write the printed representation of the scheme object x to the current
output port.  Corresponds to the scheme level `write'.

** gh_list_length renamed to gh_length.

** vector handling routines

Several major changes.  In particular, gh_vector() now resembles
(vector ...) (with a caveat -- see manual), and gh_make_vector() now
exists and behaves like (make-vector ...).  gh_vset() and gh_vref()
have been renamed gh_vector_set_x() and gh_vector_ref().  Some missing
vector-related gh_ functions have been implemented.

** pair and list routines

Implemented several of the R4RS pair and list functions that were
missing.

** gh_scm2doubles, gh_doubles2scm, gh_doubles2dvect

New function.  Converts double arrays back and forth between Scheme
and C.

* Changes to the scm_ interface

** The function scm_boot_guile now takes care of loading the startup files.

Guile's primary initialization function, scm_boot_guile, now takes
care of loading `boot-9.scm', in the `ice-9' module, to initialize
Guile, define the module system, and put together some standard
bindings.  It also loads `init.scm', which is intended to hold
site-specific initialization code.

Since Guile cannot operate properly until boot-9.scm is loaded, there
is no reason to separate loading boot-9.scm from Guile's other
initialization processes.

This job used to be done by scm_compile_shell_switches, which didn't
make much sense; in particular, it meant that people using Guile for
non-shell-like applications had to jump through hoops to get Guile
initialized properly.

** The function scm_compile_shell_switches no longer loads the startup files.
Now, Guile always loads the startup files, whenever it is initialized;
see the notes above for scm_boot_guile and scm_load_startup_files.

** Function: scm_load_startup_files
This new function takes care of loading Guile's initialization file
(`boot-9.scm'), and the site initialization file, `init.scm'.  Since
this is always called by the Guile initialization process, it's
probably not too useful to call this yourself, but it's there anyway.

** The semantics of smob marking have changed slightly.

The smob marking function (the `mark' member of the scm_smobfuns
structure) is no longer responsible for setting the mark bit on the
smob.  The generic smob handling code in the garbage collector will
set this bit.  The mark function need only ensure that any other
objects the smob refers to get marked.

Note that this change means that the smob's GC8MARK bit is typically
already set upon entry to the mark function.  Thus, marking functions
which look like this:

	{
	  if (SCM_GC8MARKP (ptr))
	    return SCM_BOOL_F;
          SCM_SETGC8MARK (ptr);
	  ... mark objects to which the smob refers ...
	}

are now incorrect, since they will return early, and fail to mark any
other objects the smob refers to.  Some code in the Guile library used
to work this way.

** The semantics of the I/O port functions in scm_ptobfuns have changed.

If you have implemented your own I/O port type, by writing the
functions required by the scm_ptobfuns and then calling scm_newptob,
you will need to change your functions slightly.

The functions in a scm_ptobfuns structure now expect the port itself
as their argument; they used to expect the `stream' member of the
port's scm_port_table structure.  This allows functions in an
scm_ptobfuns structure to easily access the port's cell (and any flags
it its CAR), and the port's scm_port_table structure.

Guile now passes the I/O port itself as the `port' argument in the
following scm_ptobfuns functions:

  int (*free) (SCM port);
  int (*fputc) (int, SCM port);
  int (*fputs) (char *, SCM port);
  scm_sizet (*fwrite) SCM_P ((char *ptr,
			      scm_sizet size,
			      scm_sizet nitems,
			      SCM port));
  int (*fflush) (SCM port);
  int (*fgetc) (SCM port);
  int (*fclose) (SCM port);

The interfaces to the `mark', `print', `equalp', and `fgets' methods
are unchanged.

If you have existing code which defines its own port types, it is easy
to convert your code to the new interface; simply apply SCM_STREAM to
the port argument to yield the value you code used to expect.

Note that since both the port and the stream have the same type in the
C code --- they are both SCM values --- the C compiler will not remind
you if you forget to update your scm_ptobfuns functions.


** Function: int scm_internal_select (int fds,
				      SELECT_TYPE *rfds,
				      SELECT_TYPE *wfds,
				      SELECT_TYPE *efds,
				      struct timeval *timeout);

This is a replacement for the `select' function provided by the OS.
It enables I/O blocking and sleeping to happen for one cooperative
thread without blocking other threads.  It also avoids busy-loops in
these situations.  It is intended that all I/O blocking and sleeping
will finally go through this function.  Currently, this function is
only available on systems providing `gettimeofday' and `select'.

** Function: SCM scm_internal_stack_catch (SCM tag,
					   scm_catch_body_t body,
					   void *body_data,
					   scm_catch_handler_t handler,
					   void *handler_data)

A new sibling to the other two C level `catch' functions
scm_internal_catch and scm_internal_lazy_catch.  Use it if you want
the stack to be saved automatically into the variable `the-last-stack'
(scm_the_last_stack_var) on error.  This is necessary if you want to
use advanced error reporting, such as calling scm_display_error and
scm_display_backtrace.  (They both take a stack object as argument.)

** Function: SCM scm_spawn_thread (scm_catch_body_t body,
				   void *body_data,
				   scm_catch_handler_t handler,
				   void *handler_data)

Spawns a new thread.  It does a job similar to
scm_call_with_new_thread but takes arguments more suitable when
spawning threads from application C code.

** The hook scm_error_callback has been removed.  It was originally
intended as a way for the user to install his own error handler.  But
that method works badly since it intervenes between throw and catch,
thereby changing the semantics of expressions like (catch #t ...).
The correct way to do it is to use one of the C level catch functions
in throw.c: scm_internal_catch/lazy_catch/stack_catch.

** Removed functions:

scm_obj_length, scm_list_length, scm_list_append, scm_list_append_x,
scm_list_reverse, scm_list_reverse_x

** New macros: SCM_LISTn where n is one of the integers 0-9.

These can be used for pretty list creation from C.  The idea is taken
from Erick Gallesio's STk.

** scm_array_map renamed to scm_array_map_x

** mbstrings are now removed

This means that the type codes scm_tc7_mb_string and
scm_tc7_mb_substring has been removed.

** scm_gen_putc, scm_gen_puts, scm_gen_write, and scm_gen_getc have changed.

Since we no longer support multi-byte strings, these I/O functions
have been simplified, and renamed.  Here are their old names, and
their new names and arguments:

scm_gen_putc   ->   void scm_putc (int c, SCM port);
scm_gen_puts   ->   void scm_puts (char *s, SCM port);
scm_gen_write  ->   void scm_lfwrite (char *ptr, scm_sizet size, SCM port);
scm_gen_getc   ->   void scm_getc (SCM port);


** The macros SCM_TYP7D and SCM_TYP7SD has been removed.

** The macro SCM_TYP7S has taken the role of the old SCM_TYP7D

SCM_TYP7S now masks away the bit which distinguishes substrings from
strings.

** scm_catch_body_t: Backward incompatible change!

Body functions to scm_internal_catch and friends do not any longer
take a second argument.  This is because it is no longer possible to
pass a #f arg to catch.

** Calls to scm_protect_object and scm_unprotect now nest properly.

The function scm_protect_object protects its argument from being freed
by the garbage collector.  scm_unprotect_object removes that
protection.

These functions now nest properly.  That is, for every object O, there
is a counter which scm_protect_object(O) increments and
scm_unprotect_object(O) decrements, if the counter is greater than
zero.  Every object's counter is zero when it is first created.  If an
object's counter is greater than zero, the garbage collector will not
reclaim its storage.

This allows you to use scm_protect_object in your code without
worrying that some other function you call will call
scm_unprotect_object, and allow it to be freed.  Assuming that the
functions you call are well-behaved, and unprotect only those objects
they protect, you can follow the same rule and have confidence that
objects will be freed only at appropriate times.


Changes in Guile 1.2 (released Tuesday, June 24 1997):

* Changes to the distribution

** Nightly snapshots are now available from ftp.red-bean.com.
The old server, ftp.cyclic.com, has been relinquished to its rightful
owner.

Nightly snapshots of the Guile development sources are now available via
anonymous FTP from ftp.red-bean.com, as /pub/guile/guile-snap.tar.gz.

Via the web, that's:  ftp://ftp.red-bean.com/pub/guile/guile-snap.tar.gz
For getit, that's:    ftp.red-bean.com:/pub/guile/guile-snap.tar.gz

** To run Guile without installing it, the procedure has changed a bit.

If you used a separate build directory to compile Guile, you'll need
to include the build directory in SCHEME_LOAD_PATH, as well as the
source directory.  See the `INSTALL' file for examples.

* Changes to the procedure for linking libguile with your programs

** The standard Guile load path for Scheme code now includes
$(datadir)/guile (usually /usr/local/share/guile).  This means that
you can install your own Scheme files there, and Guile will find them.
(Previous versions of Guile only checked a directory whose name
contained the Guile version number, so you had to re-install or move
your Scheme sources each time you installed a fresh version of Guile.)

The load path also includes $(datadir)/guile/site; we recommend
putting individual Scheme files there.  If you want to install a
package with multiple source files, create a directory for them under
$(datadir)/guile.

** Guile 1.2 will now use the Rx regular expression library, if it is
installed on your system.  When you are linking libguile into your own
programs, this means you will have to link against -lguile, -lqt (if
you configured Guile with thread support), and -lrx.

If you are using autoconf to generate configuration scripts for your
application, the following lines should suffice to add the appropriate
libraries to your link command:

### Find Rx, quickthreads and libguile.
AC_CHECK_LIB(rx, main)
AC_CHECK_LIB(qt, main)
AC_CHECK_LIB(guile, scm_shell)

The Guile 1.2 distribution does not contain sources for the Rx
library, as Guile 1.0 did.  If you want to use Rx, you'll need to
retrieve it from a GNU FTP site and install it separately.

* Changes to Scheme functions and syntax

** The dynamic linking features of Guile are now enabled by default.
You can disable them by giving the `--disable-dynamic-linking' option
to configure.

  (dynamic-link FILENAME)

    Find the object file denoted by FILENAME (a string) and link it
    into the running Guile application.  When everything works out,
    return a Scheme object suitable for representing the linked object
    file.  Otherwise an error is thrown.  How object files are
    searched is system dependent.

  (dynamic-object? VAL)

    Determine whether VAL represents a dynamically linked object file.

  (dynamic-unlink DYNOBJ)

    Unlink the indicated object file from the application.  DYNOBJ
    should be one of the values returned by `dynamic-link'.

  (dynamic-func FUNCTION DYNOBJ)

    Search the C function indicated by FUNCTION (a string or symbol)
    in DYNOBJ and return some Scheme object that can later be used
    with `dynamic-call' to actually call this function.  Right now,
    these Scheme objects are formed by casting the address of the
    function to `long' and converting this number to its Scheme
    representation.

  (dynamic-call FUNCTION DYNOBJ)

    Call the C function indicated by FUNCTION and DYNOBJ.  The
    function is passed no arguments and its return value is ignored.
    When FUNCTION is something returned by `dynamic-func', call that
    function and ignore DYNOBJ.  When FUNCTION is a string (or symbol,
    etc.), look it up in DYNOBJ; this is equivalent to

	(dynamic-call (dynamic-func FUNCTION DYNOBJ) #f)

    Interrupts are deferred while the C function is executing (with
    SCM_DEFER_INTS/SCM_ALLOW_INTS).

  (dynamic-args-call FUNCTION DYNOBJ ARGS)

    Call the C function indicated by FUNCTION and DYNOBJ, but pass it
    some arguments and return its return value.  The C function is
    expected to take two arguments and return an `int', just like
    `main':

	int c_func (int argc, char **argv);

    ARGS must be a list of strings and is converted into an array of
    `char *'.  The array is passed in ARGV and its size in ARGC.  The
    return value is converted to a Scheme number and returned from the
    call to `dynamic-args-call'.

When dynamic linking is disabled or not supported on your system,
the above functions throw errors, but they are still available.

Here is a small example that works on GNU/Linux:

  (define libc-obj (dynamic-link "libc.so"))
  (dynamic-args-call 'rand libc-obj '())

See the file `libguile/DYNAMIC-LINKING' for additional comments.

** The #/ syntax for module names is depreciated, and will be removed
in a future version of Guile.  Instead of

	#/foo/bar/baz

instead write

	(foo bar baz)

The latter syntax is more consistent with existing Lisp practice.

** Guile now does fancier printing of structures.  Structures are the
underlying implementation for records, which in turn are used to
implement modules, so all of these object now print differently and in
a more informative way.

The Scheme printer will examine the builtin variable *struct-printer*
whenever it needs to print a structure object.  When this variable is
not `#f' it is deemed to be a procedure and will be applied to the
structure object and the output port.  When *struct-printer* is `#f'
or the procedure return `#f' the structure object will be printed in
the boring #<struct 80458270> form.

This hook is used by some routines in ice-9/boot-9.scm to implement
type specific printing routines.  Please read the comments there about
"printing structs".

One of the more specific uses of structs are records.  The printing
procedure that could be passed to MAKE-RECORD-TYPE is now actually
called.  It should behave like a *struct-printer* procedure (described
above).

** Guile now supports a new R4RS-compliant syntax for keywords.  A
token of the form #:NAME, where NAME has the same syntax as a Scheme
symbol, is the external representation of the keyword named NAME.
Keyword objects print using this syntax as well, so values containing
keyword objects can be read back into Guile.  When used in an
expression, keywords are self-quoting objects.

Guile suports this read syntax, and uses this print syntax, regardless
of the current setting of the `keyword' read option.  The `keyword'
read option only controls whether Guile recognizes the `:NAME' syntax,
which is incompatible with R4RS.  (R4RS says such token represent
symbols.)

** Guile has regular expression support again.  Guile 1.0 included
functions for matching regular expressions, based on the Rx library.
In Guile 1.1, the Guile/Rx interface was removed to simplify the
distribution, and thus Guile had no regular expression support.  Guile
1.2 again supports the most commonly used functions, and supports all
of SCSH's regular expression functions.

If your system does not include a POSIX regular expression library,
and you have not linked Guile with a third-party regexp library such as
Rx, these functions will not be available.  You can tell whether your
Guile installation includes regular expression support by checking
whether the `*features*' list includes the `regex' symbol.

*** regexp functions

By default, Guile supports POSIX extended regular expressions.  That
means that the characters `(', `)', `+' and `?' are special, and must
be escaped if you wish to match the literal characters.

This regular expression interface was modeled after that implemented
by SCSH, the Scheme Shell.  It is intended to be upwardly compatible
with SCSH regular expressions.

**** Function: string-match PATTERN STR [START]
     Compile the string PATTERN into a regular expression and compare
     it with STR.  The optional numeric argument START specifies the
     position of STR at which to begin matching.

     `string-match' returns a "match structure" which describes what,
     if anything, was matched by the regular expression.  *Note Match
     Structures::.  If STR does not match PATTERN at all,
     `string-match' returns `#f'.

   Each time `string-match' is called, it must compile its PATTERN
argument into a regular expression structure.  This operation is
expensive, which makes `string-match' inefficient if the same regular
expression is used several times (for example, in a loop).  For better
performance, you can compile a regular expression in advance and then
match strings against the compiled regexp.

**** Function: make-regexp STR [FLAGS]
     Compile the regular expression described by STR, and return the
     compiled regexp structure.  If STR does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     FLAGS may be the bitwise-or of one or more of the following:

**** Constant: regexp/extended
     Use POSIX Extended Regular Expression syntax when interpreting
     STR.  If not set, POSIX Basic Regular Expression syntax is used.
     If the FLAGS argument is omitted, we assume regexp/extended.

**** Constant: regexp/icase
     Do not differentiate case.  Subsequent searches using the
     returned regular expression will be case insensitive.

**** Constant: regexp/newline
     Match-any-character operators don't match a newline.

     A non-matching list ([^...]) not containing a newline matches a
     newline.

     Match-beginning-of-line operator (^) matches the empty string
     immediately after a newline, regardless of whether the FLAGS
     passed to regexp-exec contain regexp/notbol.

     Match-end-of-line operator ($) matches the empty string
     immediately before a newline, regardless of whether the FLAGS
     passed to regexp-exec contain regexp/noteol.

**** Function: regexp-exec REGEXP STR [START [FLAGS]]
     Match the compiled regular expression REGEXP against `str'.  If
     the optional integer START argument is provided, begin matching
     from that position in the string.  Return a match structure
     describing the results of the match, or `#f' if no match could be
     found.

     FLAGS may be the bitwise-or of one or more of the following:

**** Constant: regexp/notbol
     The match-beginning-of-line operator always fails to match (but
     see the compilation flag regexp/newline above) This flag may be
     used when different portions of a string are passed to
     regexp-exec and the beginning of the string should not be
     interpreted as the beginning of the line.

**** Constant: regexp/noteol
     The match-end-of-line operator always fails to match (but see the
     compilation flag regexp/newline above)

**** Function: regexp? OBJ
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

   Regular expressions are commonly used to find patterns in one string
and replace them with the contents of another string.

**** Function: regexp-substitute PORT MATCH [ITEM...]
     Write to the output port PORT selected contents of the match
     structure MATCH.  Each ITEM specifies what should be written, and
     may be one of the following arguments:

        * A string.  String arguments are written out verbatim.

        * An integer.  The submatch with that number is written.

        * The symbol `pre'.  The portion of the matched string preceding
          the regexp match is written.

        * The symbol `post'.  The portion of the matched string
          following the regexp match is written.

     PORT may be `#f', in which case nothing is written; instead,
     `regexp-substitute' constructs a string from the specified ITEMs
     and returns that.

**** Function: regexp-substitute/global PORT REGEXP TARGET [ITEM...]
     Similar to `regexp-substitute', but can be used to perform global
     substitutions on STR.  Instead of taking a match structure as an
     argument, `regexp-substitute/global' takes two string arguments: a
     REGEXP string describing a regular expression, and a TARGET string
     which should be matched against this regular expression.

     Each ITEM behaves as in REGEXP-SUBSTITUTE, with the following
     exceptions:

        * A function may be supplied.  When this function is called, it
          will be passed one argument: a match structure for a given
          regular expression match.  It should return a string to be
          written out to PORT.

        * The `post' symbol causes `regexp-substitute/global' to recurse
          on the unmatched portion of STR.  This *must* be supplied in
          order to perform global search-and-replace on STR; if it is
          not present among the ITEMs, then `regexp-substitute/global'
          will return after processing a single match.

*** Match Structures

   A "match structure" is the object returned by `string-match' and
`regexp-exec'.  It describes which portion of a string, if any, matched
the given regular expression.  Match structures include: a reference to
the string that was checked for matches; the starting and ending
positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

   In each of the regexp match functions described below, the `match'
argument must be a match structure returned by a previous call to
`string-match' or `regexp-exec'.  Most of these functions return some
information about the original target string that was matched against a
regular expression; we will call that string TARGET for easy reference.

**** Function: regexp-match? OBJ
     Return `#t' if OBJ is a match structure returned by a previous
     call to `regexp-exec', or `#f' otherwise.

**** Function: match:substring MATCH [N]
     Return the portion of TARGET matched by subexpression number N.
     Submatch 0 (the default) represents the entire regexp match.  If
     the regular expression as a whole matched, but the subexpression
     number N did not match, return `#f'.

**** Function: match:start MATCH [N]
     Return the starting position of submatch number N.

**** Function: match:end MATCH [N]
     Return the ending position of submatch number N.

**** Function: match:prefix MATCH
     Return the unmatched portion of TARGET preceding the regexp match.

**** Function: match:suffix MATCH
     Return the unmatched portion of TARGET following the regexp match.

**** Function: match:count MATCH
     Return the number of parenthesized subexpressions from MATCH.
     Note that the entire regular expression match itself counts as a
     subexpression, and failed submatches are included in the count.

**** Function: match:string MATCH
     Return the original TARGET string.

*** Backslash Escapes

   Sometimes you will want a regexp to match characters like `*' or `$'
exactly.  For example, to check whether a particular string represents
a menu entry from an Info node, it would be useful to match it against
a regexp like `^* [^:]*::'.  However, this won't work; because the
asterisk is a metacharacter, it won't match the `*' at the beginning of
the string.  In this case, we want to make the first asterisk un-magic.

   You can do this by preceding the metacharacter with a backslash
character `\'.  (This is also called "quoting" the metacharacter, and
is known as a "backslash escape".)  When Guile sees a backslash in a
regular expression, it considers the following glyph to be an ordinary
character, no matter what special meaning it would ordinarily have.
Therefore, we can make the above example work by changing the regexp to
`^\* [^:]*::'.  The `\*' sequence tells the regular expression engine
to match only a single asterisk in the target string.

   Since the backslash is itself a metacharacter, you may force a
regexp to match a backslash in the target string by preceding the
backslash with itself.  For example, to find variable references in a
TeX program, you might want to find occurrences of the string `\let\'
followed by any number of alphabetic characters.  The regular expression
`\\let\\[A-Za-z]*' would do this: the double backslashes in the regexp
each match a single backslash in the target string.

**** Function: regexp-quote STR
     Quote each special character found in STR with a backslash, and
     return the resulting string.

   *Very important:* Using backslash escapes in Guile source code (as
in Emacs Lisp or C) can be tricky, because the backslash character has
special meaning for the Guile reader.  For example, if Guile encounters
the character sequence `\n' in the middle of a string while processing
Scheme code, it replaces those characters with a newline character.
Similarly, the character sequence `\t' is replaced by a horizontal tab.
Several of these "escape sequences" are processed by the Guile reader
before your code is executed.  Unrecognized escape sequences are
ignored: if the characters `\*' appear in a string, they will be
translated to the single character `*'.

   This translation is obviously undesirable for regular expressions,
since we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use *two*
consecutive backslashes:

     (define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))

   The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to `make-regexp' is the
string `^\* [^:]*', which is what we really want.

   This also means that in order to write a regular expression that
matches a single backslash character, the regular expression string in
the source code must include *four* backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

     (define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))

   The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings described
above.  The POSIX regular expression specification and ANSI C standard
both require these semantics.  Attempting to abandon either convention
would cause other kinds of compatibility problems, possibly more severe
ones.  Therefore, without extending the Scheme reader to support
strings with different quoting conventions (an ungainly and confusing
extension when implemented in other languages), we must adhere to this
cumbersome escape syntax.

* Changes to the gh_ interface

* Changes to the scm_ interface

* Changes to system call interfaces:

** The value returned by `raise' is now unspecified.  It throws an exception
if an error occurs.

*** A new procedure `sigaction' can be used to install signal handlers

(sigaction signum [action] [flags])

signum is the signal number, which can be specified using the value
of SIGINT etc.

If action is omitted, sigaction returns a pair: the CAR is the current
signal hander, which will be either an integer with the value SIG_DFL
(default action) or SIG_IGN (ignore), or the Scheme procedure which
handles the signal, or #f if a non-Scheme procedure handles the
signal.  The CDR contains the current sigaction flags for the handler.

If action is provided, it is installed as the new handler for signum.
action can be a Scheme procedure taking one argument, or the value of
SIG_DFL (default action) or SIG_IGN (ignore), or #f to restore
whatever signal handler was installed before sigaction was first used.
Flags can optionally be specified for the new handler (SA_RESTART is
always used if the system provides it, so need not be specified.)  The
return value is a pair with information about the old handler as
described above.

This interface does not provide access to the "signal blocking"
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.

*** A new procedure `flush-all-ports' is equivalent to running
`force-output' on every port open for output.

** Guile now provides information on how it was built, via the new
global variable, %guile-build-info.  This variable records the values
of the standard GNU makefile directory variables as an assocation
list, mapping variable names (symbols) onto directory paths (strings).
For example, to find out where the Guile link libraries were
installed, you can say:

guile -c "(display (assq-ref %guile-build-info 'libdir)) (newline)"


* Changes to the scm_ interface

** The new function scm_handle_by_message_noexit is just like the
existing scm_handle_by_message function, except that it doesn't call
exit to terminate the process.  Instead, it prints a message and just
returns #f.  This might be a more appropriate catch-all handler for
new dynamic roots and threads.


Changes in Guile 1.1 (released Friday, May 16 1997):

* Changes to the distribution.

The Guile 1.0 distribution has been split up into several smaller
pieces:
guile-core --- the Guile interpreter itself.
guile-tcltk --- the interface between the Guile interpreter and
	Tcl/Tk; Tcl is an interpreter for a stringy language, and Tk
	is a toolkit for building graphical user interfaces.
guile-rgx-ctax --- the interface between Guile and the Rx regular
	expression matcher, and the translator for the Ctax
	programming language.  These are packaged together because the
	Ctax translator uses Rx to parse Ctax source code.

This NEWS file describes the changes made to guile-core since the 1.0
release.

We no longer distribute the documentation, since it was either out of
date, or incomplete.  As soon as we have current documentation, we
will distribute it.



* Changes to the stand-alone interpreter

** guile now accepts command-line arguments compatible with SCSH, Olin
Shivers' Scheme Shell.

In general, arguments are evaluated from left to right, but there are
exceptions.  The following switches stop argument processing, and
stash all remaining command-line arguments as the value returned by
the (command-line) function.
  -s SCRIPT      load Scheme source code from FILE, and exit
  -c EXPR        evalute Scheme expression EXPR, and exit
  --             stop scanning arguments; run interactively

The switches below are processed as they are encountered.
  -l FILE        load Scheme source code from FILE
  -e FUNCTION    after reading script, apply FUNCTION to
                 command line arguments
  -ds            do -s script at this point
  --emacs        enable Emacs protocol (experimental)
  -h, --help     display this help and exit
  -v, --version  display version information and exit
  \              read arguments from following script lines

So, for example, here is a Guile script named `ekko' (thanks, Olin)
which re-implements the traditional "echo" command:

#!/usr/local/bin/guile -s
!#
(define (main args)
	(map (lambda (arg) (display arg) (display " "))
	     (cdr args))
	(newline))

(main (command-line))

Suppose we invoke this script as follows:

	ekko a speckled gecko

Through the magic of Unix script processing (triggered by the `#!'
token at the top of the file), /usr/local/bin/guile receives the
following list of command-line arguments:

	("-s" "./ekko" "a" "speckled" "gecko")

Unix inserts the name of the script after the argument specified on
the first line of the file (in this case, "-s"), and then follows that
with the arguments given to the script.  Guile loads the script, which
defines the `main' function, and then applies it to the list of
remaining command-line arguments, ("a" "speckled" "gecko").

In Unix, the first line of a script file must take the following form:

#!INTERPRETER ARGUMENT

where INTERPRETER is the absolute filename of the interpreter
executable, and ARGUMENT is a single command-line argument to pass to
the interpreter.

You may only pass one argument to the interpreter, and its length is
limited.  These restrictions can be annoying to work around, so Guile
provides a general mechanism (borrowed from, and compatible with,
SCSH) for circumventing them.

If the ARGUMENT in a Guile script is a single backslash character,
`\', Guile will open the script file, parse arguments from its second
and subsequent lines, and replace the `\' with them.  So, for example,
here is another implementation of the `ekko' script:

#!/usr/local/bin/guile \
-e main -s
!#
(define (main args)
  (for-each (lambda (arg) (display arg) (display " "))
            (cdr args))
  (newline))

If the user invokes this script as follows:

	ekko a speckled gecko

Unix expands this into

	/usr/local/bin/guile \ ekko a speckled gecko

When Guile sees the `\' argument, it replaces it with the arguments
read from the second line of the script, producing:

	/usr/local/bin/guile -e main -s ekko a speckled gecko

This tells Guile to load the `ekko' script, and apply the function
`main' to the argument list ("a" "speckled" "gecko").

Here is how Guile parses the command-line arguments:
- Each space character terminates an argument.  This means that two
  spaces in a row introduce an empty-string argument.
- The tab character is not permitted (unless you quote it with the
  backslash character, as described below), to avoid confusion.
- The newline character terminates the sequence of arguments, and will
  also terminate a final non-empty argument.  (However, a newline
  following a space will not introduce a final empty-string argument;
  it only terminates the argument list.)
- The backslash character is the escape character.  It escapes
  backslash, space, tab, and newline.  The ANSI C escape sequences
  like \n and \t are also supported.  These produce argument
  constituents; the two-character combination \n doesn't act like a
  terminating newline.  The escape sequence \NNN for exactly three
  octal digits reads as the character whose ASCII code is NNN.  As
  above, characters produced this way are argument constituents.
  Backslash followed by other characters is not allowed.

* Changes to the procedure for linking libguile with your programs

** Guile now builds and installs a shared guile library, if your
system support shared libraries.  (It still builds a static library on
all systems.)  Guile automatically detects whether your system
supports shared libraries.  To prevent Guile from buildisg shared
libraries, pass the `--disable-shared' flag to the configure script.

Guile takes longer to compile when it builds shared libraries, because
it must compile every file twice --- once to produce position-
independent object code, and once to produce normal object code.

** The libthreads library has been merged into libguile.

To link a program against Guile, you now need only link against
-lguile and -lqt; -lthreads is no longer needed.  If you are using
autoconf to generate configuration scripts for your application, the
following lines should suffice to add the appropriate libraries to
your link command:

### Find quickthreads and libguile.
AC_CHECK_LIB(qt, main)
AC_CHECK_LIB(guile, scm_shell)

* Changes to Scheme functions

** Guile Scheme's special syntax for keyword objects is now optional,
and disabled by default.

The syntax variation from R4RS made it difficult to port some
interesting packages to Guile.  The routines which accepted keyword
arguments (mostly in the module system) have been modified to also
accept symbols whose names begin with `:'.

To change the keyword syntax, you must first import the (ice-9 debug)
module:
	(use-modules (ice-9 debug))

Then you can enable the keyword syntax as follows:
	(read-set! keywords 'prefix)

To disable keyword syntax, do this:
	(read-set! keywords #f)

** Many more primitive functions accept shared substrings as
arguments.  In the past, these functions required normal, mutable
strings as arguments, although they never made use of this
restriction.

** The uniform array functions now operate on byte vectors.  These
functions are `array-fill!', `serial-array-copy!', `array-copy!',
`serial-array-map', `array-map', `array-for-each', and
`array-index-map!'.

** The new functions `trace' and `untrace' implement simple debugging
support for Scheme functions.

The `trace' function accepts any number of procedures as arguments,
and tells the Guile interpreter to display each procedure's name and
arguments each time the procedure is invoked.  When invoked with no
arguments, `trace' returns the list of procedures currently being
traced.

The `untrace' function accepts any number of procedures as arguments,
and tells the Guile interpreter not to trace them any more.  When
invoked with no arguments, `untrace' untraces all curretly traced
procedures.

The tracing in Guile has an advantage over most other systems: we
don't create new procedure objects, but mark the procedure objects
themselves.  This means that anonymous and internal procedures can be
traced.

** The function `assert-repl-prompt' has been renamed to
`set-repl-prompt!'.  It takes one argument, PROMPT.
- If PROMPT is #f, the Guile read-eval-print loop will not prompt.
- If PROMPT is a string, we use it as a prompt.
- If PROMPT is a procedure accepting no arguments, we call it, and
  display the result as a prompt.
- Otherwise, we display "> ".

** The new function `eval-string' reads Scheme expressions from a
string and evaluates them, returning the value of the last expression
in the string.  If the string contains no expressions, it returns an
unspecified value.

** The new function `thunk?' returns true iff its argument is a
procedure of zero arguments.

** `defined?' is now a builtin function, instead of syntax.  This
means that its argument should be quoted.  It returns #t iff its
argument is bound in the current module.

** The new syntax `use-modules' allows you to add new modules to your
environment without re-typing a complete `define-module' form.  It
accepts any number of module names as arguments, and imports their
public bindings into the current module.

** The new function (module-defined? NAME MODULE) returns true iff
NAME, a symbol, is defined in MODULE, a module object.

** The new function `builtin-bindings' creates and returns a hash
table containing copies of all the root module's bindings.

** The new function `builtin-weak-bindings' does the same as
`builtin-bindings', but creates a doubly-weak hash table.

** The `equal?' function now considers variable objects to be
equivalent if they have the same name and the same value.

** The new function `command-line' returns the command-line arguments
given to Guile, as a list of strings.

When using guile as a script interpreter, `command-line' returns the
script's arguments; those processed by the interpreter (like `-s' or
`-c') are omitted.  (In other words, you get the normal, expected
behavior.)  Any application that uses scm_shell to process its
command-line arguments gets this behavior as well.

** The new function `load-user-init' looks for a file called `.guile'
in the user's home directory, and loads it if it exists.  This is
mostly for use by the code generated by scm_compile_shell_switches,
but we thought it might also be useful in other circumstances.

** The new function `log10' returns the base-10 logarithm of its
argument.

** Changes to I/O functions

*** The functions `read', `primitive-load', `read-and-eval!', and
`primitive-load-path' no longer take optional arguments controlling
case insensitivity and a `#' parser.

Case sensitivity is now controlled by a read option called
`case-insensitive'.  The user can add new `#' syntaxes with the
`read-hash-extend' function (see below).

*** The new function `read-hash-extend' allows the user to change the
syntax of Guile Scheme in a somewhat controlled way.

(read-hash-extend CHAR PROC)
  When parsing S-expressions, if we read a `#' character followed by
  the character CHAR, use PROC to parse an object from the stream.
  If PROC is #f, remove any parsing procedure registered for CHAR.

  The reader applies PROC to two arguments: CHAR and an input port.

*** The new functions read-delimited and read-delimited! provide a
general mechanism for doing delimited input on streams.

(read-delimited DELIMS [PORT HANDLE-DELIM])
  Read until we encounter one of the characters in DELIMS (a string),
  or end-of-file.  PORT is the input port to read from; it defaults to
  the current input port.  The HANDLE-DELIM parameter determines how
  the terminating character is handled; it should be one of the
  following symbols:

    'trim     omit delimiter from result
    'peek     leave delimiter character in input stream
    'concat   append delimiter character to returned value
    'split    return a pair: (RESULT . TERMINATOR)

  HANDLE-DELIM defaults to 'peek.

(read-delimited! DELIMS BUF [PORT HANDLE-DELIM START END])
  A side-effecting variant of `read-delimited'.

  The data is written into the string BUF at the indices in the
  half-open interval [START, END); the default interval is the whole
  string: START = 0 and END = (string-length BUF).  The values of
  START and END must specify a well-defined interval in BUF, i.e.
  0 <= START <= END <= (string-length BUF).

  It returns NBYTES, the number of bytes read.  If the buffer filled
  up without a delimiter character being found, it returns #f.  If the
  port is at EOF when the read starts, it returns the EOF object.

  If an integer is returned (i.e., the read is successfully terminated
  by reading a delimiter character), then the HANDLE-DELIM parameter
  determines how to handle the terminating character.  It is described
  above, and defaults to 'peek.

(The descriptions of these functions were borrowed from the SCSH
manual, by Olin Shivers and Brian Carlstrom.)

*** The `%read-delimited!' function is the primitive used to implement
`read-delimited' and `read-delimited!'.

(%read-delimited! DELIMS BUF GOBBLE? [PORT START END])

This returns a pair of values: (TERMINATOR . NUM-READ).
- TERMINATOR describes why the read was terminated.  If it is a
  character or the eof object, then that is the value that terminated
  the read.  If it is #f, the function filled the buffer without finding
  a delimiting character.
- NUM-READ is the number of characters read into BUF.

If the read is successfully terminated by reading a delimiter
character, then the gobble? parameter determines what to do with the
terminating character.  If true, the character is removed from the
input stream; if false, the character is left in the input stream
where a subsequent read operation will retrieve it.  In either case,
the character is also the first value returned by the procedure call.

(The descriptions of this function was borrowed from the SCSH manual,
by Olin Shivers and Brian Carlstrom.)

*** The `read-line' and `read-line!' functions have changed; they now
trim the terminator by default; previously they appended it to the
returned string.  For the old behavior, use (read-line PORT 'concat).

*** The functions `uniform-array-read!' and `uniform-array-write!' now
take new optional START and END arguments, specifying the region of
the array to read and write.

*** The `ungetc-char-ready?' function has been removed.  We feel it's
inappropriate for an interface to expose implementation details this
way.

** Changes to the Unix library and system call interface

*** The new fcntl function provides access to the Unix `fcntl' system
call.

(fcntl PORT COMMAND VALUE)
  Apply COMMAND to PORT's file descriptor, with VALUE as an argument.
  Values for COMMAND are:

    F_DUPFD	duplicate a file descriptor
    F_GETFD	read the descriptor's close-on-exec flag
    F_SETFD     set the descriptor's close-on-exec flag to VALUE
    F_GETFL	read the descriptor's flags, as set on open
    F_SETFL	set the descriptor's flags, as set on open to VALUE
    F_GETOWN    return the process ID of a socket's owner, for SIGIO
    F_SETOWN    set the process that owns a socket to VALUE, for SIGIO
    FD_CLOEXEC  not sure what this is

For details, see the documentation for the fcntl system call.

*** The arguments to `select' have changed, for compatibility with
SCSH.  The TIMEOUT parameter may now be non-integral, yielding the
expected behavior.  The MILLISECONDS parameter has been changed to
MICROSECONDS, to more closely resemble the underlying system call.
The RVEC, WVEC, and EVEC arguments can now be vectors; the type of the
corresponding return set will be the same.

*** The arguments to the `mknod' system call have changed.  They are
now:

(mknod PATH TYPE PERMS DEV)
  Create a new file (`node') in the file system.  PATH is the name of
  the file to create.  TYPE is the kind of file to create; it should
  be 'fifo, 'block-special, or 'char-special.  PERMS specifies the
  permission bits to give the newly created file.  If TYPE is
  'block-special or 'char-special, DEV specifies which device the
  special file refers to; its interpretation depends on the kind of
  special file being created.

*** The `fork' function has been renamed to `primitive-fork', to avoid
clashing with various SCSH forks.

*** The `recv' and `recvfrom' functions have been renamed to `recv!'
and `recvfrom!'.  They no longer accept a size for a second argument;
you must pass a string to hold the received value.  They no longer
return the buffer.  Instead, `recv' returns the length of the message
received, and `recvfrom' returns a pair containing the packet's length
and originating address.

*** The file descriptor datatype has been removed, as have the
`read-fd', `write-fd', `close', `lseek', and `dup' functions.
We plan to replace these functions with a SCSH-compatible interface.

*** The `create' function has been removed; it's just a special case
of `open'.

*** There are new functions to break down process termination status
values.  In the descriptions below, STATUS is a value returned by
`waitpid'.

(status:exit-val STATUS)
  If the child process exited normally, this function returns the exit
  code for the child process (i.e., the value passed to exit, or
  returned from main).  If the child process did not exit normally,
  this function returns #f.

(status:stop-sig STATUS)
  If the child process was suspended by a signal, this function
  returns the signal that suspended the child.  Otherwise, it returns
  #f.

(status:term-sig STATUS)
  If the child process terminated abnormally, this function returns
  the signal that terminated the child.  Otherwise, this function
  returns false.

POSIX promises that exactly one of these functions will return true on
a valid STATUS value.

These functions are compatible with SCSH.

*** There are new accessors and setters for the broken-out time vectors
returned by `localtime', `gmtime', and that ilk.  They are:

  Component                 Accessor     Setter
  ========================= ============ ============
  seconds                   tm:sec       set-tm:sec
  minutes                   tm:min       set-tm:min
  hours                     tm:hour      set-tm:hour
  day of the month          tm:mday      set-tm:mday
  month                     tm:mon       set-tm:mon
  year                      tm:year      set-tm:year
  day of the week           tm:wday      set-tm:wday
  day in the year           tm:yday      set-tm:yday
  daylight saving time      tm:isdst     set-tm:isdst
  GMT offset, seconds       tm:gmtoff    set-tm:gmtoff
  name of time zone         tm:zone      set-tm:zone

*** There are new accessors for the vectors returned by `uname',
describing the host system:

  Component                                      Accessor
  ============================================== ================
  name of the operating system implementation    utsname:sysname
  network name of this machine                   utsname:nodename
  release level of the operating system          utsname:release
  version level of the operating system          utsname:version
  machine hardware platform                      utsname:machine

*** There are new accessors for the vectors returned by `getpw',
`getpwnam', `getpwuid', and `getpwent', describing entries from the
system's user database:

  Component              Accessor
  ====================== =================
  user name              passwd:name
  user password		 passwd:passwd
  user id		 passwd:uid
  group id		 passwd:gid
  real name		 passwd:gecos
  home directory	 passwd:dir
  shell program		 passwd:shell

*** There are new accessors for the vectors returned by `getgr',
`getgrnam', `getgrgid', and `getgrent', describing entries from the
system's group database:

  Component               Accessor
  ======================= ============
  group name              group:name
  group password 	  group:passwd
  group id       	  group:gid
  group members  	  group:mem

*** There are new accessors for the vectors returned by `gethost',
`gethostbyaddr', `gethostbyname', and `gethostent', describing
internet hosts:

  Component                 Accessor
  ========================= ===============
  official name of host     hostent:name
  alias list		    hostent:aliases
  host address type	    hostent:addrtype
  length of address	    hostent:length
  list of addresses	    hostent:addr-list

*** There are new accessors for the vectors returned by `getnet',
`getnetbyaddr', `getnetbyname', and `getnetent', describing internet
networks:

  Component                 Accessor
  ========================= ===============
  official name of net      netent:name
  alias list		    netent:aliases
  net number type	    netent:addrtype
  net number		    netent:net

*** There are new accessors for the vectors returned by `getproto',
`getprotobyname', `getprotobynumber', and `getprotoent', describing
internet protocols:

  Component                 Accessor
  ========================= ===============
  official protocol name    protoent:name
  alias list		    protoent:aliases
  protocol number	    protoent:proto

*** There are new accessors for the vectors returned by `getserv',
`getservbyname', `getservbyport', and `getservent', describing
internet protocols:

  Component                 Accessor
  ========================= ===============
  official service name     servent:name
  alias list		    servent:aliases
  port number		    servent:port
  protocol to use	    servent:proto

*** There are new accessors for the sockaddr structures returned by
`accept', `getsockname', `getpeername', `recvfrom!':

  Component                                Accessor
  ======================================== ===============
  address format (`family')                sockaddr:fam
  path, for file domain addresses	   sockaddr:path
  address, for internet domain addresses   sockaddr:addr
  TCP or UDP port, for internet		   sockaddr:port

*** The `getpwent', `getgrent', `gethostent', `getnetent',
`getprotoent', and `getservent' functions now return #f at the end of
the user database.  (They used to throw an exception.)

Note that calling MUMBLEent function is equivalent to calling the
corresponding MUMBLE function with no arguments.

*** The `setpwent', `setgrent', `sethostent', `setnetent',
`setprotoent', and `setservent' routines now take no arguments.

*** The `gethost', `getproto', `getnet', and `getserv' functions now
provide more useful information when they throw an exception.

*** The `lnaof' function has been renamed to `inet-lnaof'.

*** Guile now claims to have the `current-time' feature.

*** The `mktime' function now takes an optional second argument ZONE,
giving the time zone to use for the conversion.  ZONE should be a
string, in the same format as expected for the "TZ" environment variable.

*** The `strptime' function now returns a pair (TIME . COUNT), where
TIME is the parsed time as a vector, and COUNT is the number of
characters from the string left unparsed.  This function used to
return the remaining characters as a string.

*** The `gettimeofday' function has replaced the old `time+ticks' function.
The return value is now (SECONDS . MICROSECONDS); the fractional
component is no longer expressed in "ticks".

*** The `ticks/sec' constant has been removed, in light of the above change.

* Changes to the gh_ interface

** gh_eval_str() now returns an SCM object which is the result of the
evaluation

** gh_scm2str() now copies the Scheme data to a caller-provided C
array

** gh_scm2newstr() now makes a C array, copies the Scheme data to it,
and returns the array

** gh_scm2str0() is gone: there is no need to distinguish
null-terminated from non-null-terminated, since gh_scm2newstr() allows
the user to interpret the data both ways.

* Changes to the scm_ interface

** The new function scm_symbol_value0 provides an easy way to get a
symbol's value from C code:

SCM scm_symbol_value0 (char *NAME)
  Return the value of the symbol named by the null-terminated string
  NAME in the current module.  If the symbol named NAME is unbound in
  the current module, return SCM_UNDEFINED.

** The new function scm_sysintern0 creates new top-level variables,
without assigning them a value.

SCM scm_sysintern0 (char *NAME)
  Create a new Scheme top-level variable named NAME.  NAME is a
  null-terminated string.  Return the variable's value cell.

** The function scm_internal_catch is the guts of catch.  It handles
all the mechanics of setting up a catch target, invoking the catch
body, and perhaps invoking the handler if the body does a throw.

The function is designed to be usable from C code, but is general
enough to implement all the semantics Guile Scheme expects from throw.

TAG is the catch tag.  Typically, this is a symbol, but this function
doesn't actually care about that.

BODY is a pointer to a C function which runs the body of the catch;
this is the code you can throw from.  We call it like this:
   BODY (BODY_DATA, JMPBUF)
where:
   BODY_DATA is just the BODY_DATA argument we received; we pass it
      through to BODY as its first argument.  The caller can make
      BODY_DATA point to anything useful that BODY might need.
   JMPBUF is the Scheme jmpbuf object corresponding to this catch,
      which we have just created and initialized.

HANDLER is a pointer to a C function to deal with a throw to TAG,
should one occur.  We call it like this:
   HANDLER (HANDLER_DATA, THROWN_TAG, THROW_ARGS)
where
   HANDLER_DATA is the HANDLER_DATA argument we recevied; it's the
      same idea as BODY_DATA above.
   THROWN_TAG is the tag that the user threw to; usually this is
      TAG, but it could be something else if TAG was #t (i.e., a
      catch-all), or the user threw to a jmpbuf.
   THROW_ARGS is the list of arguments the user passed to the THROW
      function.

BODY_DATA is just a pointer we pass through to BODY.  HANDLER_DATA
is just a pointer we pass through to HANDLER.  We don't actually
use either of those pointers otherwise ourselves.  The idea is
that, if our caller wants to communicate something to BODY or
HANDLER, it can pass a pointer to it as MUMBLE_DATA, which BODY and
HANDLER can then use.  Think of it as a way to make BODY and
HANDLER closures, not just functions; MUMBLE_DATA points to the
enclosed variables.

Of course, it's up to the caller to make sure that any data a
MUMBLE_DATA needs is protected from GC.  A common way to do this is
to make MUMBLE_DATA a pointer to data stored in an automatic
structure variable; since the collector must scan the stack for
references anyway, this assures that any references in MUMBLE_DATA
will be found.

** The new function scm_internal_lazy_catch is exactly like
scm_internal_catch, except:

- It does not unwind the stack (this is the major difference).
- If handler returns, its value is returned from the throw.
- BODY always receives #f as its JMPBUF argument (since there's no
  jmpbuf associated with a lazy catch, because we don't unwind the
  stack.)

** scm_body_thunk is a new body function you can pass to
scm_internal_catch if you want the body to be like Scheme's `catch'
--- a thunk, or a function of one argument if the tag is #f.

BODY_DATA is a pointer to a scm_body_thunk_data structure, which
contains the Scheme procedure to invoke as the body, and the tag
we're catching.  If the tag is #f, then we pass JMPBUF (created by
scm_internal_catch) to the body procedure; otherwise, the body gets
no arguments.

** scm_handle_by_proc is a new handler function you can pass to
scm_internal_catch if you want the handler to act like Scheme's catch
--- call a procedure with the tag and the throw arguments.

If the user does a throw to this catch, this function runs a handler
procedure written in Scheme.  HANDLER_DATA is a pointer to an SCM
variable holding the Scheme procedure object to invoke.  It ought to
be a pointer to an automatic variable (i.e., one living on the stack),
or the procedure object should be otherwise protected from GC.

** scm_handle_by_message is a new handler function to use with
`scm_internal_catch' if you want Guile to print a message and die.
It's useful for dealing with throws to uncaught keys at the top level.

HANDLER_DATA, if non-zero, is assumed to be a char * pointing to a
message header to print; if zero, we use "guile" instead.  That
text is followed by a colon, then the message described by ARGS.

** The return type of scm_boot_guile is now void; the function does
not return a value, and indeed, never returns at all.

** The new function scm_shell makes it easy for user applications to
process command-line arguments in a way that is compatible with the
stand-alone guile interpreter (which is in turn compatible with SCSH,
the Scheme shell).

To use the scm_shell function, first initialize any guile modules
linked into your application, and then call scm_shell with the values
of ARGC and ARGV your `main' function received.  scm_shell will add
any SCSH-style meta-arguments from the top of the script file to the
argument vector, and then process the command-line arguments.  This
generally means loading a script file or starting up an interactive
command interpreter.  For details, see "Changes to the stand-alone
interpreter" above.

** The new functions scm_get_meta_args and scm_count_argv help you
implement the SCSH-style meta-argument, `\'.

char **scm_get_meta_args (int ARGC, char **ARGV)
  If the second element of ARGV is a string consisting of a single
  backslash character (i.e. "\\" in Scheme notation), open the file
  named by the following argument, parse arguments from it, and return
  the spliced command line.  The returned array is terminated by a
  null pointer.

  For details of argument parsing, see above, under "guile now accepts
  command-line arguments compatible with SCSH..."

int scm_count_argv (char **ARGV)
  Count the arguments in ARGV, assuming it is terminated by a null
  pointer.

For an example of how these functions might be used, see the source
code for the function scm_shell in libguile/script.c.

You will usually want to use scm_shell instead of calling this
function yourself.

** The new function scm_compile_shell_switches turns an array of
command-line arguments into Scheme code to carry out the actions they
describe.  Given ARGC and ARGV, it returns a Scheme expression to
evaluate, and calls scm_set_program_arguments to make any remaining
command-line arguments available to the Scheme code.  For example,
given the following arguments:

	-e main -s ekko a speckled gecko

scm_set_program_arguments will return the following expression:

	(begin (load "ekko") (main (command-line)) (quit))

You will usually want to use scm_shell instead of calling this
function yourself.

** The function scm_shell_usage prints a usage message appropriate for
an interpreter that uses scm_compile_shell_switches to handle its
command-line arguments.

void scm_shell_usage (int FATAL, char *MESSAGE)
  Print a usage message to the standard error output.  If MESSAGE is
  non-zero, write it before the usage message, followed by a newline.
  If FATAL is non-zero, exit the process, using FATAL as the
  termination status.  (If you want to be compatible with Guile,
  always use 1 as the exit status when terminating due to command-line
  usage problems.)

You will usually want to use scm_shell instead of calling this
function yourself.

** scm_eval_0str now returns SCM_UNSPECIFIED if the string contains no
expressions.  It used to return SCM_EOL.  Earth-shattering.

** The macros for declaring scheme objects in C code have been
rearranged slightly.  They are now:

SCM_SYMBOL (C_NAME, SCHEME_NAME)
  Declare a static SCM variable named C_NAME, and initialize it to
  point to the Scheme symbol whose name is SCHEME_NAME.  C_NAME should
  be a C identifier, and SCHEME_NAME should be a C string.

SCM_GLOBAL_SYMBOL (C_NAME, SCHEME_NAME)
  Just like SCM_SYMBOL, but make C_NAME globally visible.

SCM_VCELL (C_NAME, SCHEME_NAME)
  Create a global variable at the Scheme level named SCHEME_NAME.
  Declare a static SCM variable named C_NAME, and initialize it to
  point to the Scheme variable's value cell.

SCM_GLOBAL_VCELL (C_NAME, SCHEME_NAME)
  Just like SCM_VCELL, but make C_NAME globally visible.

The `guile-snarf' script writes initialization code for these macros
to its standard output, given C source code as input.

The SCM_GLOBAL macro is gone.

** The scm_read_line and scm_read_line_x functions have been replaced
by Scheme code based on the %read-delimited! procedure (known to C
code as scm_read_delimited_x).  See its description above for more
information.

** The function scm_sys_open has been renamed to scm_open.  It now
returns a port instead of an FD object.

* The dynamic linking support has changed.  For more information, see
libguile/DYNAMIC-LINKING.


Guile 1.0b3

User-visible changes from Thursday, September 5, 1996 until Guile 1.0
(Sun 5 Jan 1997):

* Changes to the 'guile' program:

** Guile now loads some new files when it starts up.  Guile first
searches the load path for init.scm, and loads it if found.  Then, if
Guile is not being used to execute a script, and the user's home
directory contains a file named `.guile', Guile loads that.

** You can now use Guile as a shell script interpreter.

To paraphrase the SCSH manual:

    When Unix tries to execute an executable file whose first two
    characters are the `#!', it treats the file not as machine code to
    be directly executed by the native processor, but as source code
    to be executed by some interpreter.  The interpreter to use is
    specified immediately after the #! sequence on the first line of
    the source file.  The kernel reads in the name of the interpreter,
    and executes that instead.  It passes the interpreter the source
    filename as its first argument, with the original arguments
    following.  Consult the Unix man page for the `exec' system call
    for more information.

Now you can use Guile as an interpreter, using a mechanism which is a
compatible subset of that provided by SCSH.

Guile now recognizes a '-s' command line switch, whose argument is the
name of a file of Scheme code to load.  It also treats the two
characters `#!' as the start of a comment, terminated by `!#'.  Thus,
to make a file of Scheme code directly executable by Unix, insert the
following two lines at the top of the file:

#!/usr/local/bin/guile -s
!#

Guile treats the argument of the `-s' command-line switch as the name
of a file of Scheme code to load, and treats the sequence `#!' as the
start of a block comment, terminated by `!#'.

For example, here's a version of 'echo' written in Scheme:

#!/usr/local/bin/guile -s
!#
(let loop ((args (cdr (program-arguments))))
  (if (pair? args)
      (begin
	(display (car args))
	(if (pair? (cdr args))
	    (display " "))
	(loop (cdr args)))))
(newline)

Why does `#!' start a block comment terminated by `!#', instead of the
end of the line?  That is the notation SCSH uses, and although we
don't yet support the other SCSH features that motivate that choice,
we would like to be backward-compatible with any existing Guile
scripts once we do.  Furthermore, if the path to Guile on your system
is too long for your kernel, you can start the script with this
horrible hack:

#!/bin/sh
exec /really/long/path/to/guile -s "$0" ${1+"$@"}
!#

Note that some very old Unix systems don't support the `#!' syntax.


** You can now run Guile without installing it.

Previous versions of the interactive Guile interpreter (`guile')
couldn't start up unless Guile's Scheme library had been installed;
they used the value of the environment variable `SCHEME_LOAD_PATH'
later on in the startup process, but not to find the startup code
itself.  Now Guile uses `SCHEME_LOAD_PATH' in all searches for Scheme
code.

To run Guile without installing it, build it in the normal way, and
then set the environment variable `SCHEME_LOAD_PATH' to a
colon-separated list of directories, including the top-level directory
of the Guile sources.  For example, if you unpacked Guile so that the
full filename of this NEWS file is /home/jimb/guile-1.0b3/NEWS, then
you might say

	export SCHEME_LOAD_PATH=/home/jimb/my-scheme:/home/jimb/guile-1.0b3


** Guile's read-eval-print loop no longer prints #<unspecified>
results.  If the user wants to see this, she can evaluate the
expression (assert-repl-print-unspecified #t), perhaps in her startup
file.

** Guile no longer shows backtraces by default when an error occurs;
however, it does display a message saying how to get one, and how to
request that they be displayed by default.  After an error, evaluate
   (backtrace)
to see a backtrace, and
   (debug-enable 'backtrace)
to see them by default.



* Changes to Guile Scheme:

** Guile now distinguishes between #f and the empty list.

This is for compatibility with the IEEE standard, the (possibly)
upcoming Revised^5 Report on Scheme, and many extant Scheme
implementations.

Guile used to have #f and '() denote the same object, to make Scheme's
type system more compatible with Emacs Lisp's.  However, the change
caused too much trouble for Scheme programmers, and we found another
way to reconcile Emacs Lisp with Scheme that didn't require this.


** Guile's delq, delv, delete functions, and their destructive
counterparts, delq!, delv!, and delete!, now remove all matching
elements from the list, not just the first.  This matches the behavior
of the corresponding Emacs Lisp functions, and (I believe) the Maclisp
functions which inspired them.

I recognize that this change may break code in subtle ways, but it
seems best to make the change before the FSF's first Guile release,
rather than after.


** The compiled-library-path function has been deleted from libguile.

** The facilities for loading Scheme source files have changed.

*** The variable %load-path now tells Guile which directories to search
for Scheme code.  Its value is a list of strings, each of which names
a directory.

*** The variable %load-extensions now tells Guile which extensions to
try appending to a filename when searching the load path.  Its value
is a list of strings.  Its default value is ("" ".scm").

*** (%search-load-path FILENAME) searches the directories listed in the
value of the %load-path variable for a Scheme file named FILENAME,
with all the extensions listed in %load-extensions.  If it finds a
match, then it returns its full filename.  If FILENAME is absolute, it
returns it unchanged.  Otherwise, it returns #f.

%search-load-path will not return matches that refer to directories.

*** (primitive-load FILENAME :optional CASE-INSENSITIVE-P SHARP)
uses %seach-load-path to find a file named FILENAME, and loads it if
it finds it.  If it can't read FILENAME for any reason, it throws an
error.

The arguments CASE-INSENSITIVE-P and SHARP are interpreted as by the
`read' function.

*** load uses the same searching semantics as primitive-load.

*** The functions %try-load, try-load-with-path, %load, load-with-path,
basic-try-load-with-path, basic-load-with-path, try-load-module-with-
path, and load-module-with-path have been deleted.  The functions
above should serve their purposes.

*** If the value of the variable %load-hook is a procedure,
`primitive-load' applies its value to the name of the file being
loaded (without the load path directory name prepended).  If its value
is #f, it is ignored.  Otherwise, an error occurs.

This is mostly useful for printing load notification messages.


** The function `eval!' is no longer accessible from the scheme level.
We can't allow operations which introduce glocs into the scheme level,
because Guile's type system can't handle these as data.  Use `eval' or
`read-and-eval!' (see below) as replacement.

** The new function read-and-eval! reads an expression from PORT,
evaluates it, and returns the result.  This is more efficient than
simply calling `read' and `eval', since it is not necessary to make a
copy of the expression for the evaluator to munge.

Its optional arguments CASE_INSENSITIVE_P and SHARP are interpreted as
for the `read' function.


** The function `int?' has been removed; its definition was identical
to that of `integer?'.

** The functions `<?', `<?', `<=?', `=?', `>?', and `>=?'.  Code should
use the R4RS names for these functions.

** The function object-properties no longer returns the hash handle;
it simply returns the object's property list.

** Many functions have been changed to throw errors, instead of
returning #f on failure.  The point of providing exception handling in
the language is to simplify the logic of user code, but this is less
useful if Guile's primitives don't throw exceptions.

** The function `fileno' has been renamed from `%fileno'.

** The function primitive-mode->fdes returns #t or #f now, not 1 or 0.


* Changes to Guile's C interface:

** The library's initialization procedure has been simplified.
scm_boot_guile now has the prototype:

void scm_boot_guile (int ARGC,
                     char **ARGV,
	             void (*main_func) (),
	             void *closure);

scm_boot_guile calls MAIN_FUNC, passing it CLOSURE, ARGC, and ARGV.
MAIN_FUNC should do all the work of the program (initializing other
packages, reading user input, etc.) before returning.  When MAIN_FUNC
returns, call exit (0); this function never returns.  If you want some
other exit value, MAIN_FUNC may call exit itself.

scm_boot_guile arranges for program-arguments to return the strings
given by ARGC and ARGV.  If MAIN_FUNC modifies ARGC/ARGV, should call
scm_set_program_arguments with the final list, so Scheme code will
know which arguments have been processed.

scm_boot_guile establishes a catch-all catch handler which prints an
error message and exits the process.  This means that Guile exits in a
coherent way when system errors occur and the user isn't prepared to
handle it.  If the user doesn't like this behavior, they can establish
their own universal catcher in MAIN_FUNC to shadow this one.

Why must the caller do all the real work from MAIN_FUNC?  The garbage
collector assumes that all local variables of type SCM will be above
scm_boot_guile's stack frame on the stack.  If you try to manipulate
SCM values after this function returns, it's the luck of the draw
whether the GC will be able to find the objects you allocate.  So,
scm_boot_guile function exits, rather than returning, to discourage
people from making that mistake.

The IN, OUT, and ERR arguments were removed; there are other
convenient ways to override these when desired.

The RESULT argument was deleted; this function should never return.

The BOOT_CMD argument was deleted; the MAIN_FUNC argument is more
general.


** Guile's header files should no longer conflict with your system's
header files.

In order to compile code which #included <libguile.h>, previous
versions of Guile required you to add a directory containing all the
Guile header files to your #include path.  This was a problem, since
Guile's header files have names which conflict with many systems'
header files.

Now only <libguile.h> need appear in your #include path; you must
refer to all Guile's other header files as <libguile/mumble.h>.
Guile's installation procedure puts libguile.h in $(includedir), and
the rest in $(includedir)/libguile.


** Two new C functions, scm_protect_object and scm_unprotect_object,
have been added to the Guile library.

scm_protect_object (OBJ) protects OBJ from the garbage collector.
OBJ will not be freed, even if all other references are dropped,
until someone does scm_unprotect_object (OBJ).  Both functions
return OBJ.

Note that calls to scm_protect_object do not nest.  You can call
scm_protect_object any number of times on a given object, and the
next call to scm_unprotect_object will unprotect it completely.

Basically, scm_protect_object and scm_unprotect_object just
maintain a list of references to things.  Since the GC knows about
this list, all objects it mentions stay alive.  scm_protect_object
adds its argument to the list; scm_unprotect_object remove its
argument from the list.


** scm_eval_0str now returns the value of the last expression
evaluated.

** The new function scm_read_0str reads an s-expression from a
null-terminated string, and returns it.

** The new function `scm_stdio_to_port' converts a STDIO file pointer
to a Scheme port object.

** The new function `scm_set_program_arguments' allows C code to set
the value returned by the Scheme `program-arguments' function.


Older changes:

* Guile no longer includes sophisticated Tcl/Tk support.

The old Tcl/Tk support was unsatisfying to us, because it required the
user to link against the Tcl library, as well as Tk and Guile.  The
interface was also un-lispy, in that it preserved Tcl/Tk's practice of
referring to widgets by names, rather than exporting widgets to Scheme
code as a special datatype.

In the Usenix Tk Developer's Workshop held in July 1996, the Tcl/Tk
maintainers described some very interesting changes in progress to the
Tcl/Tk internals, which would facilitate clean interfaces between lone
Tk and other interpreters --- even for garbage-collected languages
like Scheme.  They expected the new Tk to be publicly available in the
fall of 1996.

Since it seems that Guile might soon have a new, cleaner interface to
lone Tk, and that the old Guile/Tk glue code would probably need to be
completely rewritten, we (Jim Blandy and Richard Stallman) have
decided not to support the old code.  We'll spend the time instead on
a good interface to the newer Tk, as soon as it is available.

Until then, gtcltk-lib provides trivial, low-maintenance functionality.


Copyright information:

Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2006 Free Software Foundation, Inc.

   Permission is granted to anyone to make or distribute verbatim copies
   of this document as received, in any medium, provided that the
   copyright notice and this permission notice are preserved,
   thus giving the recipient permission to redistribute in turn.

   Permission is granted to distribute modified versions
   of this document, or of portions of it,
   under the above conditions, provided also that they
   carry prominent notices stating who last changed them.


Local variables:
mode: outline
paragraph-separate: "[ 	]*$"
end:
