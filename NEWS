Guile NEWS --- history of user-visible changes.  -*- text -*-
Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
See the end for copying conditions.

Please send Guile bug reports to bug-guile@gnu.org.

Changes since Guile 1.4:

* Changes to the distribution

** As per RELEASE directions, deprecated items have been removed

*** Macros removed

  SCM_INPORTP, SCM_OUTPORTP SCM_ICHRP, SCM_ICHR, SCM_MAKICHR
  SCM_SETJMPBUF SCM_NSTRINGP SCM_NRWSTRINGP SCM_NVECTORP

*** Functions removed

  scm_sysmissing

  gc-thunk - replaced by after-gc-hook.

** New SRFI modules have been added:

(srfi srfi-2) exports and-let*.

(srfi srfi-6) is a dummy module for now, since guile already provides
  all of the srfi-6 procedures by default: open-input-string,
  open-output-string, get-output-string.

(srfi srfi-8) exports receive.

(srfi srfi-9) exports define-record-type.

(srfi srfi-11) exports let-values and let*-values.

(srfi srfi-13) implements the SRFI String Library.

(srfi srfi-14) implements the SRFI Character-Set Library.

** New module (ice-9 stack-catch):

stack-catch is like catch, but saves the current state of the stack in
the fluid the-last-stack.  This fluid can be useful when using the
debugger and when re-throwing an error.

** The module (ice-9 and-let*) has been renamed to (ice-9 and-let-star)

This has been done to prevent problems on lesser operating systems
that can't tolerate `*'s in file names.  The exported macro continues
to be named `and-let*', of course.

On systems that support it, there is also a compatibility module named
(ice-9 and-let*).  It will go away in the next release.

** New modules (oop goops) etc.:

  (oop goops)
  (oop goops describe)
  (oop goops save)
  (oop goops active-slot)
  (oop goops composite-slot)

The Guile Object Oriented Programming System (GOOPS) has been
integrated into Guile.

Type

  (use-modules (oop goops))

access GOOPS bindings.

We're now ready to try some basic GOOPS functionality.

Generic functions

  (define-method (+ (x <string>) (y <string>))
    (string-append x y))

  (+ 1 2) --> 3
  (+ "abc" "de") --> "abcde"

User-defined types

  (define-class <2D-vector> ()
    (x #:init-value 0 #:accessor x-component #:init-keyword #:x)
    (y #:init-value 0 #:accessor y-component #:init-keyword #:y))

  (define-method write ((obj <2D-vector>) port)
    (display (format #f "<~S, ~S>" (x-component obj) (y-component obj))
	     port))

  (define v (make <2D-vector> #:x 3 #:y 4))
  v --> <3, 4>

  (define-method + ((x <2D-vector>) (y <2D-vector>))
    (make <2D-vector>
          #:x (+ (x-component x) (x-component y))
          #:y (+ (y-component x) (y-component y))))

  (+ v v) --> <6, 8>

Asking for the type of an object

  (class-of v) --> #<<class> <2D-vector> 40241ac0>
  <2D-vector>  --> #<<class> <2D-vector> 40241ac0>
  (class-of 1) --> #<<class> <integer> 401b2a98>
  <integer>    --> #<<class> <integer> 401b2a98>

  (is-a? v <2D-vector>) --> #t

See further in the GOOPS manual and tutorial in the `doc' directory,
in info (goops.info) and texinfo formats.

** New module (ice-9 rdelim).

This exports the following procedures which were previously defined
in the default environment:

read-line read-line! read-delimited read-delimited! %read-delimited!
%read-line write-line

For backwards compatibility the definitions are still imported into the
default environment in this version of Guile.  However you should add:

(use-modules (ice-9 rdelim))

to any program which uses the definitions, since this may change in
future.

Alternatively, if guile-scsh is installed, the (scsh rdelim) module
can be used for similar functionality.

** New module (ice-9 match)

This module includes Andrew K. Wright's pattern matcher:

(use-modules (ice-9 match))

(match '(+ 1 2)
  (('+ x) x)
  (('+ x y) `(add ,x ,y))
  (('- x y) `(sub ,x ,y)))  => (add 1 2)

See ice-9/match.scm for brief description or
http://www.star-lab.com/wright/code.html for complete documentation.

This module requires SLIB to be installed and available from Guile.

** New module (ice-9 buffered-input)

This module provides procedures to construct an input port from an
underlying source of input that reads and returns its input in chunks.
The underlying input source is a Scheme procedure, specified by the
caller, which the port invokes whenever it needs more input.

This is useful when building an input port whose back end is Readline
or a UI element such as the GtkEntry widget.

** Documentation

The reference and tutorial documentation that was previously
distributed separately, as `guile-doc', is now included in the core
Guile distribution.  The documentation consists of the following
manuals.

- The Guile Tutorial (guile-tut.texi) contains a tutorial introduction
  to using Guile.

- The Guile Reference Manual (guile.texi) contains (or is intended to
  contain) reference documentation on all aspects of Guile.

- The GOOPS Manual (goops.texi) contains both tutorial-style and
  reference documentation for using GOOPS, Guile's Object Oriented
  Programming System.

- The Revised^5 Report on the Algorithmic Language Scheme
  (r5rs.texi).

See the README file in the `doc' directory for more details.

* Changes to the stand-alone interpreter

** Evaluation of "()", the empty list, is now an error.

Previously, you could for example write (cons 1 ()); now you need to
be more explicit and write (cons 1 '()).

** It's now possible to create modules with controlled environments

Example:

(use-modules (ice-9 safe))
(define m (make-safe-module))
;;; m will now be a module containing only a safe subset of R5RS
(eval '(+ 1 2) m) --> 3
(eval 'load m) --> ERROR: Unbound variable: load

* Changes to Scheme functions and syntax

** The empty combination is no longer valid syntax.

Previously, the expression "()" evaluated to the empty list.  This has
been changed to signal a "missing expression" error.  The correct way
to write the empty list as a literal constant is to use quote: "'()".

** Auto-loading of compiled-code modules is deprecated.

Guile used to be able to automatically find and link a shared
libraries to satisfy requests for a module.  For example, the module
`(foo bar)' could be implemented by placing a shared library named
"foo/libbar.so" (or with a different extension) in a directory on the
load path of Guile.

This has been found to be too tricky, and is no longer supported.
What you should do instead now is to write a small Scheme file that
explicitly calls `dynamic-link' to load the shared library and
`dynamic-call' to initialize it.

The shared libraries themselves should be installed in the usual
places for shared libraries, with names like "libguile-foo-bar".

For example, place this into a file "foo/bar.scm"

    (define-module (foo bar))

    (dynamic-call "foobar_init" (dynamic-link "libguile-foo-bar"))

The file name passed to `dynamic-link' should not contain an
extension.  It will be provided automatically.

** The module system has been made more disciplined.

The function `eval' will now save and restore the current module
around the evaluation of the specified expression.  While this
expression is evaluated, `(current-module)' will now return the right
module, which is the module specified as the second argument to
`eval'.

A consequence of this change is that `eval' is not particularily
useful when you want allow the evaluated code to change what module is
designated as the current module and have this change persist from one
call to `eval' to the next.  The read-eval-print-loop is an example
where `eval' is now inadequate.  To compensate, there is a new
function `primitive-eval' that does not take a module specifier and
that does not save/restore the current module.  You should use this
function together with `set-current-module', `current-module', etc
when you want to have more control over the state that is carried from
one eval to the next.

Additionally, it has been made sure that forms that are evaluated at
the top level are always evaluated with respect to the current module.
Previously, subforms of top-level forms such as `begin', `case',
etc. did not respect changes to the current module although these
subforms are at the top-level as well.

To prevent strange behaviour, the forms `define-module',
`use-modules', `use-syntax', and `export' have been restricted to only
work on the top level.  The forms `define-public' and
`defmacro-public' only export the new binding on the top level.  They
behave just like `define' and `defmacro', respectively, when they are
used in a lexical environment.

** The semantics of guardians have changed.

The changes are for the most part compatible.  An important criterion
was to keep the typical usage of guardians as simple as before, but to
make the semantics safer and (as a result) more useful.

*** All objects returned from guardians are now properly alive.

It is now guaranteed that any object referenced by an object returned
from a guardian is alive.  It's now impossible for a guardian to
return a "contained" object before its "containing" object.

One incompatible (but probably not very important) change resulting
from this is that it is no longer possible to guard objects that
indirectly reference themselves (i.e. are parts of cycles).  If you do
so accidentally, you'll get a warning.

*** There are now two types of guardians: greedy and sharing.

If you call (make-guardian #t) or just (make-guardian), you'll get a
greedy guardian, and for (make-guardian #f) a sharing guardian.

Greedy guardians are the default because they are more "defensive".
You can only greedily guard an object once.  If you guard an object
more than once, once in a greedy guardian and the rest of times in
sharing guardians, then it is guaranteed that the object won't be
returned from sharing guardians as long as it is greedily guarded
and/or alive.

Guardians returned by calls to `make-guardian' can now take one more
optional parameter, which says whether to throw an error in case an
attempt is made to greedily guard an object that is already greedily
guarded.  The default is true, i.e. throw an error.  If the parameter
is false, the guardian invocation returns #t if guarding was
successful and #f if it wasn't.

Also, since greedy guarding is, in effect, a side-effecting operation
on objects, a new function is introduced: `destroy-guardian!'.
Invoking this function on a guardian renders it unoperative and, if
the guardian is greedy, clears the "greedily guarded" property of the
objects that were guarded by it, thus undoing the side effect.

Note that all this hair is hardly very important, since guardian
objects are usually permanent.

** Escape procedures created by call-with-current-continuation now
accept any number of arguments, as required by R5RS.

** New function `call-with-deprecation'

Call a thunk, displaying a deprecation message at the first call:

  (define (id x)
    (call-with-deprecation "`id' is deprecated.  Use `identity' instead."
      (lambda ()
	(identity x))))

  guile> (id 1)
  ;; `id' is deprecated.  Use `identity' instead.
  1
  guile> (id 1)
  1

** New function `make-object-property'

This function returns a new `procedure with setter' P that can be used
to attach a property to objects.  When calling P as

   (set! (P obj) val)

where `obj' is any kind of object, it attaches `val' to `obj' in such
a way that it can be retrieved by calling P as

    (P obj)

This function will replace procedure properties, symbol properties and
source properties eventually.

** Module (ice-9 optargs) now uses keywords instead of `#&'.

Instead of #&optional, #&key, etc you should now use #:optional,
#:key, etc.  Since #:optional is a keyword, you can write it as just
:optional when (read-set! keywords 'prefix) is active.

The old reader syntax `#&' is still supported, but deprecated.  It
will be removed in the next release.

** Backward incompatible change: eval EXP ENVIRONMENT-SPECIFIER

`eval' is now R5RS, that is it takes two arguments.
The second argument is an environment specifier, i.e. either

  (scheme-report-environment 5)
  (null-environment 5)
  (interaction-environment)

or

  any module.

** New define-module option: pure

Tells the module system not to include any bindings from the root
module.

Example:

(define-module (totally-empty-module)
  :pure)

** New define-module option: export NAME1 ...

Export names NAME1 ...

This option is required if you want to be able to export bindings from
a module which doesn't import one of `define-public' or `export'.

Example:

(define-module (foo)
  :pure
  :use-module (ice-9 r5rs)
  :export (bar))

;;; Note that we're pure R5RS below this point!

(define (bar)
  ...)

** Deprecated: scm_make_shared_substring

Explicit shared substrings will disappear from Guile.

Instead, "normal" strings will be implemented using sharing
internally, combined with a copy-on-write strategy.

** Deprecated: scm_read_only_string_p

The concept of read-only strings will disappear in next release of
Guile.

** Deprecated: scm_sloppy_memq, scm_sloppy_memv, scm_sloppy_member

Instead, use scm_c_memq or scm_memq, scm_memv, scm_member.

** New function: read-string!/partial str [port_or_fdes [start [end]]]

     Read characters from an fport or file descriptor into a string
     STR.  This procedure is scsh-compatible and can efficiently read
     large strings.  It will:

        * attempt to fill the entire string, unless the START and/or
          END arguments are supplied.  i.e., START defaults to 0 and
          END defaults to `(string-length str)'

        * use the current input port if PORT_OR_FDES is not supplied.

        * read any characters that are currently available, without
          waiting for the rest (short reads are possible).

        * wait for as long as it needs to for the first character to
          become available, unless the port is in non-blocking mode

        * return `#f' if end-of-file is encountered before reading any
          characters, otherwise return the number of characters read.

        * return 0 if the port is in non-blocking mode and no characters
          are immediately available.

        * return 0 if the request is for 0 bytes, with no end-of-file
          check

** New function: object->string OBJ

Return a Scheme string obtained by printing a given object.

** New function: port? X

Returns a boolean indicating whether X is a port.  Equivalent to
`(or (input-port? X) (output-port? X))'.

** New function: file-port?

Determines whether a given object is a port that is related to a file.

** New function: port-for-each proc

     Apply PROC to each port in the Guile port table in turn.  The
     return value is unspecified.  More specifically, PROC is applied
     exactly once to every port that exists in the system at the time
     PORT-FOR-EACH is invoked.  Changes to the port table while
     PORT-FOR-EACH is running have no effect as far as PORT-FOR-EACH is
     concerned.

** New function: dup2 oldfd newfd

A simple wrapper for the `dup2' system call.  Copies the file
descriptor OLDFD to descriptor number NEWFD, replacing the
previous meaning of NEWFD.  Both OLDFD and NEWFD must be integers.
Unlike for dup->fdes or primitive-move->fdes, no attempt is made
to move away ports which are using NEWFD.  The return value is
unspecified.

** New function: close-fdes fd

A simple wrapper for the `close' system call.  Close file
descriptor FD, which must be an integer.  Unlike close (*note
close: Ports and File Descriptors.), the file descriptor will be
closed even if a port is using it.  The return value is
unspecified.

** New function: crypt password salt

Encrypts `password' using the standard unix password encryption
algorithm.

** New function: chroot path

Change the root directory of the running process to `path'.

** New functions: getlogin, cuserid

Return the login name or the user name of the current effective user
id, respectively.

** New functions: getpriority which who, setpriority which who prio

Get or set the priority of the running process.

** New function: getpass prompt

Read a password from the terminal, first displaying `prompt' and
disabling echoing.

** New function: flock file operation

Set/remove an advisory shared or exclusive lock on `file'.

** New functions: sethostname name, gethostname

Set or get the hostname of the machine the current process is running
on.

** New function: mkstemp! tmpl

mkstemp creates a new unique file in the file system and returns a
new buffered port open for reading and writing to the file.  TMPL
is a string specifying where the file should be created: it must
end with `XXXXXX' and will be changed in place to return the name
of the temporary file.

** New function: open-input-string string

Return an input string port which delivers the characters from
`string'.  This procedure, together with `open-output-string' and
`get-output-string' implements SRFI-6.

** New function: open-output-string

Return an output string port which collects all data written to it.
The data can then be retrieved by `get-output-string'.

** New function: get-output-string

Return the contents of an output string port.

** New function: identity

Return the argument.

** socket, connect, accept etc., now have support for IPv6.  IPv6 addresses
   are represented in Scheme as integers with normal host byte ordering.

** New function: inet-pton family address

     Convert a printable string network address into an integer.  Note
     that unlike the C version of this function, the result is an
     integer with normal host byte ordering.  FAMILY can be `AF_INET'
     or `AF_INET6'.  e.g.,
          (inet-pton AF_INET "127.0.0.1") => 2130706433
          (inet-pton AF_INET6 "::1") => 1

** New function: inet-ntop family address

     Convert an integer network address into a printable string.  Note
     that unlike the C version of this function, the input is an
     integer with normal host byte ordering.  FAMILY can be `AF_INET'
     or `AF_INET6'.  e.g.,
          (inet-ntop AF_INET 2130706433) => "127.0.0.1"
          (inet-ntop AF_INET6 (- (expt 2 128) 1)) =>
          ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff

** Deprecated: id

Use `identity' instead.

** Deprecated: close-all-ports-except.

This was intended for closing ports in a child process after a fork,
but it has the undesirable side effect of flushing buffers.
port-for-each is more flexible.

** The (ice-9 popen) module now attempts to set up file descriptors in
the child process from the current Scheme ports, instead of using the
current values of file descriptors 0, 1, and 2 in the parent process.

** Removed function:  builtin-weak-bindings

There is no such concept as a weak binding any more.

** Removed constants:  bignum-radix, scm-line-incrementors

** define-method: New syntax mandatory.

The new method syntax is now mandatory:

(define-method (NAME ARG-SPEC ...) BODY ...)
(define-method (NAME ARG-SPEC ... . REST-ARG) BODY ...)

  ARG-SPEC ::= ARG-NAME | (ARG-NAME TYPE)
  REST-ARG ::= ARG-NAME

If you have old code using the old syntax, import
(oop goops old-define-method) before (oop goops) as in:

  (use-modules (oop goops old-define-method) (oop goops))

* Changes to the gh_ interface

* Changes to the scm_ interface

** New function: scm_c_read (SCM port, void *buffer, scm_sizet size)

Used by an application to read arbitrary number of bytes from a port.
Same semantics as libc read, except that scm_c_read only returns less
than SIZE bytes if at end-of-file.

Warning: Doesn't update port line and column counts!

** New function: scm_c_write (SCM port, const void *ptr, scm_sizet size)

Used by an application to write arbitrary number of bytes to an SCM
port.  Similar semantics as libc write.  However, unlike libc
write, scm_c_write writes the requested number of bytes and has no
return value.

Warning: Doesn't update port line and column counts!

** New function: scm_init_guile ()

In contrast to scm_boot_guile, scm_init_guile will return normally
after initializing Guile.  It is not available on all systems, tho.

** New functions: scm_str2symbol, scm_mem2symbol

The function scm_str2symbol takes a const char* pointing to a zero-terminated
field of characters and creates a scheme symbol object from that C string.
The function scm_mem2symbol takes a const char* and a number of characters and
creates a symbol from the characters in that memory area.

** New functions: scm_primitive_make_property
                  scm_primitive_property_ref
                  scm_primitive_property_set_x
                  scm_primitive_property_del_x

These functions implement a new way to deal with object properties.
See libguile/properties.c for their documentation.

** New function: scm_done_free (long size)

This function is the inverse of scm_done_malloc.  Use it to report the
amount of smob memory you free.  The previous method, which involved
calling scm_done_malloc with negative argument, was somewhat
unintuitive (and is still available, of course).

** New function: scm_c_memq (SCM obj, SCM list)

This function provides a fast C level alternative for scm_memq for the case
that the list parameter is known to be a proper list.  The function is a
replacement for scm_sloppy_memq, but is stricter in its requirements on its
list input parameter, since for anything else but a proper list the function's
behaviour is undefined - it may even crash or loop endlessly.  Further, for
the case that the object is not found in the list, scm_c_memq returns #f which
is similar to scm_memq, but different from scm_sloppy_memq's behaviour.

** New functions: scm_remember_upto_here_1, scm_remember_upto_here_2,
scm_remember_upto_here

These functions replace the function scm_remember.

** Deprecated function:  scm_remember

Use one of the new functions scm_remember_upto_here_1,
scm_remember_upto_here_2 or scm_remember_upto_here instead.

** New function: scm_allocate_string

This function replaces the function scm_makstr.

** Deprecated function:  scm_makstr

Use the new function scm_allocate_string instead.

** New global variable scm_gc_running_p introduced.

Use this variable to find out if garbage collection is being executed.  Up to
now applications have used scm_gc_heap_lock to test if garbage collection was
running, which also works because of the fact that up to know only the garbage
collector has set this variable.  But, this is an implementation detail that
may change.  Further, scm_gc_heap_lock is not set throughout gc, thus the use
of this variable is (and has been) not fully safe anyway.

** New macros:  SCM_BITVECTOR_MAX_LENGTH, SCM_UVECTOR_MAX_LENGTH

Use these instead of SCM_LENGTH_MAX.

** New macros:  SCM_CONTINUATION_LENGTH, SCM_CCLO_LENGTH, SCM_STACK_LENGTH,
SCM_STRING_LENGTH, SCM_SYMBOL_LENGTH, SCM_UVECTOR_LENGTH,
SCM_BITVECTOR_LENGTH, SCM_VECTOR_LENGTH.

Use these instead of SCM_LENGTH.

** New macros:  SCM_SET_CONTINUATION_LENGTH, SCM_SET_STRING_LENGTH,
SCM_SET_SYMBOL_LENGTH, SCM_SET_VECTOR_LENGTH, SCM_SET_UVECTOR_LENGTH,
SCM_SET_BITVECTOR_LENGTH

Use these instead of SCM_SETLENGTH

** New macros:  SCM_STRING_CHARS, SCM_SYMBOL_CHARS, SCM_CCLO_BASE,
SCM_VECTOR_BASE, SCM_UVECTOR_BASE, SCM_BITVECTOR_BASE, SCM_COMPLEX_MEM,
SCM_ARRAY_MEM

Use these instead of SCM_CHARS, SCM_UCHARS, SCM_ROCHARS, SCM_ROUCHARS or
SCM_VELTS.

** New macros:  SCM_SET_BIGNUM_BASE, SCM_SET_STRING_CHARS,
SCM_SET_SYMBOL_CHARS, SCM_SET_UVECTOR_BASE, SCM_SET_BITVECTOR_BASE,
SCM_SET_VECTOR_BASE

Use these instead of SCM_SETCHARS.

** New macro:  SCM_BITVECTOR_P

** New macro:  SCM_STRING_COERCE_0TERMINATION_X

Use instead of SCM_COERCE_SUBSTR.

** New macros:  SCM_DIR_OPEN_P, SCM_DIR_FLAG_OPEN

For directory objects, use these instead of SCM_OPDIRP and SCM_OPN.

** Deprecated macros:  SCM_OUTOFRANGE, SCM_NALLOC, SCM_HUP_SIGNAL,
SCM_INT_SIGNAL, SCM_FPE_SIGNAL, SCM_BUS_SIGNAL, SCM_SEGV_SIGNAL,
SCM_ALRM_SIGNAL, SCM_GC_SIGNAL, SCM_TICK_SIGNAL, SCM_SIG_ORD,
SCM_ORD_SIG, SCM_NUM_SIGS, SCM_SYMBOL_SLOTS, SCM_SLOTS, SCM_SLOPPY_STRINGP,
SCM_VALIDATE_STRINGORSUBSTR, SCM_FREEP, SCM_NFREEP, SCM_CHARS, SCM_UCHARS,
SCM_VALIDATE_ROSTRING, SCM_VALIDATE_ROSTRING_COPY,
SCM_VALIDATE_NULLORROSTRING_COPY, SCM_ROLENGTH, SCM_LENGTH, SCM_HUGE_LENGTH,
SCM_SUBSTRP, SCM_SUBSTR_STR, SCM_SUBSTR_OFFSET, SCM_COERCE_SUBSTR,
SCM_ROSTRINGP, SCM_RWSTRINGP, SCM_VALIDATE_RWSTRING, SCM_ROCHARS,
SCM_ROUCHARS, SCM_SETLENGTH, SCM_SETCHARS, SCM_LENGTH_MAX, SCM_GC8MARKP,
SCM_SETGC8MARK, SCM_CLRGC8MARK, SCM_GCTYP16, SCM_GCCDR, SCM_SUBR_DOC,
SCM_OPDIRP, SCM_VALIDATE_OPDIR, SCM_WTA, RETURN_SCM_WTA, SCM_CONST_LONG,
SCM_WNA, SCM_FUNC_NAME, SCM_VALIDATE_NUMBER_COPY,
SCM_VALIDATE_NUMBER_DEF_COPY, SCM_SLOPPY_CONSP, SCM_SLOPPY_NCONSP,
SCM_SETAND_CDR, SCM_SETOR_CDR, SCM_SETAND_CAR, SCM_SETOR_CAR

Use SCM_ASSERT_RANGE or SCM_VALIDATE_XXX_RANGE instead of SCM_OUTOFRANGE.
Use scm_memory_error instead of SCM_NALLOC.
Use SCM_STRINGP instead of SCM_SLOPPY_STRINGP.
Use SCM_VALIDATE_STRING instead of SCM_VALIDATE_STRINGORSUBSTR.
Use SCM_FREE_CELL_P instead of SCM_FREEP/SCM_NFREEP
Use a type specific accessor macro instead of SCM_CHARS/SCM_UCHARS.
Use a type specific accessor instead of SCM(_|_RO|_HUGE_)LENGTH.
Use SCM_VALIDATE_(SYMBOL|STRING) instead of SCM_VALIDATE_ROSTRING.
Use SCM_STRING_COERCE_0TERMINATION_X instead of SCM_COERCE_SUBSTR.
Use SCM_STRINGP or SCM_SYMBOLP instead of SCM_ROSTRINGP.
Use SCM_STRINGP instead of SCM_RWSTRINGP.
Use SCM_VALIDATE_STRING instead of SCM_VALIDATE_RWSTRING.
Use SCM_STRING_CHARS instead of SCM_ROCHARS.
Use SCM_STRING_UCHARS instead of SCM_ROUCHARS.
Use a type specific setter macro instead of SCM_SETLENGTH.
Use a type specific setter macro instead of SCM_SETCHARS.
Use a type specific length macro instead of SCM_LENGTH_MAX.
Use SCM_GCMARKP instead of SCM_GC8MARKP.
Use SCM_SETGCMARK instead of SCM_SETGC8MARK.
Use SCM_CLRGCMARK instead of SCM_CLRGC8MARK.
Use SCM_TYP16 instead of SCM_GCTYP16.
Use SCM_CDR instead of SCM_GCCDR.
Use SCM_DIR_OPEN_P instead of SCM_OPDIRP.
Use SCM_MISC_ERROR or SCM_WRONG_TYPE_ARG instead of SCM_WTA.
Use SCM_MISC_ERROR or SCM_WRONG_TYPE_ARG instead of RETURN_SCM_WTA.
Use SCM_VCELL_INIT instead of SCM_CONST_LONG.
Use SCM_WRONG_NUM_ARGS instead of SCM_WNA.
Use SCM_CONSP instead of SCM_SLOPPY_CONSP.
Use !SCM_CONSP instead of SCM_SLOPPY_NCONSP.

** Removed function:  scm_struct_init

** Removed variable:  scm_symhash_dim

** Renamed function: scm_make_cont has been replaced by
scm_make_continuation, which has a different interface.

** Deprecated function:  scm_call_catching_errors

Use scm_catch or scm_lazy_catch from throw.[ch] instead.

** Deprecated function:  scm_strhash

Use scm_string_hash instead.

** Deprecated function:  scm_vector_set_length_x

Instead, create a fresh vector of the desired size and copy the contents.

** scm_gensym has changed prototype

scm_gensym now only takes one argument.

** New function: scm_gentemp (SCM prefix, SCM obarray)

The builtin `gentemp' has now become a primitive.

** Deprecated type tags:  scm_tc7_ssymbol, scm_tc7_msymbol, scm_tcs_symbols,
scm_tc7_lvector

There is now only a single symbol type scm_tc7_symbol.
The tag scm_tc7_lvector was not used anyway.

** Deprecated function:  scm_make_smob_type_mfpe, scm_set_smob_mfpe.

Use scm_make_smob_type and scm_set_smob_XXX instead.

** New function scm_set_smob_apply.

This can be used to set an apply function to a smob type.

** Deprecated function:  scm_strprint_obj

Use scm_object_to_string instead.

** Deprecated function:  scm_wta

Use scm_wrong_type_arg, or another appropriate error signalling function
instead.


Changes since Guile 1.3.4:

* Changes to the distribution

** Trees from nightly snapshots and CVS now require you to run autogen.sh.

We've changed the way we handle generated files in the Guile source
repository.  As a result, the procedure for building trees obtained
from the nightly FTP snapshots or via CVS has changed:
- You must have appropriate versions of autoconf, automake, and
  libtool installed on your system.  See README for info on how to
  obtain these programs.
- Before configuring the tree, you must first run the script
  `autogen.sh' at the top of the source tree.

The Guile repository used to contain not only source files, written by
humans, but also some generated files, like configure scripts and
Makefile.in files.  Even though the contents of these files could be
derived mechanically from other files present, we thought it would
make the tree easier to build if we checked them into CVS.

However, this approach means that minor differences between
developer's installed tools and habits affected the whole team.
So we have removed the generated files from the repository, and
added the autogen.sh script, which will reconstruct them
appropriately.


** configure now has experimental options to remove support for certain
features:

--disable-arrays     omit array and uniform array support
--disable-posix      omit posix interfaces
--disable-networking omit networking interfaces
--disable-regex      omit regular expression interfaces

These are likely to become separate modules some day.

** New configure option --enable-debug-freelist

This enables a debugging version of SCM_NEWCELL(), and also registers
an extra primitive, the setter `gc-set-debug-check-freelist!'.

Configure with the --enable-debug-freelist option to enable
the gc-set-debug-check-freelist! primitive, and then use:

(gc-set-debug-check-freelist! #t)  # turn on checking of the freelist
(gc-set-debug-check-freelist! #f)  # turn off checking

Checking of the freelist forces a traversal of the freelist and
a garbage collection before each allocation of a cell.  This can
slow down the interpreter dramatically, so the setter should be used to
turn on this extra processing only when necessary.

** New configure option --enable-debug-malloc

Include code for debugging of calls to scm_must_malloc/realloc/free.

Checks that

1. objects freed by scm_must_free has been mallocated by scm_must_malloc
2. objects reallocated by scm_must_realloc has been allocated by
   scm_must_malloc
3. reallocated objects are reallocated with the same what string

But, most importantly, it records the number of allocated objects of
each kind.  This is useful when searching for memory leaks.

A Guile compiled with this option provides the primitive
`malloc-stats' which returns an alist with pairs of kind and the
number of objects of that kind.

** All includes are now referenced relative to the root directory

Since some users have had problems with mixups between Guile and
system headers, we have decided to always refer to Guile headers via
their parent directories.  This essentially creates a "private name
space" for Guile headers.  This means that the compiler only is given
-I options for the root build and root source directory.

** Header files kw.h and genio.h have been removed.

** The module (ice-9 getopt-gnu-style) has been removed.

** New module (ice-9 documentation)

Implements the interface to documentation strings associated with
objects.

** New module (ice-9 time)

Provides a macro `time', which displays execution time of a given form.

** New module (ice-9 history)

Loading this module enables value history in the repl.

* Changes to the stand-alone interpreter

** New command line option --debug

Start Guile with debugging evaluator and backtraces enabled.

This is useful when debugging your .guile init file or scripts.

** New help facility

Usage: (help NAME) gives documentation about objects named NAME (a symbol)
       (help REGEXP) ditto for objects with names matching REGEXP (a string)
       (help ,EXPR) gives documentation for object returned by EXPR
       (help (my module)) gives module commentary for `(my module)'
       (help) gives this text

`help' searches among bindings exported from loaded modules, while
`apropos' searches among bindings visible from the "current" module.

Examples: (help help)
          (help cons)
          (help "output-string")

** `help' and `apropos' now prints full module names

** Dynamic linking now uses libltdl from the libtool package.

The old system dependent code for doing dynamic linking has been
replaced with calls to the libltdl functions which do all the hairy
details for us.

The major improvement is that you can now directly pass libtool
library names like "libfoo.la" to `dynamic-link' and `dynamic-link'
will be able to do the best shared library job you can get, via
libltdl.

The way dynamic libraries are found has changed and is not really
portable across platforms, probably.  It is therefore recommended to
use absolute filenames when possible.

If you pass a filename without an extension to `dynamic-link', it will
try a few appropriate ones.  Thus, the most platform ignorant way is
to specify a name like "libfoo", without any directories and
extensions.

** Guile COOP threads are now compatible with LinuxThreads

Previously, COOP threading wasn't possible in applications linked with
Linux POSIX threads due to their use of the stack pointer to find the
thread context.  This has now been fixed with a workaround which uses
the pthreads to allocate the stack.

** New primitives: `pkgdata-dir', `site-dir', `library-dir'

** Positions of erring expression in scripts

With version 1.3.4, the location of the erring expression in Guile
scipts is no longer automatically reported.  (This should have been
documented before the 1.3.4 release.)

You can get this information by enabling recording of positions of
source expressions and running the debugging evaluator.  Put this at
the top of your script (or in your "site" file):

  (read-enable 'positions)
  (debug-enable 'debug)

** Backtraces in scripts

It is now possible to get backtraces in scripts.

Put

  (debug-enable 'debug 'backtrace)

at the top of the script.

(The first options enables the debugging evaluator.
 The second enables backtraces.)

** Part of module system symbol lookup now implemented in C

The eval closure of most modules is now implemented in C.  Since this
was one of the bottlenecks for loading speed, Guile now loads code
substantially faster than before.

** Attempting to get the value of an unbound variable now produces
an exception with a key of 'unbound-variable instead of 'misc-error.

** The initial default output port is now unbuffered if it's using a
tty device.  Previously in this situation it was line-buffered.

** New hook: after-gc-hook

after-gc-hook takes over the role of gc-thunk.  This hook is run at
the first SCM_TICK after a GC.  (Thus, the code is run at the same
point during evaluation as signal handlers.)

Note that this hook should be used only for diagnostic and debugging
purposes.  It is not certain that it will continue to be well-defined
when this hook is run in the future.

C programmers: Note the new C level hooks scm_before_gc_c_hook,
scm_before_sweep_c_hook, scm_after_gc_c_hook.

** Improvements to garbage collector

Guile 1.4 has a new policy for triggering heap allocation and
determining the sizes of heap segments.  It fixes a number of problems
in the old GC.

1. The new policy can handle two separate pools of cells
   (2-word/4-word) better.  (The old policy would run wild, allocating
   more and more memory for certain programs.)

2. The old code would sometimes allocate far too much heap so that the
   Guile process became gigantic.  The new code avoids this.

3. The old code would sometimes allocate too little so that few cells
   were freed at GC so that, in turn, too much time was spent in GC.

4. The old code would often trigger heap allocation several times in a
   row.  (The new scheme predicts how large the segments needs to be
   in order not to need further allocation.)

All in all, the new GC policy will make larger applications more
efficient.

The new GC scheme also is prepared for POSIX threading.  Threads can
allocate private pools of cells ("clusters") with just a single
function call.  Allocation of single cells from such a cluster can
then proceed without any need of inter-thread synchronization.

** New environment variables controlling GC parameters

GUILE_MAX_SEGMENT_SIZE          Maximal segment size
                                (default = 2097000)

Allocation of 2-word cell heaps:

GUILE_INIT_SEGMENT_SIZE_1       Size of initial heap segment in bytes
                                (default = 360000)

GUILE_MIN_YIELD_1               Minimum number of freed cells at each
                                GC in percent of total heap size
                                (default = 40)

Allocation of 4-word cell heaps
(used for real numbers and misc other objects):

GUILE_INIT_SEGMENT_SIZE_2, GUILE_MIN_YIELD_2

(See entry "Way for application to customize GC parameters" under
 section "Changes to the scm_ interface" below.)

** Guile now implements reals using 4-word cells

This speeds up computation with reals.  (They were earlier allocated
with `malloc'.)  There is still some room for optimizations, however.

** Some further steps toward POSIX thread support have been taken

*** Guile's critical sections (SCM_DEFER/ALLOW_INTS)
don't have much effect any longer, and many of them will be removed in
next release.

*** Signals
are only handled at the top of the evaluator loop, immediately after
I/O, and in scm_equalp.

*** The GC can allocate thread private pools of pairs.

* Changes to Scheme functions and syntax

** close-input-port and close-output-port are now R5RS

These procedures have been turned into primitives and have R5RS behaviour.

** New procedure: simple-format PORT MESSAGE ARG1 ...

(ice-9 boot) makes `format' an alias for `simple-format' until possibly
extended by the more sophisticated version in (ice-9 format)

(simple-format port message . args)
Write MESSAGE to DESTINATION, defaulting to `current-output-port'.
MESSAGE can contain ~A (was %s) and ~S (was %S) escapes.  When printed,
the escapes are replaced with corresponding members of ARGS:
~A formats using `display' and ~S formats using `write'.
If DESTINATION is #t, then use the `current-output-port',
if DESTINATION is #f, then return a string containing the formatted text.
Does not add a trailing newline."

** string-ref: the second argument is no longer optional.

** string, list->string: no longer accept strings in their arguments,
only characters, for compatibility with R5RS.

** New procedure: port-closed? PORT
Returns #t if PORT is closed or #f if it is open.

** Deprecated: list*

The list* functionality is now provided by cons* (SRFI-1 compliant)

** New procedure: cons* ARG1 ARG2 ... ARGn

Like `list', but the last arg provides the tail of the constructed list,
returning (cons ARG1 (cons ARG2 (cons ... ARGn))).

Requires at least one argument.  If given one argument, that argument
is returned as result.

This function is called `list*' in some other Schemes and in Common LISP.

** Removed deprecated: serial-map, serial-array-copy!, serial-array-map!

** New procedure: object-documentation OBJECT

Returns the documentation string associated with OBJECT.  The
procedure uses a caching mechanism so that subsequent lookups are
faster.

Exported by (ice-9 documentation).

** module-name now returns full names of modules

Previously, only the last part of the name was returned (`session' for
`(ice-9 session)').  Ex: `(ice-9 session)'.

* Changes to the gh_ interface

** Deprecated: gh_int2scmb

Use gh_bool2scm instead.

* Changes to the scm_ interface

** Guile primitives now carry docstrings!

Thanks to Greg Badros!

** Guile primitives are defined in a new way: SCM_DEFINE/SCM_DEFINE1/SCM_PROC

Now Guile primitives are defined using the SCM_DEFINE/SCM_DEFINE1/SCM_PROC
macros and must contain a docstring that is extracted into foo.doc using a new
guile-doc-snarf script (that uses guile-doc-snarf.awk).

However, a major overhaul of these macros is scheduled for the next release of
guile.

** Guile primitives use a new technique for validation of arguments

SCM_VALIDATE_* macros are defined to ease the redundancy and improve
the readability of argument checking.

** All (nearly?) K&R prototypes for functions replaced with ANSI C equivalents.

** New macros: SCM_PACK, SCM_UNPACK

Compose/decompose an SCM value.

The SCM type is now treated as an abstract data type and may be defined as a
long, a void* or as a struct, depending on the architecture and compile time
options. This makes it easier to find several types of bugs, for example when
SCM values are treated as integers without conversion.  Values of the SCM type
should be treated as "atomic" values.  These macros are used when
composing/decomposing an SCM value, either because you want to access
individual bits, or because you want to treat it as an integer value.

E.g., in order to set bit 7 in an SCM value x, use the expression

  SCM_PACK (SCM_UNPACK (x) | 0x80)

** The name property of hooks is deprecated.
Thus, the use of SCM_HOOK_NAME and scm_make_hook_with_name is deprecated.

You can emulate this feature by using object properties.

** Deprecated macros: SCM_INPORTP, SCM_OUTPORTP, SCM_CRDY, SCM_ICHRP,
SCM_ICHR, SCM_MAKICHR, SCM_SETJMPBUF, SCM_NSTRINGP, SCM_NRWSTRINGP,
SCM_NVECTORP

These macros will be removed in a future release of Guile.

** The following types, functions and macros from numbers.h are deprecated:
scm_dblproc, SCM_UNEGFIXABLE, SCM_FLOBUFLEN, SCM_INEXP, SCM_CPLXP, SCM_REAL,
SCM_IMAG, SCM_REALPART, scm_makdbl, SCM_SINGP, SCM_NUM2DBL, SCM_NO_BIGDIG

Further, it is recommended not to rely on implementation details for guile's
current implementation of bignums.  It is planned to replace this
implementation with gmp in the future.

** Port internals: the rw_random variable in the scm_port structure
must be set to non-zero in any random access port.  In recent Guile
releases it was only set for bidirectional random-access ports.

** Port internals: the seek ptob procedure is now responsible for
resetting the buffers if required.  The change was made so that in the
special case of reading the current position (i.e., seek p 0 SEEK_CUR)
the fport and strport ptobs can avoid resetting the buffers,
in particular to avoid discarding unread chars.  An existing port
type can be fixed by adding something like the following to the
beginning of the ptob seek procedure:

      if (pt->rw_active == SCM_PORT_READ)
	scm_end_input (object);
      else if (pt->rw_active == SCM_PORT_WRITE)
	ptob->flush (object);

although to actually avoid resetting the buffers and discard unread
chars requires further hacking that depends on the characteristics
of the ptob.

** Deprecated functions: scm_fseek, scm_tag

These functions are no longer used and will be removed in a future version.

** The scm_sysmissing procedure is no longer used in libguile.
Unless it turns out to be unexpectedly useful to somebody, it will be
removed in a future version.

** The format of error message strings has changed

The two C procedures: scm_display_error and scm_error, as well as the
primitive `scm-error', now use scm_simple_format to do their work.
This means that the message strings of all code must be updated to use
~A where %s was used before, and ~S where %S was used before.

During the period when there still are a lot of old Guiles out there,
you might want to support both old and new versions of Guile.

There are basically two methods to achieve this.  Both methods use
autoconf.  Put

  AC_CHECK_FUNCS(scm_simple_format)

in your configure.in.

Method 1: Use the string concatenation features of ANSI C's
          preprocessor.

In C:

#ifdef HAVE_SCM_SIMPLE_FORMAT
#define FMT_S "~S"
#else
#define FMT_S "%S"
#endif

Then represent each of your error messages using a preprocessor macro:

#define E_SPIDER_ERROR "There's a spider in your " ## FMT_S ## "!!!"

In Scheme:

(define fmt-s (if (defined? 'simple-format) "~S" "%S"))
(define make-message string-append)

(define e-spider-error (make-message "There's a spider in your " fmt-s "!!!"))

Method 2: Use the oldfmt function found in doc/oldfmt.c.

In C:

scm_misc_error ("picnic", scm_c_oldfmt0 ("There's a spider in your ~S!!!"),
                ...);

In Scheme:

(scm-error 'misc-error "picnic" (oldfmt "There's a spider in your ~S!!!")
           ...)


** Deprecated: coop_mutex_init, coop_condition_variable_init

Don't use the functions coop_mutex_init and
coop_condition_variable_init.  They will change.

Use scm_mutex_init and scm_cond_init instead.

** New function: int scm_cond_timedwait (scm_cond_t *COND, scm_mutex_t *MUTEX, const struct timespec *ABSTIME)
     `scm_cond_timedwait' atomically unlocks MUTEX and waits on
     COND, as `scm_cond_wait' does, but it also bounds the duration
     of the wait. If COND has not been signaled before time ABSTIME,
     the mutex MUTEX is re-acquired and `scm_cond_timedwait'
     returns the error code `ETIMEDOUT'.

     The ABSTIME parameter specifies an absolute time, with the same
     origin as `time' and `gettimeofday': an ABSTIME of 0 corresponds
     to 00:00:00 GMT, January 1, 1970.

** New function: scm_cond_broadcast (scm_cond_t *COND)
     `scm_cond_broadcast' restarts all the threads that are waiting
     on the condition variable COND. Nothing happens if no threads are
     waiting on COND.

** New function: scm_key_create (scm_key_t *KEY, void (*destr_function) (void *))
     `scm_key_create' allocates a new TSD key. The key is stored in
     the location pointed to by KEY. There is no limit on the number
     of keys allocated at a given time. The value initially associated
     with the returned key is `NULL' in all currently executing threads.

     The DESTR_FUNCTION argument, if not `NULL', specifies a destructor
     function associated with the key. When a thread terminates,
     DESTR_FUNCTION is called on the value associated with the key in
     that thread. The DESTR_FUNCTION is not called if a key is deleted
     with `scm_key_delete' or a value is changed with
     `scm_setspecific'.  The order in which destructor functions are
     called at thread termination time is unspecified.

     Destructors are not yet implemented.

** New function: scm_setspecific (scm_key_t KEY, const void *POINTER)
     `scm_setspecific' changes the value associated with KEY in the
     calling thread, storing the given POINTER instead.

** New function: scm_getspecific (scm_key_t KEY)
     `scm_getspecific' returns the value currently associated with
     KEY in the calling thread.

** New function: scm_key_delete (scm_key_t KEY)
     `scm_key_delete' deallocates a TSD key. It does not check
     whether non-`NULL' values are associated with that key in the
     currently executing threads, nor call the destructor function
     associated with the key.

** New function: scm_c_hook_init (scm_c_hook_t *HOOK, void *HOOK_DATA, scm_c_hook_type_t TYPE)

Initialize a C level hook HOOK with associated HOOK_DATA and type
TYPE.  (See scm_c_hook_run ().)

** New function: scm_c_hook_add (scm_c_hook_t *HOOK, scm_c_hook_function_t FUNC, void *FUNC_DATA, int APPENDP)

Add hook function FUNC with associated FUNC_DATA to HOOK.  If APPENDP
is true, add it last, otherwise first.  The same FUNC can be added
multiple times if FUNC_DATA differ and vice versa.

** New function: scm_c_hook_remove (scm_c_hook_t *HOOK, scm_c_hook_function_t FUNC, void *FUNC_DATA)

Remove hook function FUNC with associated FUNC_DATA from HOOK.  A
function is only removed if both FUNC and FUNC_DATA matches.

** New function: void *scm_c_hook_run (scm_c_hook_t *HOOK, void *DATA)

Run hook HOOK passing DATA to the hook functions.

If TYPE is SCM_C_HOOK_NORMAL, all hook functions are run.  The value
returned is undefined.

If TYPE is SCM_C_HOOK_OR, hook functions are run until a function
returns a non-NULL value.  This value is returned as the result of
scm_c_hook_run.  If all functions return NULL, NULL is returned.

If TYPE is SCM_C_HOOK_AND, hook functions are run until a function
returns a NULL value, and NULL is returned.  If all functions returns
a non-NULL value, the last value is returned.

** New C level GC hooks

Five new C level hooks has been added to the garbage collector.

  scm_before_gc_c_hook
  scm_after_gc_c_hook

are run before locking and after unlocking the heap.  The system is
thus in a mode where evaluation can take place.  (Except that
scm_before_gc_c_hook must not allocate new cells.)

  scm_before_mark_c_hook
  scm_before_sweep_c_hook
  scm_after_sweep_c_hook

are run when the heap is locked.  These are intended for extension of
the GC in a modular fashion.  Examples are the weaks and guardians
modules.

** Way for application to customize GC parameters

The application can set up other default values for the GC heap
allocation parameters

  GUILE_INIT_HEAP_SIZE_1, GUILE_MIN_YIELD_1,
  GUILE_INIT_HEAP_SIZE_2, GUILE_MIN_YIELD_2,
  GUILE_MAX_SEGMENT_SIZE,

by setting

  scm_default_init_heap_size_1, scm_default_min_yield_1,
  scm_default_init_heap_size_2, scm_default_min_yield_2,
  scm_default_max_segment_size

respectively before callong scm_boot_guile.

(See entry "New environment variables ..." in section
"Changes to the stand-alone interpreter" above.)

** scm_protect_object/scm_unprotect_object now nest

This means that you can call scm_protect_object multiple times on an
object and count on the object being protected until
scm_unprotect_object has been call the same number of times.

The functions also have better time complexity.

Still, it is usually possible to structure the application in a way
that you don't need to use these functions.  For example, if you use a
protected standard Guile list to keep track of live objects rather
than some custom data type, objects will die a natural death when they
are no longer needed.

** Deprecated type tags:  scm_tc16_flo, scm_tc_flo, scm_tc_dblr, scm_tc_dblc

Guile does not provide the float representation for inexact real numbers any
more.  Now, only doubles are used to represent inexact real numbers.  Further,
the tag names scm_tc_dblr and scm_tc_dblc have been changed to scm_tc16_real
and scm_tc16_complex, respectively.

** Removed deprecated type scm_smobfuns

** Removed deprecated function scm_newsmob

** Warning: scm_make_smob_type_mfpe might become deprecated in a future release

There is an ongoing discussion among the developers whether to
deprecate `scm_make_smob_type_mfpe' or not.  Please use the current
standard interface (scm_make_smob_type, scm_set_smob_XXX) in new code
until this issue has been settled.

** Removed deprecated type tag scm_tc16_kw

** Added type tag scm_tc16_keyword

(This was introduced already in release 1.3.4 but was not documented
 until now.)

** gdb_print now prints "*** Guile not initialized ***" until Guile initialized

* Changes to system call interfaces:

** The "select" procedure now tests port buffers for the ability to
provide input or accept output.  Previously only the underlying file
descriptors were checked.

** New variable PIPE_BUF: the maximum number of bytes that can be
atomically written to a pipe.

** If a facility is not available on the system when Guile is
compiled, the corresponding primitive procedure will not be defined.
Previously it would have been defined but would throw a system-error
exception if called.  Exception handlers which catch this case may
need minor modification: an error will be thrown with key
'unbound-variable instead of 'system-error.  Alternatively it's
now possible to use `defined?' to check whether the facility is
available.

** Procedures which depend on the timezone should now give the correct
result on systems which cache the TZ environment variable, even if TZ
is changed without calling tzset.

* Changes to the networking interfaces:

** New functions: htons, ntohs, htonl, ntohl: for converting short and
long integers between network and host format.  For now, it's not
particularly convenient to do this kind of thing, but consider:

(define write-network-long
  (lambda (value port)
    (let ((v (make-uniform-vector 1 1 0)))
      (uniform-vector-set! v 0 (htonl value))
      (uniform-vector-write v port))))

(define read-network-long
  (lambda (port)
    (let ((v (make-uniform-vector 1 1 0)))
      (uniform-vector-read! v port)
      (ntohl (uniform-vector-ref v 0)))))

** If inet-aton fails, it now throws an error with key 'misc-error
instead of 'system-error, since errno is not relevant.

** Certain gethostbyname/gethostbyaddr failures now throw errors with
specific keys instead of 'system-error.  The latter is inappropriate
since errno will not have been set.  The keys are:
'host-not-found, 'try-again, 'no-recovery and 'no-data.

** sethostent, setnetent, setprotoent, setservent: now take an
optional argument STAYOPEN, which specifies whether the database
remains open after a database entry is accessed randomly (e.g., using
gethostbyname for the hosts database.)  The default is #f.  Previously
#t was always used.


Changes since Guile 1.3.2:

* Changes to the stand-alone interpreter

** Debugger

An initial version of the Guile debugger written by Chris Hanson has
been added.  The debugger is still under development but is included
in the distribution anyway since it is already quite useful.

Type

  (debug)

after an error to enter the debugger.  Type `help' inside the debugger
for a description of available commands.

If you prefer to have stack frames numbered and printed in
anti-chronological order and prefer up in the stack to be down on the
screen as is the case in gdb, you can put

  (debug-enable 'backwards)

in your .guile startup file.  (However, this means that Guile can't
use indentation to indicate stack level.)

The debugger is autoloaded into Guile at the first use.

** Further enhancements to backtraces

There is a new debug option `width' which controls the maximum width
on the screen of printed stack frames.  Fancy printing parameters
("level" and "length" as in Common LISP) are adaptively adjusted for
each stack frame to give maximum information while still fitting
within the bounds.  If the stack frame can't be made to fit by
adjusting parameters, it is simply cut off at the end.  This is marked
with a `$'.

** Some modules are now only loaded when the repl is started

The modules (ice-9 debug), (ice-9 session), (ice-9 threads) and (ice-9
regex) are now loaded into (guile-user) only if the repl has been
started.  The effect is that the startup time for scripts has been
reduced to 30% of what it was previously.

Correctly written scripts load the modules they require at the top of
the file and should not be affected by this change.

** Hooks are now represented as smobs

* Changes to Scheme functions and syntax

** Readline support has changed again.

The old (readline-activator) module is gone.  Use (ice-9 readline)
instead, which now contains all readline functionality.  So the code
to activate readline is now

    (use-modules (ice-9 readline))
    (activate-readline)

This should work at any time, including from the guile prompt.

To avoid confusion about the terms of Guile's license, please only
enable readline for your personal use; please don't make it the
default for others.  Here is why we make this rather odd-sounding
request:

Guile is normally licensed under a weakened form of the GNU General
Public License, which allows you to link code with Guile without
placing that code under the GPL.  This exception is important to some
people.

However, since readline is distributed under the GNU General Public
License, when you link Guile with readline, either statically or
dynamically, you effectively change Guile's license to the strict GPL.
Whenever you link any strictly GPL'd code into Guile, uses of Guile
which are normally permitted become forbidden.  This is a rather
non-obvious consequence of the licensing terms.

So, to make sure things remain clear, please let people choose for
themselves whether to link GPL'd libraries like readline with Guile.

** regexp-substitute/global has changed slightly, but incompatibly.

If you include a function in the item list, the string of the match
object it receives is the same string passed to
regexp-substitute/global, not some suffix of that string.
Correspondingly, the match's positions are relative to the entire
string, not the suffix.

If the regexp can match the empty string, the way matches are chosen
from the string has changed.  regexp-substitute/global recognizes the
same set of matches that list-matches does; see below.

** New function: list-matches REGEXP STRING [FLAGS]

Return a list of match objects, one for every non-overlapping, maximal
match of REGEXP in STRING.  The matches appear in left-to-right order.
list-matches only reports matches of the empty string if there are no
other matches which begin on, end at, or include the empty match's
position.

If present, FLAGS is passed as the FLAGS argument to regexp-exec.

** New function: fold-matches REGEXP STRING INIT PROC [FLAGS]

For each match of REGEXP in STRING, apply PROC to the match object,
and the last value PROC returned, or INIT for the first call.  Return
the last value returned by PROC.  We apply PROC to the matches as they
appear from left to right.

This function recognizes matches according to the same criteria as
list-matches.

Thus, you could define list-matches like this:

  (define (list-matches regexp string . flags)
    (reverse! (apply fold-matches regexp string '() cons flags)))

If present, FLAGS is passed as the FLAGS argument to regexp-exec.

** Hooks

*** New function: hook? OBJ

Return #t if OBJ is a hook, otherwise #f.

*** New function: make-hook-with-name NAME [ARITY]

Return a hook with name NAME and arity ARITY.  The default value for
ARITY is 0.  The only effect of NAME is that it will appear when the
hook object is printed to ease debugging.

*** New function: hook-empty? HOOK

Return #t if HOOK doesn't contain any procedures, otherwise #f.

*** New function: hook->list HOOK

Return a list of the procedures that are called when run-hook is
applied to HOOK.

** `map' signals an error if its argument lists are not all the same length.

This is the behavior required by R5RS, so this change is really a bug
fix.  But it seems to affect a lot of people's code, so we're
mentioning it here anyway.

** Print-state handling has been made more transparent

Under certain circumstances, ports are represented as a port with an
associated print state.  Earlier, this pair was represented as a pair
(see "Some magic has been added to the printer" below).  It is now
indistinguishable (almost; see `get-print-state') from a port on the
user level.

*** New function: port-with-print-state OUTPUT-PORT PRINT-STATE

Return a new port with the associated print state PRINT-STATE.

*** New function: get-print-state OUTPUT-PORT

Return the print state associated with this port if it exists,
otherwise return #f.

*** New function: directory-stream? OBJECT

Returns true iff OBJECT is a directory stream --- the sort of object
returned by `opendir'.

** New function: using-readline?

Return #t if readline is in use in the current repl.

** structs will be removed in 1.4

Structs will be replaced in Guile 1.4.  We will merge GOOPS into Guile
and use GOOPS objects as the fundamental record type.

* Changes to the scm_ interface

** structs will be removed in 1.4

The entire current struct interface (struct.c, struct.h) will be
replaced in Guile 1.4.  We will merge GOOPS into libguile and use
GOOPS objects as the fundamental record type.

** The internal representation of subr's has changed

Instead of giving a hint to the subr name, the CAR field of the subr
now contains an index to a subr entry in scm_subr_table.

*** New variable: scm_subr_table

An array of subr entries.  A subr entry contains the name, properties
and documentation associated with the subr.  The properties and
documentation slots are not yet used.

** A new scheme for "forwarding" calls to a builtin to a generic function

It is now possible to extend the functionality of some Guile
primitives by letting them defer a call to a GOOPS generic function on
argument mismatch.  This means that there is no loss of efficiency in
normal evaluation.

Example:

  (use-modules (oop goops)) ; Must be GOOPS version 0.2.
  (define-method + ((x <string>) (y <string>))
    (string-append x y))

+ will still be as efficient as usual in numerical calculations, but
can also be used for concatenating strings.

Who will be the first one to extend Guile's numerical tower to
rationals?  :)  [OK, there a few other things to fix before this can
be made in a clean way.]

*** New snarf macros for defining primitives: SCM_GPROC, SCM_GPROC1

  New macro: SCM_GPROC (CNAME, SNAME, REQ, OPT, VAR, CFUNC, GENERIC)

  New macro: SCM_GPROC1 (CNAME, SNAME, TYPE, CFUNC, GENERIC)

These do the same job as SCM_PROC and SCM_PROC1, but they also define
a variable GENERIC which can be used by the dispatch macros below.

[This is experimental code which may change soon.]

*** New macros for forwarding control to a generic on arg type error

  New macro: SCM_WTA_DISPATCH_1 (GENERIC, ARG1, POS, SUBR)

  New macro: SCM_WTA_DISPATCH_2 (GENERIC, ARG1, ARG2, POS, SUBR)

These correspond to the scm_wta function call, and have the same
behaviour until the user has called the GOOPS primitive
`enable-primitive-generic!'.  After that, these macros will apply the
generic function GENERIC to the argument(s) instead of calling
scm_wta.

[This is experimental code which may change soon.]

*** New macros for argument testing with generic dispatch

  New macro: SCM_GASSERT1 (COND, GENERIC, ARG1, POS, SUBR)

  New macro: SCM_GASSERT2 (COND, GENERIC, ARG1, ARG2, POS, SUBR)

These correspond to the SCM_ASSERT macro, but will defer control to
GENERIC on error after `enable-primitive-generic!' has been called.

[This is experimental code which may change soon.]

** New function: SCM scm_eval_body (SCM body, SCM env)

Evaluates the body of a special form.

** The internal representation of struct's has changed

Previously, four slots were allocated for the procedure(s) of entities
and operators.  The motivation for this representation had to do with
the structure of the evaluator, the wish to support tail-recursive
generic functions, and efficiency.  Since the generic function
dispatch mechanism has changed, there is no longer a need for such an
expensive representation, and the representation has been simplified.

This should not make any difference for most users.

** GOOPS support has been cleaned up.

Some code has been moved from eval.c to objects.c and code in both of
these compilation units has been cleaned up and better structured.

*** New functions for applying generic functions

  New function: SCM scm_apply_generic (GENERIC, ARGS)
  New function: SCM scm_call_generic_0 (GENERIC)
  New function: SCM scm_call_generic_1 (GENERIC, ARG1)
  New function: SCM scm_call_generic_2 (GENERIC, ARG1, ARG2)
  New function: SCM scm_call_generic_3 (GENERIC, ARG1, ARG2, ARG3)

** Deprecated function: scm_make_named_hook

It is now replaced by:

** New function: SCM scm_create_hook (const char *name, int arity)

Creates a hook in the same way as make-hook above but also
binds a variable named NAME to it.

This is the typical way of creating a hook from C code.

Currently, the variable is created in the "current" module.
This might change when we get the new module system.

[The behaviour is identical to scm_make_named_hook.]



Changes since Guile 1.3:

* Changes to mailing lists

** Some of the Guile mailing lists have moved to sourceware.cygnus.com.

See the README file to find current addresses for all the Guile
mailing lists.

* Changes to the distribution

** Readline support is no longer included with Guile by default.

Based on the different license terms of Guile and Readline, we
concluded that Guile should not *by default* cause the linking of
Readline into an application program.  Readline support is now offered
as a separate module, which is linked into an application only when
you explicitly specify it.

Although Guile is GNU software, its distribution terms add a special
exception to the usual GNU General Public License (GPL).  Guile's
license includes a clause that allows you to link Guile with non-free
programs.  We add this exception so as not to put Guile at a
disadvantage vis-a-vis other extensibility packages that support other
languages.

In contrast, the GNU Readline library is distributed under the GNU
General Public License pure and simple.  This means that you may not
link Readline, even dynamically, into an application unless it is
distributed under a free software license that is compatible the GPL.

Because of this difference in distribution terms, an application that
can use Guile may not be able to use Readline.  Now users will be
explicitly offered two independent decisions about the use of these
two packages.

You can activate the readline support by issuing

    (use-modules (readline-activator))
    (activate-readline)

from your ".guile" file, for example.

* Changes to the stand-alone interpreter

** All builtins now print as primitives.
Previously builtin procedures not belonging to the fundamental subr
types printed as #<compiled closure #<primitive-procedure gsubr-apply>>.
Now, they print as #<primitive-procedure NAME>.

** Backtraces slightly more intelligible.
gsubr-apply and macro transformer application frames no longer appear
in backtraces.

* Changes to Scheme functions and syntax

** Guile now correctly handles internal defines by rewriting them into
their equivalent letrec.  Previously, internal defines would
incrementally add to the innermost environment, without checking
whether the restrictions specified in RnRS were met.  This lead to the
correct behaviour when these restriction actually were met, but didn't
catch all illegal uses.  Such an illegal use could lead to crashes of
the Guile interpreter or or other unwanted results.  An example of
incorrect internal defines that made Guile behave erratically:

  (let ()
    (define a 1)
    (define (b) a)
    (define c (1+ (b)))
    (define d 3)

    (b))

  => 2

The problem with this example is that the definition of `c' uses the
value of `b' directly.  This confuses the meoization machine of Guile
so that the second call of `b' (this time in a larger environment that
also contains bindings for `c' and `d') refers to the binding of `c'
instead of `a'.  You could also make Guile crash with a variation on
this theme:

    (define (foo flag)
      (define a 1)
      (define (b flag) (if flag a 1))
      (define c (1+ (b flag)))
      (define d 3)

      (b #t))

    (foo #f)
    (foo #t)

From now on, Guile will issue an `Unbound variable: b' error message
for both examples.

** Hooks

A hook contains a list of functions which should be called on
particular occasions in an existing program.  Hooks are used for
customization.

A window manager might have a hook before-window-map-hook.  The window
manager uses the function run-hooks to call all functions stored in
before-window-map-hook each time a window is mapped.  The user can
store functions in the hook using add-hook!.

In Guile, hooks are first class objects.

*** New function: make-hook [N_ARGS]

Return a hook for hook functions which can take N_ARGS arguments.
The default value for N_ARGS is 0.

(See also scm_make_named_hook below.)

*** New function: add-hook! HOOK PROC [APPEND_P]

Put PROC at the beginning of the list of functions stored in HOOK.
If APPEND_P is supplied, and non-false, put PROC at the end instead.

PROC must be able to take the number of arguments specified when the
hook was created.

If PROC already exists in HOOK, then remove it first.

*** New function: remove-hook! HOOK PROC

Remove PROC from the list of functions in HOOK.

*** New function: reset-hook! HOOK

Clear the list of hook functions stored in HOOK.

*** New function: run-hook HOOK ARG1 ...

Run all hook functions stored in HOOK with arguments ARG1 ... .
The number of arguments supplied must correspond to the number given
when the hook was created.

** The function `dynamic-link' now takes optional keyword arguments.
   The only keyword argument that is currently defined is `:global
   BOOL'.  With it, you can control whether the shared library will be
   linked in global mode or not.  In global mode, the symbols from the
   linked library can be used to resolve references from other
   dynamically linked libraries.  In non-global mode, the linked
   library is essentially invisible and can only be accessed via
   `dynamic-func', etc.  The default is now to link in global mode.
   Previously, the default has been non-global mode.

   The `#:global' keyword is only effective on platforms that support
   the dlopen family of functions.

** New function `provided?'

 - Function: provided? FEATURE
     Return true iff FEATURE is supported by this installation of
     Guile.  FEATURE must be a symbol naming a feature; the global
     variable `*features*' is a list of available features.

** Changes to the module (ice-9 expect):

*** The expect-strings macro now matches `$' in a regular expression
    only at a line-break or end-of-file by default.  Previously it would
    match the end of the string accumulated so far. The old behaviour
    can be obtained by setting the variable `expect-strings-exec-flags'
    to 0.

*** The expect-strings macro now uses a variable `expect-strings-exec-flags'
    for the regexp-exec flags.  If `regexp/noteol' is included, then `$'
    in a regular expression will still match before a line-break or
    end-of-file.  The default is `regexp/noteol'.

*** The expect-strings macro now uses a variable
    `expect-strings-compile-flags' for the flags to be supplied to
    `make-regexp'.  The default is `regexp/newline', which was previously
    hard-coded.

*** The expect macro now supplies two arguments to a match procedure:
    the current accumulated string and a flag to indicate whether
    end-of-file has been reached.  Previously only the string was supplied.
    If end-of-file is reached, the match procedure will be called an
    additional time with the same accumulated string as the previous call
    but with the flag set.

** New module (ice-9 format), implementing the Common Lisp `format' function.

This code, and the documentation for it that appears here, was
borrowed from SLIB, with minor adaptations for Guile.

 - Function: format DESTINATION FORMAT-STRING . ARGUMENTS
     An almost complete implementation of Common LISP format description
     according to the CL reference book `Common LISP' from Guy L.
     Steele, Digital Press.  Backward compatible to most of the
     available Scheme format implementations.

     Returns `#t', `#f' or a string; has side effect of printing
     according to FORMAT-STRING.  If DESTINATION is `#t', the output is
     to the current output port and `#t' is returned.  If DESTINATION
     is `#f', a formatted string is returned as the result of the call.
     NEW: If DESTINATION is a string, DESTINATION is regarded as the
     format string; FORMAT-STRING is then the first argument and the
     output is returned as a string. If DESTINATION is a number, the
     output is to the current error port if available by the
     implementation. Otherwise DESTINATION must be an output port and
     `#t' is returned.

     FORMAT-STRING must be a string.  In case of a formatting error
     format returns `#f' and prints a message on the current output or
     error port.  Characters are output as if the string were output by
     the `display' function with the exception of those prefixed by a
     tilde (~).  For a detailed description of the FORMAT-STRING syntax
     please consult a Common LISP format reference manual.  For a test
     suite to verify this format implementation load `formatst.scm'.
     Please send bug reports to `lutzeb@cs.tu-berlin.de'.

     Note: `format' is not reentrant, i.e. only one `format'-call may
     be executed at a time.


*** Format Specification (Format version 3.0)

   Please consult a Common LISP format reference manual for a detailed
description of the format string syntax.  For a demonstration of the
implemented directives see `formatst.scm'.

   This implementation supports directive parameters and modifiers (`:'
and `@' characters). Multiple parameters must be separated by a comma
(`,').  Parameters can be numerical parameters (positive or negative),
character parameters (prefixed by a quote character (`''), variable
parameters (`v'), number of rest arguments parameter (`#'), empty and
default parameters.  Directive characters are case independent. The
general form of a directive is:

DIRECTIVE ::= ~{DIRECTIVE-PARAMETER,}[:][@]DIRECTIVE-CHARACTER

DIRECTIVE-PARAMETER ::= [ [-|+]{0-9}+ | 'CHARACTER | v | # ]

*** Implemented CL Format Control Directives

   Documentation syntax: Uppercase characters represent the
corresponding control directive characters. Lowercase characters
represent control directive parameter descriptions.

`~A'
     Any (print as `display' does).
    `~@A'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARA'
          full padding.

`~S'
     S-expression (print as `write' does).
    `~@S'
          left pad.

    `~MINCOL,COLINC,MINPAD,PADCHARS'
          full padding.

`~D'
     Decimal.
    `~@D'
          print number sign always.

    `~:D'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARD'
          padding.

`~X'
     Hexadecimal.
    `~@X'
          print number sign always.

    `~:X'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARX'
          padding.

`~O'
     Octal.
    `~@O'
          print number sign always.

    `~:O'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARO'
          padding.

`~B'
     Binary.
    `~@B'
          print number sign always.

    `~:B'
          print comma separated.

    `~MINCOL,PADCHAR,COMMACHARB'
          padding.

`~NR'
     Radix N.
    `~N,MINCOL,PADCHAR,COMMACHARR'
          padding.

`~@R'
     print a number as a Roman numeral.

`~:@R'
     print a number as an "old fashioned" Roman numeral.

`~:R'
     print a number as an ordinal English number.

`~:@R'
     print a number as a cardinal English number.

`~P'
     Plural.
    `~@P'
          prints `y' and `ies'.

    `~:P'
          as `~P but jumps 1 argument backward.'

    `~:@P'
          as `~@P but jumps 1 argument backward.'

`~C'
     Character.
    `~@C'
          prints a character as the reader can understand it (i.e. `#\'
          prefixing).

    `~:C'
          prints a character as emacs does (eg. `^C' for ASCII 03).

`~F'
     Fixed-format floating-point (prints a flonum like MMM.NNN).
    `~WIDTH,DIGITS,SCALE,OVERFLOWCHAR,PADCHARF'
    `~@F'
          If the number is positive a plus sign is printed.

`~E'
     Exponential floating-point (prints a flonum like MMM.NNN`E'EE).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARE'
    `~@E'
          If the number is positive a plus sign is printed.

`~G'
     General floating-point (prints a flonum either fixed or
     exponential).
    `~WIDTH,DIGITS,EXPONENTDIGITS,SCALE,OVERFLOWCHAR,PADCHAR,EXPONENTCHARG'
    `~@G'
          If the number is positive a plus sign is printed.

`~$'
     Dollars floating-point (prints a flonum in fixed with signs
     separated).
    `~DIGITS,SCALE,WIDTH,PADCHAR$'
    `~@$'
          If the number is positive a plus sign is printed.

    `~:@$'
          A sign is always printed and appears before the padding.

    `~:$'
          The sign appears before the padding.

`~%'
     Newline.
    `~N%'
          print N newlines.

`~&'
     print newline if not at the beginning of the output line.
    `~N&'
          prints `~&' and then N-1 newlines.

`~|'
     Page Separator.
    `~N|'
          print N page separators.

`~~'
     Tilde.
    `~N~'
          print N tildes.

`~'<newline>
     Continuation Line.
    `~:'<newline>
          newline is ignored, white space left.

    `~@'<newline>
          newline is left, white space ignored.

`~T'
     Tabulation.
    `~@T'
          relative tabulation.

    `~COLNUM,COLINCT'
          full tabulation.

`~?'
     Indirection (expects indirect arguments as a list).
    `~@?'
          extracts indirect arguments from format arguments.

`~(STR~)'
     Case conversion (converts by `string-downcase').
    `~:(STR~)'
          converts by `string-capitalize'.

    `~@(STR~)'
          converts by `string-capitalize-first'.

    `~:@(STR~)'
          converts by `string-upcase'.

`~*'
     Argument Jumping (jumps 1 argument forward).
    `~N*'
          jumps N arguments forward.

    `~:*'
          jumps 1 argument backward.

    `~N:*'
          jumps N arguments backward.

    `~@*'
          jumps to the 0th argument.

    `~N@*'
          jumps to the Nth argument (beginning from 0)

`~[STR0~;STR1~;...~;STRN~]'
     Conditional Expression (numerical clause conditional).
    `~N['
          take argument from N.

    `~@['
          true test conditional.

    `~:['
          if-else-then conditional.

    `~;'
          clause separator.

    `~:;'
          default clause follows.

`~{STR~}'
     Iteration (args come from the next argument (a list)).
    `~N{'
          at most N iterations.

    `~:{'
          args from next arg (a list of lists).

    `~@{'
          args from the rest of arguments.

    `~:@{'
          args from the rest args (lists).

`~^'
     Up and out.
    `~N^'
          aborts if N = 0

    `~N,M^'
          aborts if N = M

    `~N,M,K^'
          aborts if N <= M <= K

*** Not Implemented CL Format Control Directives

`~:A'
     print `#f' as an empty list (see below).

`~:S'
     print `#f' as an empty list (see below).

`~<~>'
     Justification.

`~:^'
     (sorry I don't understand its semantics completely)

*** Extended, Replaced and Additional Control Directives

`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHD'
`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHX'
`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHO'
`~MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHB'
`~N,MINCOL,PADCHAR,COMMACHAR,COMMAWIDTHR'
     COMMAWIDTH is the number of characters between two comma
     characters.

`~I'
     print a R4RS complex number as `~F~@Fi' with passed parameters for
     `~F'.

`~Y'
     Pretty print formatting of an argument for scheme code lists.

`~K'
     Same as `~?.'

`~!'
     Flushes the output if format DESTINATION is a port.

`~_'
     Print a `#\space' character
    `~N_'
          print N `#\space' characters.

`~/'
     Print a `#\tab' character
    `~N/'
          print N `#\tab' characters.

`~NC'
     Takes N as an integer representation for a character. No arguments
     are consumed. N is converted to a character by `integer->char'.  N
     must be a positive decimal number.

`~:S'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~:A'
     Print out readproof.  Prints out internal objects represented as
     `#<...>' as strings `"#<...>"' so that the format output can always
     be processed by `read'.

`~Q'
     Prints information and a copyright notice on the format
     implementation.
    `~:Q'
          prints format version.

`~F, ~E, ~G, ~$'
     may also print number strings, i.e. passing a number as a string
     and format it accordingly.

*** Configuration Variables

   The format module exports some configuration variables to suit the
systems and users needs. There should be no modification necessary for
the configuration that comes with Guile.  Format detects automatically
if the running scheme system implements floating point numbers and
complex numbers.

format:symbol-case-conv
     Symbols are converted by `symbol->string' so the case type of the
     printed symbols is implementation dependent.
     `format:symbol-case-conv' is a one arg closure which is either
     `#f' (no conversion), `string-upcase', `string-downcase' or
     `string-capitalize'. (default `#f')

format:iobj-case-conv
     As FORMAT:SYMBOL-CASE-CONV but applies for the representation of
     implementation internal objects. (default `#f')

format:expch
     The character prefixing the exponent value in `~E' printing.
     (default `#\E')

*** Compatibility With Other Format Implementations

SLIB format 2.x:
     See `format.doc'.

SLIB format 1.4:
     Downward compatible except for padding support and `~A', `~S',
     `~P', `~X' uppercase printing.  SLIB format 1.4 uses C-style
     `printf' padding support which is completely replaced by the CL
     `format' padding style.

MIT C-Scheme 7.1:
     Downward compatible except for `~', which is not documented
     (ignores all characters inside the format string up to a newline
     character).  (7.1 implements `~a', `~s', ~NEWLINE, `~~', `~%',
     numerical and variable parameters and `:/@' modifiers in the CL
     sense).

Elk 1.5/2.0:
     Downward compatible except for `~A' and `~S' which print in
     uppercase.  (Elk implements `~a', `~s', `~~', and `~%' (no
     directive parameters or modifiers)).

Scheme->C 01nov91:
     Downward compatible except for an optional destination parameter:
     S2C accepts a format call without a destination which returns a
     formatted string. This is equivalent to a #f destination in S2C.
     (S2C implements `~a', `~s', `~c', `~%', and `~~' (no directive
     parameters or modifiers)).


** Changes to string-handling functions.

These functions were added to support the (ice-9 format) module, above.

*** New function: string-upcase STRING
*** New function: string-downcase STRING

These are non-destructive versions of the existing string-upcase! and
string-downcase! functions.

*** New function: string-capitalize! STRING
*** New function: string-capitalize STRING

These functions convert the first letter of each word in the string to
upper case.  Thus:

      (string-capitalize "howdy there")
      => "Howdy There"

As with the other functions, string-capitalize! modifies the string in
place, while string-capitalize returns a modified copy of its argument.

*** New function: string-ci->symbol STRING

Return a symbol whose name is STRING, but having the same case as if
the symbol had be read by `read'.

Guile can be configured to be sensitive or insensitive to case
differences in Scheme identifiers.  If Guile is case-insensitive, all
symbols are converted to lower case on input.  The `string-ci->symbol'
function returns a symbol whose name in STRING, transformed as Guile
would if STRING were input.

*** New function: substring-move! STRING1 START END STRING2 START

Copy the substring of STRING1 from START (inclusive) to END
(exclusive) to STRING2 at START.  STRING1 and STRING2 may be the same
string, and the source and destination areas may overlap; in all
cases, the function behaves as if all the characters were copied
simultanously.

*** Extended functions: substring-move-left! substring-move-right!

These functions now correctly copy arbitrarily overlapping substrings;
they are both synonyms for substring-move!.


** New module (ice-9 getopt-long), with the function `getopt-long'.

getopt-long is a function for parsing command-line arguments in a
manner consistent with other GNU programs.

(getopt-long ARGS GRAMMAR)
Parse the arguments ARGS according to the argument list grammar GRAMMAR.

ARGS should be a list of strings.  Its first element should be the
name of the program; subsequent elements should be the arguments
that were passed to the program on the command line.  The
`program-arguments' procedure returns a list of this form.

GRAMMAR is a list of the form:
((OPTION (PROPERTY VALUE) ...) ...)

Each OPTION should be a symbol.  `getopt-long' will accept a
command-line option named `--OPTION'.
Each option can have the following (PROPERTY VALUE) pairs:

  (single-char CHAR) --- Accept `-CHAR' as a single-character
            equivalent to `--OPTION'.  This is how to specify traditional
            Unix-style flags.
  (required? BOOL) --- If BOOL is true, the option is required.
            getopt-long will raise an error if it is not found in ARGS.
  (value BOOL) --- If BOOL is #t, the option accepts a value; if
            it is #f, it does not; and if it is the symbol
            `optional', the option may appear in ARGS with or
            without a value.
  (predicate FUNC) --- If the option accepts a value (i.e. you
            specified `(value #t)' for this option), then getopt
            will apply FUNC to the value, and throw an exception
            if it returns #f.  FUNC should be a procedure which
            accepts a string and returns a boolean value; you may
            need to use quasiquotes to get it into GRAMMAR.

The (PROPERTY VALUE) pairs may occur in any order, but each
property may occur only once.  By default, options do not have
single-character equivalents, are not required, and do not take
values.

In ARGS, single-character options may be combined, in the usual
Unix fashion: ("-x" "-y") is equivalent to ("-xy").  If an option
accepts values, then it must be the last option in the
combination; the value is the next argument.  So, for example, using
the following grammar:
     ((apples    (single-char #\a))
      (blimps    (single-char #\b) (value #t))
      (catalexis (single-char #\c) (value #t)))
the following argument lists would be acceptable:
   ("-a" "-b" "bang" "-c" "couth")     ("bang" and "couth" are the values
                                        for "blimps" and "catalexis")
   ("-ab" "bang" "-c" "couth")         (same)
   ("-ac" "couth" "-b" "bang")         (same)
   ("-abc" "couth" "bang")             (an error, since `-b' is not the
                                        last option in its combination)

If an option's value is optional, then `getopt-long' decides
whether it has a value by looking at what follows it in ARGS.  If
the next element is a string, and it does not appear to be an
option itself, then that string is the option's value.

The value of a long option can appear as the next element in ARGS,
or it can follow the option name, separated by an `=' character.
Thus, using the same grammar as above, the following argument lists
are equivalent:
  ("--apples" "Braeburn" "--blimps" "Goodyear")
  ("--apples=Braeburn" "--blimps" "Goodyear")
  ("--blimps" "Goodyear" "--apples=Braeburn")

If the option "--" appears in ARGS, argument parsing stops there;
subsequent arguments are returned as ordinary arguments, even if
they resemble options.  So, in the argument list:
        ("--apples" "Granny Smith" "--" "--blimp" "Goodyear")
`getopt-long' will recognize the `apples' option as having the
value "Granny Smith", but it will not recognize the `blimp'
option; it will return the strings "--blimp" and "Goodyear" as
ordinary argument strings.

The `getopt-long' function returns the parsed argument list as an
assocation list, mapping option names --- the symbols from GRAMMAR
--- onto their values, or #t if the option does not accept a value.
Unused options do not appear in the alist.

All arguments that are not the value of any option are returned
as a list, associated with the empty list.

`getopt-long' throws an exception if:
- it finds an unrecognized option in ARGS
- a required option is omitted
- an option that requires an argument doesn't get one
- an option that doesn't accept an argument does get one (this can
  only happen using the long option `--opt=value' syntax)
- an option predicate fails

So, for example:

(define grammar
  `((lockfile-dir (required? #t)
                  (value #t)
                  (single-char #\k)
                  (predicate ,file-is-directory?))
    (verbose (required? #f)
             (single-char #\v)
             (value #f))
    (x-includes (single-char #\x))
    (rnet-server (single-char #\y)
                 (predicate ,string?))))

(getopt-long '("my-prog" "-vk" "/tmp" "foo1" "--x-includes=/usr/include"
               "--rnet-server=lamprod" "--" "-fred" "foo2" "foo3")
               grammar)
=> ((() "foo1" "-fred" "foo2" "foo3")
    (rnet-server . "lamprod")
    (x-includes . "/usr/include")
    (lockfile-dir . "/tmp")
    (verbose . #t))

** The (ice-9 getopt-gnu-style) module is obsolete; use (ice-9 getopt-long).

It will be removed in a few releases.

** New syntax: lambda*
** New syntax: define*
** New syntax: define*-public
** New syntax: defmacro*
** New syntax: defmacro*-public
Guile now supports optional arguments.

`lambda*', `define*', `define*-public', `defmacro*' and
`defmacro*-public' are identical to the non-* versions except that
they use an extended type of parameter list that has the following BNF
syntax (parentheses are literal, square brackets indicate grouping,
and `*', `+' and `?' have the usual meaning):

   ext-param-list ::= ( [identifier]* [#&optional [ext-var-decl]+]?
      [#&key [ext-var-decl]+ [#&allow-other-keys]?]?
      [[#&rest identifier]|[. identifier]]? ) | [identifier]

   ext-var-decl ::= identifier | ( identifier expression )

The semantics are best illustrated with the following documentation
and examples for `lambda*':

 lambda* args . body
   lambda extended for optional and keyword arguments

 lambda* creates a procedure that takes optional arguments. These
 are specified by putting them inside brackets at the end of the
 paramater list, but before any dotted rest argument. For example,
   (lambda* (a b #&optional c d . e) '())
 creates a procedure with fixed arguments a and b, optional arguments c
 and d, and rest argument e. If the optional arguments are omitted
 in a call, the variables for them are unbound in the procedure. This
 can be checked with the bound? macro.

 lambda* can also take keyword arguments. For example, a procedure
 defined like this:
   (lambda* (#&key xyzzy larch) '())
 can be called with any of the argument lists (#:xyzzy 11)
 (#:larch 13) (#:larch 42 #:xyzzy 19) (). Whichever arguments
 are given as keywords are bound to values.

 Optional and keyword arguments can also be given default values
 which they take on when they are not present in a call, by giving a
 two-item list in place of an optional argument, for example in:
   (lambda* (foo #&optional (bar 42) #&key (baz 73)) (list foo bar baz))
 foo is a fixed argument, bar is an optional argument with default
 value 42, and baz is a keyword argument with default value 73.
 Default value expressions are not evaluated unless they are needed
 and until the procedure is called.

 lambda* now supports two more special parameter list keywords.

 lambda*-defined procedures now throw an error by default if a
 keyword other than one of those specified is found in the actual
 passed arguments. However, specifying #&allow-other-keys
 immediately after the kyword argument declarations restores the
 previous behavior of ignoring unknown keywords. lambda* also now
 guarantees that if the same keyword is passed more than once, the
 last one passed is the one that takes effect. For example,
  ((lambda* (#&key (heads 0) (tails 0)) (display (list heads tails)))
    #:heads 37 #:tails 42 #:heads 99)
 would result in (99 47) being displayed.

 #&rest is also now provided as a synonym for the dotted syntax rest
 argument. The argument lists (a . b) and (a #&rest b) are equivalent in
 all respects to lambda*. This is provided for more similarity to DSSSL,
 MIT-Scheme and Kawa among others, as well as for refugees from other
 Lisp dialects.

Further documentation may be found in the optargs.scm file itself.

The optional argument module also exports the macros `let-optional',
`let-optional*', `let-keywords', `let-keywords*' and `bound?'. These
are not documented here because they may be removed in the future, but
full documentation is still available in optargs.scm.

** New syntax: and-let*
Guile now supports the `and-let*' form, described in the draft SRFI-2.

Syntax: (land* (<clause> ...) <body> ...)
Each <clause> should have one of the following forms:
  (<variable> <expression>)
  (<expression>)
  <bound-variable>
Each <variable> or <bound-variable> should be an identifier.  Each
<expression> should be a valid expression.  The <body> should be a
possibly empty sequence of expressions, like the <body> of a
lambda form.

Semantics: A LAND* expression is evaluated by evaluating the
<expression> or <bound-variable> of each of the <clause>s from
left to right.  The value of the first <expression> or
<bound-variable> that evaluates to a false value is returned; the
remaining <expression>s and <bound-variable>s are not evaluated.
The <body> forms are evaluated iff all the <expression>s and
<bound-variable>s evaluate to true values.

The <expression>s and the <body> are evaluated in an environment
binding each <variable> of the preceding (<variable> <expression>)
clauses to the value of the <expression>.  Later bindings
shadow earlier bindings.

Guile's and-let* macro was contributed by Michael Livshin.

** New sorting functions

*** New function: sorted? SEQUENCE LESS?
Returns `#t' when the sequence argument is in non-decreasing order
according to LESS? (that is, there is no adjacent pair `... x y
...' for which `(less? y x)').

Returns `#f' when the sequence contains at least one out-of-order
pair.  It is an error if the sequence is neither a list nor a
vector.

*** New function: merge LIST1 LIST2 LESS?
LIST1 and LIST2 are sorted lists.
Returns the sorted list of all elements in LIST1 and LIST2.

Assume that the elements a and b1 in LIST1 and b2 in LIST2 are "equal"
in the sense that (LESS? x y) --> #f for x, y in {a, b1, b2},
and that a < b1 in LIST1.  Then a < b1 < b2 in the result.
(Here "<" should read "comes before".)

*** New procedure: merge! LIST1 LIST2 LESS?
Merges two lists, re-using the pairs of LIST1 and LIST2 to build
the result.  If the code is compiled, and LESS? constructs no new
pairs, no pairs at all will be allocated.  The first pair of the
result will be either the first pair of LIST1 or the first pair of
LIST2.

*** New function: sort SEQUENCE LESS?
Accepts either a list or a vector, and returns a new sequence
which is sorted.  The new sequence is the same type as the input.
Always `(sorted? (sort sequence less?) less?)'.  The original
sequence is not altered in any way.  The new sequence shares its
elements with the old one; no elements are copied.

*** New procedure: sort! SEQUENCE LESS
Returns its sorted result in the original boxes.  No new storage is
allocated at all.  Proper usage: (set! slist (sort! slist <))

*** New function: stable-sort SEQUENCE LESS?
Similar to `sort' but stable.  That is, if "equal" elements are
ordered a < b in the original sequence, they will have the same order
in the result.

*** New function: stable-sort! SEQUENCE LESS?
Similar to `sort!' but stable.
Uses temporary storage when sorting vectors.

*** New functions: sort-list, sort-list!
Added for compatibility with scsh.

** New built-in random number support

*** New function: random N [STATE]
Accepts a positive integer or real N and returns a number of the
same type between zero (inclusive) and N (exclusive).  The values
returned have a uniform distribution.

The optional argument STATE must be of the type produced by
`copy-random-state' or `seed->random-state'.  It defaults to the value
of the variable `*random-state*'.  This object is used to maintain the
state of the pseudo-random-number generator and is altered as a side
effect of the `random' operation.

*** New variable: *random-state*
Holds a data structure that encodes the internal state of the
random-number generator that `random' uses by default.  The nature
of this data structure is implementation-dependent.  It may be
printed out and successfully read back in, but may or may not
function correctly as a random-number state object in another
implementation.

*** New function: copy-random-state [STATE]
Returns a new object of type suitable for use as the value of the
variable `*random-state*' and as a second argument to `random'.
If argument STATE is given, a copy of it is returned.  Otherwise a
copy of `*random-state*' is returned.

*** New function: seed->random-state SEED
Returns a new object of type suitable for use as the value of the
variable `*random-state*' and as a second argument to `random'.
SEED is a string or a number.  A new state is generated and
initialized using SEED.

*** New function: random:uniform [STATE]
Returns an uniformly distributed inexact real random number in the
range between 0 and 1.

*** New procedure: random:solid-sphere! VECT [STATE]
Fills VECT with inexact real random numbers the sum of whose
squares is less than 1.0.  Thinking of VECT as coordinates in
space of dimension N = `(vector-length VECT)', the coordinates are
uniformly distributed within the unit N-shere.  The sum of the
squares of the numbers is returned.  VECT can be either a vector
or a uniform vector of doubles.

*** New procedure: random:hollow-sphere! VECT [STATE]
Fills VECT with inexact real random numbers the sum of whose squares
is equal to 1.0.  Thinking of VECT as coordinates in space of
dimension n = `(vector-length VECT)', the coordinates are uniformly
distributed over the surface of the unit n-shere.  VECT can be either
a vector or a uniform vector of doubles.

*** New function: random:normal [STATE]
Returns an inexact real in a normal distribution with mean 0 and
standard deviation 1.  For a normal distribution with mean M and
standard deviation D use `(+ M (* D (random:normal)))'.

*** New procedure: random:normal-vector! VECT [STATE]
Fills VECT with inexact real random numbers which are independent and
standard normally distributed (i.e., with mean 0 and variance 1).
VECT can be either a vector or a uniform vector of doubles.

*** New function: random:exp STATE
Returns an inexact real in an exponential distribution with mean 1.
For an exponential distribution with mean U use (* U (random:exp)).

** The range of logand, logior, logxor, logtest, and logbit? have changed.

These functions now operate on numbers in the range of a C unsigned
long.

These functions used to operate on numbers in the range of a C signed
long; however, this seems inappropriate, because Guile integers don't
overflow.

** New function: make-guardian
This is an implementation of guardians as described in
R. Kent Dybvig, Carl Bruggeman, and David Eby (1993) "Guardians in a
Generation-Based Garbage Collector" ACM SIGPLAN Conference on
Programming Language Design and Implementation, June 1993
ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/guardians.ps.gz

** New functions: delq1!, delv1!, delete1!
These procedures behave similar to delq! and friends but delete only
one object if at all.

** New function: unread-string STRING PORT
Unread STRING to PORT, that is, push it back onto the port so that
next read operation will work on the pushed back characters.

** unread-char can now be called multiple times
If unread-char is called multiple times, the unread characters will be
read again in last-in first-out order.

** the procedures uniform-array-read! and uniform-array-write! now
work on any kind of port, not just ports which are open on a file.

** Now 'l' in a port mode requests line buffering.

** The procedure truncate-file now works on string ports as well
as file ports.  If the size argument is omitted, the current
file position is used.

** new procedure: seek PORT/FDES OFFSET WHENCE
The arguments are the same as for the old fseek procedure, but it
works on string ports as well as random-access file ports.

** the fseek procedure now works on string ports, since it has been
redefined using seek.

** the setvbuf procedure now uses a default size if mode is _IOFBF and
size is not supplied.

** the newline procedure no longer flushes the port if it's not
line-buffered: previously it did if it was the current output port.

** open-pipe and close-pipe are no longer primitive procedures, but
an emulation can be obtained using `(use-modules (ice-9 popen))'.

** the freopen procedure has been removed.

** new procedure: drain-input PORT
Drains PORT's read buffers (including any pushed-back characters)
and returns the contents as a single string.

** New function: map-in-order PROC LIST1 LIST2 ...
Version of `map' which guarantees that the procedure is applied to the
lists in serial order.

** Renamed `serial-array-copy!' and `serial-array-map!' to
`array-copy-in-order!' and `array-map-in-order!'.  The old names are
now obsolete and will go away in release 1.5.

** New syntax: collect BODY1 ...
Version of `begin' which returns a list of the results of the body
forms instead of the result of the last body form.  In contrast to
`begin', `collect' allows an empty body.

** New functions: read-history FILENAME, write-history FILENAME
Read/write command line history from/to file.  Returns #t on success
and #f if an error occured.

** `ls' and `lls' in module (ice-9 ls) now handle no arguments.

These procedures return a list of definitions available in the specified
argument, a relative module reference.  In the case of no argument,
`(current-module)' is now consulted for definitions to return, instead
of simply returning #f, the former behavior.

** The #/ syntax for lists is no longer supported.

Earlier versions of Scheme accepted this syntax, but printed a
warning.

** Guile no longer consults the SCHEME_LOAD_PATH environment variable.

Instead, you should set GUILE_LOAD_PATH to tell Guile where to find
modules.

* Changes to the gh_ interface

** gh_scm2doubles

Now takes a second argument which is the result array.  If this
pointer is NULL, a new array is malloced (the old behaviour).

** gh_chars2byvect, gh_shorts2svect, gh_floats2fvect, gh_scm2chars,
   gh_scm2shorts, gh_scm2longs, gh_scm2floats

New functions.

* Changes to the scm_ interface

** Function: scm_make_named_hook (char* name, int n_args)

Creates a hook in the same way as make-hook above but also
binds a variable named NAME to it.

This is the typical way of creating a hook from C code.

Currently, the variable is created in the "current" module.  This
might change when we get the new module system.

** The smob interface

The interface for creating smobs has changed.  For documentation, see
data-rep.info (made from guile-core/doc/data-rep.texi).

*** Deprecated function: SCM scm_newsmob (scm_smobfuns *)

>>> This function will be removed in 1.3.4. <<<

It is replaced by:

*** Function: SCM scm_make_smob_type (const char *name, scm_sizet size)
This function adds a new smob type, named NAME, with instance size
SIZE to the system.  The return value is a tag that is used in
creating instances of the type.  If SIZE is 0, then no memory will
be allocated when instances of the smob are created, and nothing
will be freed by the default free function.

*** Function: void scm_set_smob_mark (long tc, SCM (*mark) (SCM))
This function sets the smob marking procedure for the smob type
specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Function: void scm_set_smob_free (long tc, SCM (*mark) (SCM))
This function sets the smob freeing procedure for the smob type
specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Function: void scm_set_smob_print (tc, print)

 - Function: void scm_set_smob_print (long tc,
			              scm_sizet (*print) (SCM,
						          SCM,
							  scm_print_state *))

This function sets the smob printing procedure for the smob type
specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Function: void scm_set_smob_equalp (long tc, SCM (*equalp) (SCM, SCM))
This function sets the smob equality-testing predicate for the
smob type specified by the tag TC. TC is the tag returned by
`scm_make_smob_type'.

*** Macro: void SCM_NEWSMOB (SCM var, long tc, void *data)
Make VALUE contain a smob instance of the type with type code TC and
smob data DATA.  VALUE must be previously declared as C type `SCM'.

*** Macro: fn_returns SCM_RETURN_NEWSMOB (long tc, void *data)
This macro expands to a block of code that creates a smob instance
of the type with type code TC and smob data DATA, and returns that
`SCM' value.  It should be the last piece of code in a block.

** The interfaces for using I/O ports and implementing port types
(ptobs) have changed significantly.  The new interface is based on
shared access to buffers and a new set of ptob procedures.

*** scm_newptob has been removed

It is replaced by:

*** Function: SCM scm_make_port_type (type_name, fill_buffer, write_flush)

- Function: SCM scm_make_port_type (char *type_name,
                                    int (*fill_buffer) (SCM port),
                                    void (*write_flush) (SCM port));

Similarly to the new smob interface, there is a set of function
setters by which the user can customize the behaviour of his port
type.  See ports.h (scm_set_port_XXX).

** scm_strport_to_string: New function: creates a new string from
a string port's buffer.

** Plug in interface for random number generators
The variable `scm_the_rng' in random.c contains a value and three
function pointers which together define the current random number
generator being used by the Scheme level interface and the random
number library functions.

The user is free to replace the default generator with the generator
of his own choice.

*** Variable: size_t scm_the_rng.rstate_size
The size of the random state type used by the current RNG
measured in chars.

*** Function: unsigned long scm_the_rng.random_bits (scm_rstate *STATE)
Given the random STATE, return 32 random bits.

*** Function: void scm_the_rng.init_rstate (scm_rstate *STATE, chars *S, int N)
Seed random state STATE using string S of length N.

*** Function: scm_rstate *scm_the_rng.copy_rstate (scm_rstate *STATE)
Given random state STATE, return a malloced copy.

** Default RNG
The default RNG is the MWC (Multiply With Carry) random number
generator described by George Marsaglia at the Department of
Statistics and Supercomputer Computations Research Institute, The
Florida State University (http://stat.fsu.edu/~geo).

It uses 64 bits, has a period of 4578426017172946943 (4.6e18), and
passes all tests in the DIEHARD test suite
(http://stat.fsu.edu/~geo/diehard.html).  The generation of 32 bits
costs one multiply and one add on platforms which either supports long
longs (gcc does this on most systems) or have 64 bit longs.  The cost
is four multiply on other systems but this can be optimized by writing
scm_i_uniform32 in assembler.

These functions are provided through the scm_the_rng interface for use
by libguile and the application.

*** Function: unsigned long scm_i_uniform32 (scm_i_rstate *STATE)
Given the random STATE, return 32 random bits.
Don't use this function directly.  Instead go through the plugin
interface (see "Plug in interface" above).

*** Function: void scm_i_init_rstate (scm_i_rstate *STATE, char *SEED, int N)
Initialize STATE using SEED of length N.

*** Function: scm_i_rstate *scm_i_copy_rstate (scm_i_rstate *STATE)
Return a malloc:ed copy of STATE.  This function can easily be re-used
in the interfaces to other RNGs.

** Random number library functions
These functions use the current RNG through the scm_the_rng interface.
It might be a good idea to use these functions from your C code so
that only one random generator is used by all code in your program.

The default random state is stored in:

*** Variable: SCM scm_var_random_state
Contains the vcell of the Scheme variable "*random-state*" which is
used as default state by all random number functions in the Scheme
level interface.

Example:

  double x = scm_c_uniform01 (SCM_RSTATE (SCM_CDR (scm_var_random_state)));

*** Function: scm_rstate *scm_c_default_rstate (void)
This is a convenience function which returns the value of
scm_var_random_state.  An error message is generated if this value
isn't a random state.

*** Function: scm_rstate *scm_c_make_rstate (char *SEED, int LENGTH)
Make a new random state from the string SEED of length LENGTH.

It is generally not a good idea to use multiple random states in a
program.  While subsequent random numbers generated from one random
state are guaranteed to be reasonably independent, there is no such
guarantee for numbers generated from different random states.

*** Macro: unsigned long scm_c_uniform32 (scm_rstate *STATE)
Return 32 random bits.

*** Function: double scm_c_uniform01 (scm_rstate *STATE)
Return a sample from the uniform(0,1) distribution.

*** Function: double scm_c_normal01 (scm_rstate *STATE)
Return a sample from the normal(0,1) distribution.

*** Function: double scm_c_exp1 (scm_rstate *STATE)
Return a sample from the exp(1) distribution.

*** Function: unsigned long scm_c_random (scm_rstate *STATE, unsigned long M)
Return a sample from the discrete uniform(0,M) distribution.

*** Function: SCM scm_c_random_bignum (scm_rstate *STATE, SCM M)
Return a sample from the discrete uniform(0,M) distribution.
M must be a bignum object.  The returned value may be an INUM.



Changes in Guile 1.3 (released Monday, October 19, 1998):

* Changes to the distribution

** We renamed the SCHEME_LOAD_PATH environment variable to GUILE_LOAD_PATH.
To avoid conflicts, programs should name environment variables after
themselves, except when there's a common practice establishing some
other convention.

For now, Guile supports both GUILE_LOAD_PATH and SCHEME_LOAD_PATH,
giving the former precedence, and printing a warning message if the
latter is set.  Guile 1.4 will not recognize SCHEME_LOAD_PATH at all.

** The header files related to multi-byte characters have been removed.
They were: libguile/extchrs.h and libguile/mbstrings.h.  Any C code
which referred to these explicitly will probably need to be rewritten,
since the support for the variant string types has been removed; see
below.

** The header files append.h and sequences.h have been removed.  These
files implemented non-R4RS operations which would encourage
non-portable programming style and less easy-to-read code.

* Changes to the stand-alone interpreter

** New procedures have been added to implement a "batch mode":

*** Function: batch-mode?

    Returns a boolean indicating whether the interpreter is in batch
    mode.

*** Function: set-batch-mode?! ARG

    If ARG is true, switches the interpreter to batch mode.  The `#f'
    case has not been implemented.

** Guile now provides full command-line editing, when run interactively.
To use this feature, you must have the readline library installed.
The Guile build process will notice it, and automatically include
support for it.

The readline library is available via anonymous FTP from any GNU
mirror site; the canonical location is "ftp://prep.ai.mit.edu/pub/gnu".

** the-last-stack is now a fluid.

* Changes to the procedure for linking libguile with your programs

** You can now use the `guile-config' utility to build programs that use Guile.

Guile now includes a command-line utility called `guile-config', which
can provide information about how to compile and link programs that
use Guile.

*** `guile-config compile' prints any C compiler flags needed to use Guile.
You should include this command's output on the command line you use
to compile C or C++ code that #includes the Guile header files.  It's
usually just a `-I' flag to help the compiler find the Guile headers.


*** `guile-config link' prints any linker flags necessary to link with Guile.

This command writes to its standard output a list of flags which you
must pass to the linker to link your code against the Guile library.
The flags include '-lguile' itself, any other libraries the Guile
library depends upon, and any `-L' flags needed to help the linker
find those libraries.

For example, here is a Makefile rule that builds a program named 'foo'
from the object files ${FOO_OBJECTS}, and links them against Guile:

  foo: ${FOO_OBJECTS}
	  ${CC} ${CFLAGS} ${FOO_OBJECTS} `guile-config link` -o foo

Previous Guile releases recommended that you use autoconf to detect
which of a predefined set of libraries were present on your system.
It is more robust to use `guile-config', since it records exactly which
libraries the installed Guile library requires.

This was originally called `build-guile', but was renamed to
`guile-config' before Guile 1.3 was released, to be consistent with
the analogous script for the GTK+ GUI toolkit, which is called
`gtk-config'.


** Use the GUILE_FLAGS macro in your configure.in file to find Guile.

If you are using the GNU autoconf package to configure your program,
you can use the GUILE_FLAGS autoconf macro to call `guile-config'
(described above) and gather the necessary values for use in your
Makefiles.

The GUILE_FLAGS macro expands to configure script code which runs the
`guile-config' script, to find out where Guile's header files and
libraries are installed.  It sets two variables, marked for
substitution, as by AC_SUBST.

  GUILE_CFLAGS --- flags to pass to a C or C++ compiler to build
    code that uses Guile header files.  This is almost always just a
    -I flag.

  GUILE_LDFLAGS --- flags to pass to the linker to link a
    program against Guile.  This includes `-lguile' for the Guile
    library itself, any libraries that Guile itself requires (like
    -lqthreads), and so on.  It may also include a -L flag to tell the
    compiler where to find the libraries.

GUILE_FLAGS is defined in the file guile.m4, in the top-level
directory of the Guile distribution.  You can copy it into your
package's aclocal.m4 file, and then use it in your configure.in file.

If you are using the `aclocal' program, distributed with GNU automake,
to maintain your aclocal.m4 file, the Guile installation process
installs guile.m4 where aclocal will find it.  All you need to do is
use GUILE_FLAGS in your configure.in file, and then run `aclocal';
this will copy the definition of GUILE_FLAGS into your aclocal.m4
file.


* Changes to Scheme functions and syntax

** Multi-byte strings have been removed, as have multi-byte and wide
ports.  We felt that these were the wrong approach to
internationalization support.

** New function: readline [PROMPT]
Read a line from the terminal, and allow the user to edit it,
prompting with PROMPT.  READLINE provides a large set of Emacs-like
editing commands, lets the user recall previously typed lines, and
works on almost every kind of terminal, including dumb terminals.

READLINE assumes that the cursor is at the beginning of the line when
it is invoked.  Thus, you can't print a prompt yourself, and then call
READLINE; you need to package up your prompt as a string, pass it to
the function, and let READLINE print the prompt itself.  This is
because READLINE needs to know the prompt's screen width.

For Guile to provide this function, you must have the readline
library, version 2.1 or later, installed on your system.  Readline is
available via anonymous FTP from prep.ai.mit.edu in pub/gnu, or from
any GNU mirror site.

See also ADD-HISTORY function.

** New function: add-history STRING
Add STRING as the most recent line in the history used by the READLINE
command.  READLINE does not add lines to the history itself; you must
call ADD-HISTORY to make previous input available to the user.

** The behavior of the read-line function has changed.

This function now uses standard C library functions to read the line,
for speed.  This means that it doesn not respect the value of
scm-line-incrementors; it assumes that lines are delimited with
#\newline.

(Note that this is read-line, the function that reads a line of text
from a port, not readline, the function that reads a line from a
terminal, providing full editing capabilities.)

** New module (ice-9 getopt-gnu-style): Parse command-line arguments.

This module provides some simple argument parsing.  It exports one
function:

Function: getopt-gnu-style ARG-LS
    Parse a list of program arguments into an alist of option
    descriptions.

    Each item in the list of program arguments is examined to see if
    it meets the syntax of a GNU long-named option.  An argument like
    `--MUMBLE' produces an element of the form (MUMBLE . #t) in the
    returned alist, where MUMBLE is a keyword object with the same
    name as the argument.  An argument like `--MUMBLE=FROB' produces
    an element of the form (MUMBLE . FROB), where FROB is a string.

    As a special case, the returned alist also contains a pair whose
    car is the symbol `rest'.  The cdr of this pair is a list
    containing all the items in the argument list that are not options
    of the form mentioned above.

    The argument `--' is treated specially: all items in the argument
    list appearing after such an argument are not examined, and are
    returned in the special `rest' list.

    This function does not parse normal single-character switches.
    You will need to parse them out of the `rest' list yourself.

** The read syntax for byte vectors and short vectors has changed.

Instead of #bytes(...), write #y(...).

Instead of #short(...), write #h(...).

This may seem nutty, but, like the other uniform vectors, byte vectors
and short vectors want to have the same print and read syntax (and,
more basic, want to have read syntax!).  Changing the read syntax to
use multiple characters after the hash sign breaks with the
conventions used in R5RS and the conventions used for the other
uniform vectors.  It also introduces complexity in the current reader,
both on the C and Scheme levels.  (The Right solution is probably to
change the syntax and prototypes for uniform vectors entirely.)


** The new module (ice-9 session) provides useful interactive functions.

*** New procedure: (apropos REGEXP OPTION ...)

Display a list of top-level variables whose names match REGEXP, and
the modules they are imported from.  Each OPTION should be one of the
following symbols:

  value  --- Show the value of each matching variable.
  shadow --- Show bindings shadowed by subsequently imported modules.
  full   --- Same as both `shadow' and `value'.

For example:

    guile> (apropos "trace" 'full)
    debug: trace    #<procedure trace args>
    debug: untrace  #<procedure untrace args>
    the-scm-module: display-backtrace       #<compiled-closure #<primitive-procedure gsubr-apply>>
    the-scm-module: before-backtrace-hook   ()
    the-scm-module: backtrace       #<primitive-procedure backtrace>
    the-scm-module: after-backtrace-hook    ()
    the-scm-module: has-shown-backtrace-hint?       #f
    guile>

** There are new functions and syntax for working with macros.

Guile implements macros as a special object type.  Any variable whose
top-level binding is a macro object acts as a macro.  The macro object
specifies how the expression should be transformed before evaluation.

*** Macro objects now print in a reasonable way, resembling procedures.

*** New function: (macro? OBJ)
True iff OBJ is a macro object.

*** New function: (primitive-macro? OBJ)
Like (macro? OBJ), but true only if OBJ is one of the Guile primitive
macro transformers, implemented in eval.c rather than Scheme code.

Why do we have this function?
- For symmetry with procedure? and primitive-procedure?,
- to allow custom print procedures to tell whether a macro is
  primitive, and display it differently, and
- to allow compilers and user-written evaluators to distinguish
  builtin special forms from user-defined ones, which could be
  compiled.

*** New function: (macro-type OBJ)
Return a value indicating what kind of macro OBJ is.  Possible return
values are:

    The symbol `syntax' --- a macro created by procedure->syntax.
    The symbol `macro' --- a macro created by procedure->macro.
    The symbol `macro!' --- a macro created by procedure->memoizing-macro.
    The boolean #f --- if OBJ is not a macro object.

*** New function: (macro-name MACRO)
Return the name of the macro object MACRO's procedure, as returned by
procedure-name.

*** New function: (macro-transformer MACRO)
Return the transformer procedure for MACRO.

*** New syntax: (use-syntax MODULE ... TRANSFORMER)

Specify a new macro expander to use in the current module.  Each
MODULE is a module name, with the same meaning as in the `use-modules'
form; each named module's exported bindings are added to the current
top-level environment.  TRANSFORMER is an expression evaluated in the
resulting environment which must yield a procedure to use as the
module's eval transformer: every expression evaluated in this module
is passed to this function, and the result passed to the Guile
interpreter.

*** macro-eval! is removed.  Use local-eval instead.

** Some magic has been added to the printer to better handle user
written printing routines (like record printers, closure printers).

The problem is that these user written routines must have access to
the current `print-state' to be able to handle fancy things like
detection of circular references.  These print-states have to be
passed to the builtin printing routines (display, write, etc) to
properly continue the print chain.

We didn't want to change all existing print code so that it
explicitly passes thru a print state in addition to a port.  Instead,
we extented the possible values that the builtin printing routines
accept as a `port'.  In addition to a normal port, they now also take
a pair of a normal port and a print-state.  Printing will go to the
port and the print-state will be used to control the detection of
circular references, etc.  If the builtin function does not care for a
print-state, it is simply ignored.

User written callbacks are now called with such a pair as their
`port', but because every function now accepts this pair as a PORT
argument, you don't have to worry about that.  In fact, it is probably
safest to not check for these pairs.

However, it is sometimes necessary to continue a print chain on a
different port, for example to get a intermediate string
representation of the printed value, mangle that string somehow, and
then to finally print the mangled string.  Use the new function

    inherit-print-state OLD-PORT NEW-PORT

for this.  It constructs a new `port' that prints to NEW-PORT but
inherits the print-state of OLD-PORT.

** struct-vtable-offset renamed to vtable-offset-user

** New constants: vtable-index-layout, vtable-index-vtable, vtable-index-printer

** There is now a third optional argument to make-vtable-vtable
   (and fourth to make-struct) when constructing new types (vtables).
   This argument initializes field vtable-index-printer of the vtable.

** The detection of circular references has been extended to structs.
That is, a structure that -- in the process of being printed -- prints
itself does not lead to infinite recursion.

** There is now some basic support for fluids.  Please read
"libguile/fluid.h" to find out more. It is accessible from Scheme with
the following functions and macros:

Function: make-fluid

    Create a new fluid object.  Fluids are not special variables or
    some other extension to the semantics of Scheme, but rather
    ordinary Scheme objects.  You can store them into variables (that
    are still lexically scoped, of course) or into any other place you
    like.  Every fluid has a initial value of `#f'.

Function: fluid? OBJ

    Test whether OBJ is a fluid.

Function: fluid-ref FLUID
Function: fluid-set! FLUID VAL

    Access/modify the fluid FLUID.  Modifications are only visible
    within the current dynamic root (that includes threads).

Function: with-fluids* FLUIDS VALUES THUNK

    FLUIDS is a list of fluids and VALUES a corresponding list of
    values for these fluids.  Before THUNK gets called the values are
    installed in the fluids and the old values of the fluids are
    saved in the VALUES list.  When the flow of control leaves THUNK
    or reenters it, the values get swapped again.  You might think of
    this as a `safe-fluid-excursion'.  Note that the VALUES list is
    modified by `with-fluids*'.

Macro: with-fluids ((FLUID VALUE) ...) FORM ...

    The same as `with-fluids*' but with a different syntax.  It looks
    just like `let', but both FLUID and VALUE are evaluated.  Remember,
    fluids are not special variables but ordinary objects.  FLUID
    should evaluate to a fluid.

** Changes to system call interfaces:

*** close-port, close-input-port and close-output-port now return a
boolean instead of an `unspecified' object.  #t means that the port
was successfully closed, while #f means it was already closed.  It is
also now possible for these procedures to raise an exception if an
error occurs (some errors from write can be delayed until close.)

*** the first argument to chmod, fcntl, ftell and fseek can now be a
file descriptor.

*** the third argument to fcntl is now optional.

*** the first argument to chown can now be a file descriptor or a port.

*** the argument to stat can now be a port.

*** The following new procedures have been added (most use scsh
interfaces):

*** procedure: close PORT/FD
     Similar to close-port (*note close-port: Closing Ports.), but also
     works on file descriptors.  A side effect of closing a file
     descriptor is that any ports using that file descriptor are moved
     to a different file descriptor and have their revealed counts set
     to zero.

*** procedure: port->fdes PORT
     Returns the integer file descriptor underlying PORT.  As a side
     effect the revealed count of PORT is incremented.

*** procedure: fdes->ports FDES
     Returns a list of existing ports which have FDES as an underlying
     file descriptor, without changing their revealed counts.

*** procedure: fdes->inport FDES
     Returns an existing input port which has FDES as its underlying
     file descriptor, if one exists, and increments its revealed count.
     Otherwise, returns a new input port with a revealed count of 1.

*** procedure: fdes->outport FDES
     Returns an existing output port which has FDES as its underlying
     file descriptor, if one exists, and increments its revealed count.
     Otherwise, returns a new output port with a revealed count of 1.

   The next group of procedures perform a `dup2' system call, if NEWFD
(an integer) is supplied, otherwise a `dup'.  The file descriptor to be
duplicated can be supplied as an integer or contained in a port.  The
type of value returned varies depending on which procedure is used.

   All procedures also have the side effect when performing `dup2' that
any ports using NEWFD are moved to a different file descriptor and have
their revealed counts set to zero.

*** procedure: dup->fdes PORT/FD [NEWFD]
     Returns an integer file descriptor.

*** procedure: dup->inport PORT/FD [NEWFD]
     Returns a new input port using the new file descriptor.

*** procedure: dup->outport PORT/FD [NEWFD]
     Returns a new output port using the new file descriptor.

*** procedure: dup PORT/FD [NEWFD]
     Returns a new port if PORT/FD is a port, with the same mode as the
     supplied port, otherwise returns an integer file descriptor.

*** procedure: dup->port PORT/FD MODE [NEWFD]
     Returns a new port using the new file descriptor.  MODE supplies a
     mode string for the port (*note open-file: File Ports.).

*** procedure: setenv NAME VALUE
     Modifies the environment of the current process, which is also the
     default environment inherited by child processes.

     If VALUE is `#f', then NAME is removed from the environment.
     Otherwise, the string NAME=VALUE is added to the environment,
     replacing any existing string with name matching NAME.

     The return value is unspecified.

*** procedure: truncate-file OBJ SIZE
     Truncates the file referred to by OBJ to at most SIZE bytes.  OBJ
     can be a string containing a file name or an integer file
     descriptor or port open for output on the file.  The underlying
     system calls are `truncate' and `ftruncate'.

     The return value is unspecified.

*** procedure: setvbuf PORT MODE [SIZE]
     Set the buffering mode for PORT.  MODE can be:
    `_IONBF'
          non-buffered

    `_IOLBF'
          line buffered

    `_IOFBF'
          block buffered, using a newly allocated buffer of SIZE bytes.
          However if SIZE is zero or unspecified, the port will be made
          non-buffered.

     This procedure should not be used after I/O has been performed with
     the port.

     Ports are usually block buffered by default, with a default buffer
     size.  Procedures e.g., *Note open-file: File Ports, which accept a
     mode string allow `0' to be added to request an unbuffered port.

*** procedure: fsync PORT/FD
     Copies any unwritten data for the specified output file descriptor
     to disk.  If PORT/FD is a port, its buffer is flushed before the
     underlying file descriptor is fsync'd.  The return value is
     unspecified.

*** procedure: open-fdes PATH FLAGS [MODES]
     Similar to `open' but returns a file descriptor instead of a port.

*** procedure: execle PATH ENV [ARG] ...
     Similar to `execl', but the environment of the new process is
     specified by ENV, which must be a list of strings as returned by
     the `environ' procedure.

     This procedure is currently implemented using the `execve' system
     call, but we call it `execle' because of its Scheme calling
     interface.

*** procedure: strerror ERRNO
     Returns the Unix error message corresponding to ERRNO, an integer.

*** procedure: primitive-exit [STATUS]
     Terminate the current process without unwinding the Scheme stack.
     This is would typically be useful after a fork.  The exit status
     is STATUS if supplied, otherwise zero.

*** procedure: times
     Returns an object with information about real and processor time.
     The following procedures accept such an object as an argument and
     return a selected component:

    `tms:clock'
          The current real time, expressed as time units relative to an
          arbitrary base.

    `tms:utime'
          The CPU time units used by the calling process.

    `tms:stime'
          The CPU time units used by the system on behalf of the
          calling process.

    `tms:cutime'
          The CPU time units used by terminated child processes of the
          calling process, whose status has been collected (e.g., using
          `waitpid').

    `tms:cstime'
          Similarly, the CPU times units used by the system on behalf of
          terminated child processes.

** Removed: list-length
** Removed: list-append, list-append!
** Removed: list-reverse, list-reverse!

** array-map renamed to array-map!

** serial-array-map renamed to serial-array-map!

** catch doesn't take #f as first argument any longer

Previously, it was possible to pass #f instead of a key to `catch'.
That would cause `catch' to pass a jump buffer object to the procedure
passed as second argument.  The procedure could then use this jump
buffer objekt as an argument to throw.

This mechanism has been removed since its utility doesn't motivate the
extra complexity it introduces.

** The `#/' notation for lists now provokes a warning message from Guile.
This syntax will be removed from Guile in the near future.

To disable the warning message, set the GUILE_HUSH environment
variable to any non-empty value.

** The newline character now prints as `#\newline', following the
normal Scheme notation, not `#\nl'.

* Changes to the gh_ interface

** The gh_enter function now takes care of loading the Guile startup files.
gh_enter works by calling scm_boot_guile; see the remarks below.

** Function: void gh_write (SCM x)

Write the printed representation of the scheme object x to the current
output port.  Corresponds to the scheme level `write'.

** gh_list_length renamed to gh_length.

** vector handling routines

Several major changes.  In particular, gh_vector() now resembles
(vector ...) (with a caveat -- see manual), and gh_make_vector() now
exists and behaves like (make-vector ...).  gh_vset() and gh_vref()
have been renamed gh_vector_set_x() and gh_vector_ref().  Some missing
vector-related gh_ functions have been implemented.

** pair and list routines

Implemented several of the R4RS pair and list functions that were
missing.

** gh_scm2doubles, gh_doubles2scm, gh_doubles2dvect

New function.  Converts double arrays back and forth between Scheme
and C.

* Changes to the scm_ interface

** The function scm_boot_guile now takes care of loading the startup files.

Guile's primary initialization function, scm_boot_guile, now takes
care of loading `boot-9.scm', in the `ice-9' module, to initialize
Guile, define the module system, and put together some standard
bindings.  It also loads `init.scm', which is intended to hold
site-specific initialization code.

Since Guile cannot operate properly until boot-9.scm is loaded, there
is no reason to separate loading boot-9.scm from Guile's other
initialization processes.

This job used to be done by scm_compile_shell_switches, which didn't
make much sense; in particular, it meant that people using Guile for
non-shell-like applications had to jump through hoops to get Guile
initialized properly.

** The function scm_compile_shell_switches no longer loads the startup files.
Now, Guile always loads the startup files, whenever it is initialized;
see the notes above for scm_boot_guile and scm_load_startup_files.

** Function: scm_load_startup_files
This new function takes care of loading Guile's initialization file
(`boot-9.scm'), and the site initialization file, `init.scm'.  Since
this is always called by the Guile initialization process, it's
probably not too useful to call this yourself, but it's there anyway.

** The semantics of smob marking have changed slightly.

The smob marking function (the `mark' member of the scm_smobfuns
structure) is no longer responsible for setting the mark bit on the
smob.  The generic smob handling code in the garbage collector will
set this bit.  The mark function need only ensure that any other
objects the smob refers to get marked.

Note that this change means that the smob's GC8MARK bit is typically
already set upon entry to the mark function.  Thus, marking functions
which look like this:

	{
	  if (SCM_GC8MARKP (ptr))
	    return SCM_BOOL_F;
          SCM_SETGC8MARK (ptr);
	  ... mark objects to which the smob refers ...
	}

are now incorrect, since they will return early, and fail to mark any
other objects the smob refers to.  Some code in the Guile library used
to work this way.

** The semantics of the I/O port functions in scm_ptobfuns have changed.

If you have implemented your own I/O port type, by writing the
functions required by the scm_ptobfuns and then calling scm_newptob,
you will need to change your functions slightly.

The functions in a scm_ptobfuns structure now expect the port itself
as their argument; they used to expect the `stream' member of the
port's scm_port_table structure.  This allows functions in an
scm_ptobfuns structure to easily access the port's cell (and any flags
it its CAR), and the port's scm_port_table structure.

Guile now passes the I/O port itself as the `port' argument in the
following scm_ptobfuns functions:

  int (*free) (SCM port);
  int (*fputc) (int, SCM port);
  int (*fputs) (char *, SCM port);
  scm_sizet (*fwrite) SCM_P ((char *ptr,
			      scm_sizet size,
			      scm_sizet nitems,
			      SCM port));
  int (*fflush) (SCM port);
  int (*fgetc) (SCM port);
  int (*fclose) (SCM port);

The interfaces to the `mark', `print', `equalp', and `fgets' methods
are unchanged.

If you have existing code which defines its own port types, it is easy
to convert your code to the new interface; simply apply SCM_STREAM to
the port argument to yield the value you code used to expect.

Note that since both the port and the stream have the same type in the
C code --- they are both SCM values --- the C compiler will not remind
you if you forget to update your scm_ptobfuns functions.


** Function: int scm_internal_select (int fds,
				      SELECT_TYPE *rfds,
				      SELECT_TYPE *wfds,
				      SELECT_TYPE *efds,
				      struct timeval *timeout);

This is a replacement for the `select' function provided by the OS.
It enables I/O blocking and sleeping to happen for one cooperative
thread without blocking other threads.  It also avoids busy-loops in
these situations.  It is intended that all I/O blocking and sleeping
will finally go through this function.  Currently, this function is
only available on systems providing `gettimeofday' and `select'.

** Function: SCM scm_internal_stack_catch (SCM tag,
					   scm_catch_body_t body,
					   void *body_data,
					   scm_catch_handler_t handler,
					   void *handler_data)

A new sibling to the other two C level `catch' functions
scm_internal_catch and scm_internal_lazy_catch.  Use it if you want
the stack to be saved automatically into the variable `the-last-stack'
(scm_the_last_stack_var) on error.  This is necessary if you want to
use advanced error reporting, such as calling scm_display_error and
scm_display_backtrace.  (They both take a stack object as argument.)

** Function: SCM scm_spawn_thread (scm_catch_body_t body,
				   void *body_data,
				   scm_catch_handler_t handler,
				   void *handler_data)

Spawns a new thread.  It does a job similar to
scm_call_with_new_thread but takes arguments more suitable when
spawning threads from application C code.

** The hook scm_error_callback has been removed.  It was originally
intended as a way for the user to install his own error handler.  But
that method works badly since it intervenes between throw and catch,
thereby changing the semantics of expressions like (catch #t ...).
The correct way to do it is to use one of the C level catch functions
in throw.c: scm_internal_catch/lazy_catch/stack_catch.

** Removed functions:

scm_obj_length, scm_list_length, scm_list_append, scm_list_append_x,
scm_list_reverse, scm_list_reverse_x

** New macros: SCM_LISTn where n is one of the integers 0-9.

These can be used for pretty list creation from C.  The idea is taken
from Erick Gallesio's STk.

** scm_array_map renamed to scm_array_map_x

** mbstrings are now removed

This means that the type codes scm_tc7_mb_string and
scm_tc7_mb_substring has been removed.

** scm_gen_putc, scm_gen_puts, scm_gen_write, and scm_gen_getc have changed.

Since we no longer support multi-byte strings, these I/O functions
have been simplified, and renamed.  Here are their old names, and
their new names and arguments:

scm_gen_putc   ->   void scm_putc (int c, SCM port);
scm_gen_puts   ->   void scm_puts (char *s, SCM port);
scm_gen_write  ->   void scm_lfwrite (char *ptr, scm_sizet size, SCM port);
scm_gen_getc   ->   void scm_getc (SCM port);


** The macros SCM_TYP7D and SCM_TYP7SD has been removed.

** The macro SCM_TYP7S has taken the role of the old SCM_TYP7D

SCM_TYP7S now masks away the bit which distinguishes substrings from
strings.

** scm_catch_body_t: Backward incompatible change!

Body functions to scm_internal_catch and friends do not any longer
take a second argument.  This is because it is no longer possible to
pass a #f arg to catch.

** Calls to scm_protect_object and scm_unprotect now nest properly.

The function scm_protect_object protects its argument from being freed
by the garbage collector.  scm_unprotect_object removes that
protection.

These functions now nest properly.  That is, for every object O, there
is a counter which scm_protect_object(O) increments and
scm_unprotect_object(O) decrements, if the counter is greater than
zero.  Every object's counter is zero when it is first created.  If an
object's counter is greater than zero, the garbage collector will not
reclaim its storage.

This allows you to use scm_protect_object in your code without
worrying that some other function you call will call
scm_unprotect_object, and allow it to be freed.  Assuming that the
functions you call are well-behaved, and unprotect only those objects
they protect, you can follow the same rule and have confidence that
objects will be freed only at appropriate times.


Changes in Guile 1.2 (released Tuesday, June 24 1997):

* Changes to the distribution

** Nightly snapshots are now available from ftp.red-bean.com.
The old server, ftp.cyclic.com, has been relinquished to its rightful
owner.

Nightly snapshots of the Guile development sources are now available via
anonymous FTP from ftp.red-bean.com, as /pub/guile/guile-snap.tar.gz.

Via the web, that's:  ftp://ftp.red-bean.com/pub/guile/guile-snap.tar.gz
For getit, that's:    ftp.red-bean.com:/pub/guile/guile-snap.tar.gz

** To run Guile without installing it, the procedure has changed a bit.

If you used a separate build directory to compile Guile, you'll need
to include the build directory in SCHEME_LOAD_PATH, as well as the
source directory.  See the `INSTALL' file for examples.

* Changes to the procedure for linking libguile with your programs

** The standard Guile load path for Scheme code now includes
$(datadir)/guile (usually /usr/local/share/guile).  This means that
you can install your own Scheme files there, and Guile will find them.
(Previous versions of Guile only checked a directory whose name
contained the Guile version number, so you had to re-install or move
your Scheme sources each time you installed a fresh version of Guile.)

The load path also includes $(datadir)/guile/site; we recommend
putting individual Scheme files there.  If you want to install a
package with multiple source files, create a directory for them under
$(datadir)/guile.

** Guile 1.2 will now use the Rx regular expression library, if it is
installed on your system.  When you are linking libguile into your own
programs, this means you will have to link against -lguile, -lqt (if
you configured Guile with thread support), and -lrx.

If you are using autoconf to generate configuration scripts for your
application, the following lines should suffice to add the appropriate
libraries to your link command:

### Find Rx, quickthreads and libguile.
AC_CHECK_LIB(rx, main)
AC_CHECK_LIB(qt, main)
AC_CHECK_LIB(guile, scm_shell)

The Guile 1.2 distribution does not contain sources for the Rx
library, as Guile 1.0 did.  If you want to use Rx, you'll need to
retrieve it from a GNU FTP site and install it separately.

* Changes to Scheme functions and syntax

** The dynamic linking features of Guile are now enabled by default.
You can disable them by giving the `--disable-dynamic-linking' option
to configure.

  (dynamic-link FILENAME)

    Find the object file denoted by FILENAME (a string) and link it
    into the running Guile application.  When everything works out,
    return a Scheme object suitable for representing the linked object
    file.  Otherwise an error is thrown.  How object files are
    searched is system dependent.

  (dynamic-object? VAL)

    Determine whether VAL represents a dynamically linked object file.

  (dynamic-unlink DYNOBJ)

    Unlink the indicated object file from the application.  DYNOBJ
    should be one of the values returned by `dynamic-link'.

  (dynamic-func FUNCTION DYNOBJ)

    Search the C function indicated by FUNCTION (a string or symbol)
    in DYNOBJ and return some Scheme object that can later be used
    with `dynamic-call' to actually call this function.  Right now,
    these Scheme objects are formed by casting the address of the
    function to `long' and converting this number to its Scheme
    representation.

  (dynamic-call FUNCTION DYNOBJ)

    Call the C function indicated by FUNCTION and DYNOBJ.  The
    function is passed no arguments and its return value is ignored.
    When FUNCTION is something returned by `dynamic-func', call that
    function and ignore DYNOBJ.  When FUNCTION is a string (or symbol,
    etc.), look it up in DYNOBJ; this is equivalent to

	(dynamic-call (dynamic-func FUNCTION DYNOBJ) #f)

    Interrupts are deferred while the C function is executing (with
    SCM_DEFER_INTS/SCM_ALLOW_INTS).

  (dynamic-args-call FUNCTION DYNOBJ ARGS)

    Call the C function indicated by FUNCTION and DYNOBJ, but pass it
    some arguments and return its return value.  The C function is
    expected to take two arguments and return an `int', just like
    `main':

	int c_func (int argc, char **argv);

    ARGS must be a list of strings and is converted into an array of
    `char *'.  The array is passed in ARGV and its size in ARGC.  The
    return value is converted to a Scheme number and returned from the
    call to `dynamic-args-call'.

When dynamic linking is disabled or not supported on your system,
the above functions throw errors, but they are still available.

Here is a small example that works on GNU/Linux:

  (define libc-obj (dynamic-link "libc.so"))
  (dynamic-args-call 'rand libc-obj '())

See the file `libguile/DYNAMIC-LINKING' for additional comments.

** The #/ syntax for module names is depreciated, and will be removed
in a future version of Guile.  Instead of

	#/foo/bar/baz

instead write

	(foo bar baz)

The latter syntax is more consistent with existing Lisp practice.

** Guile now does fancier printing of structures.  Structures are the
underlying implementation for records, which in turn are used to
implement modules, so all of these object now print differently and in
a more informative way.

The Scheme printer will examine the builtin variable *struct-printer*
whenever it needs to print a structure object.  When this variable is
not `#f' it is deemed to be a procedure and will be applied to the
structure object and the output port.  When *struct-printer* is `#f'
or the procedure return `#f' the structure object will be printed in
the boring #<struct 80458270> form.

This hook is used by some routines in ice-9/boot-9.scm to implement
type specific printing routines.  Please read the comments there about
"printing structs".

One of the more specific uses of structs are records.  The printing
procedure that could be passed to MAKE-RECORD-TYPE is now actually
called.  It should behave like a *struct-printer* procedure (described
above).

** Guile now supports a new R4RS-compliant syntax for keywords.  A
token of the form #:NAME, where NAME has the same syntax as a Scheme
symbol, is the external representation of the keyword named NAME.
Keyword objects print using this syntax as well, so values containing
keyword objects can be read back into Guile.  When used in an
expression, keywords are self-quoting objects.

Guile suports this read syntax, and uses this print syntax, regardless
of the current setting of the `keyword' read option.  The `keyword'
read option only controls whether Guile recognizes the `:NAME' syntax,
which is incompatible with R4RS.  (R4RS says such token represent
symbols.)

** Guile has regular expression support again.  Guile 1.0 included
functions for matching regular expressions, based on the Rx library.
In Guile 1.1, the Guile/Rx interface was removed to simplify the
distribution, and thus Guile had no regular expression support.  Guile
1.2 again supports the most commonly used functions, and supports all
of SCSH's regular expression functions.

If your system does not include a POSIX regular expression library,
and you have not linked Guile with a third-party regexp library such as
Rx, these functions will not be available.  You can tell whether your
Guile installation includes regular expression support by checking
whether the `*features*' list includes the `regex' symbol.

*** regexp functions

By default, Guile supports POSIX extended regular expressions.  That
means that the characters `(', `)', `+' and `?' are special, and must
be escaped if you wish to match the literal characters.

This regular expression interface was modeled after that implemented
by SCSH, the Scheme Shell.  It is intended to be upwardly compatible
with SCSH regular expressions.

**** Function: string-match PATTERN STR [START]
     Compile the string PATTERN into a regular expression and compare
     it with STR.  The optional numeric argument START specifies the
     position of STR at which to begin matching.

     `string-match' returns a "match structure" which describes what,
     if anything, was matched by the regular expression.  *Note Match
     Structures::.  If STR does not match PATTERN at all,
     `string-match' returns `#f'.

   Each time `string-match' is called, it must compile its PATTERN
argument into a regular expression structure.  This operation is
expensive, which makes `string-match' inefficient if the same regular
expression is used several times (for example, in a loop).  For better
performance, you can compile a regular expression in advance and then
match strings against the compiled regexp.

**** Function: make-regexp STR [FLAGS]
     Compile the regular expression described by STR, and return the
     compiled regexp structure.  If STR does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     FLAGS may be the bitwise-or of one or more of the following:

**** Constant: regexp/extended
     Use POSIX Extended Regular Expression syntax when interpreting
     STR.  If not set, POSIX Basic Regular Expression syntax is used.
     If the FLAGS argument is omitted, we assume regexp/extended.

**** Constant: regexp/icase
     Do not differentiate case.  Subsequent searches using the
     returned regular expression will be case insensitive.

**** Constant: regexp/newline
     Match-any-character operators don't match a newline.

     A non-matching list ([^...]) not containing a newline matches a
     newline.

     Match-beginning-of-line operator (^) matches the empty string
     immediately after a newline, regardless of whether the FLAGS
     passed to regexp-exec contain regexp/notbol.

     Match-end-of-line operator ($) matches the empty string
     immediately before a newline, regardless of whether the FLAGS
     passed to regexp-exec contain regexp/noteol.

**** Function: regexp-exec REGEXP STR [START [FLAGS]]
     Match the compiled regular expression REGEXP against `str'.  If
     the optional integer START argument is provided, begin matching
     from that position in the string.  Return a match structure
     describing the results of the match, or `#f' if no match could be
     found.

     FLAGS may be the bitwise-or of one or more of the following:

**** Constant: regexp/notbol
     The match-beginning-of-line operator always fails to match (but
     see the compilation flag regexp/newline above) This flag may be
     used when different portions of a string are passed to
     regexp-exec and the beginning of the string should not be
     interpreted as the beginning of the line.

**** Constant: regexp/noteol
     The match-end-of-line operator always fails to match (but see the
     compilation flag regexp/newline above)

**** Function: regexp? OBJ
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

   Regular expressions are commonly used to find patterns in one string
and replace them with the contents of another string.

**** Function: regexp-substitute PORT MATCH [ITEM...]
     Write to the output port PORT selected contents of the match
     structure MATCH.  Each ITEM specifies what should be written, and
     may be one of the following arguments:

        * A string.  String arguments are written out verbatim.

        * An integer.  The submatch with that number is written.

        * The symbol `pre'.  The portion of the matched string preceding
          the regexp match is written.

        * The symbol `post'.  The portion of the matched string
          following the regexp match is written.

     PORT may be `#f', in which case nothing is written; instead,
     `regexp-substitute' constructs a string from the specified ITEMs
     and returns that.

**** Function: regexp-substitute/global PORT REGEXP TARGET [ITEM...]
     Similar to `regexp-substitute', but can be used to perform global
     substitutions on STR.  Instead of taking a match structure as an
     argument, `regexp-substitute/global' takes two string arguments: a
     REGEXP string describing a regular expression, and a TARGET string
     which should be matched against this regular expression.

     Each ITEM behaves as in REGEXP-SUBSTITUTE, with the following
     exceptions:

        * A function may be supplied.  When this function is called, it
          will be passed one argument: a match structure for a given
          regular expression match.  It should return a string to be
          written out to PORT.

        * The `post' symbol causes `regexp-substitute/global' to recurse
          on the unmatched portion of STR.  This *must* be supplied in
          order to perform global search-and-replace on STR; if it is
          not present among the ITEMs, then `regexp-substitute/global'
          will return after processing a single match.

*** Match Structures

   A "match structure" is the object returned by `string-match' and
`regexp-exec'.  It describes which portion of a string, if any, matched
the given regular expression.  Match structures include: a reference to
the string that was checked for matches; the starting and ending
positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

   In each of the regexp match functions described below, the `match'
argument must be a match structure returned by a previous call to
`string-match' or `regexp-exec'.  Most of these functions return some
information about the original target string that was matched against a
regular expression; we will call that string TARGET for easy reference.

**** Function: regexp-match? OBJ
     Return `#t' if OBJ is a match structure returned by a previous
     call to `regexp-exec', or `#f' otherwise.

**** Function: match:substring MATCH [N]
     Return the portion of TARGET matched by subexpression number N.
     Submatch 0 (the default) represents the entire regexp match.  If
     the regular expression as a whole matched, but the subexpression
     number N did not match, return `#f'.

**** Function: match:start MATCH [N]
     Return the starting position of submatch number N.

**** Function: match:end MATCH [N]
     Return the ending position of submatch number N.

**** Function: match:prefix MATCH
     Return the unmatched portion of TARGET preceding the regexp match.

**** Function: match:suffix MATCH
     Return the unmatched portion of TARGET following the regexp match.

**** Function: match:count MATCH
     Return the number of parenthesized subexpressions from MATCH.
     Note that the entire regular expression match itself counts as a
     subexpression, and failed submatches are included in the count.

**** Function: match:string MATCH
     Return the original TARGET string.

*** Backslash Escapes

   Sometimes you will want a regexp to match characters like `*' or `$'
exactly.  For example, to check whether a particular string represents
a menu entry from an Info node, it would be useful to match it against
a regexp like `^* [^:]*::'.  However, this won't work; because the
asterisk is a metacharacter, it won't match the `*' at the beginning of
the string.  In this case, we want to make the first asterisk un-magic.

   You can do this by preceding the metacharacter with a backslash
character `\'.  (This is also called "quoting" the metacharacter, and
is known as a "backslash escape".)  When Guile sees a backslash in a
regular expression, it considers the following glyph to be an ordinary
character, no matter what special meaning it would ordinarily have.
Therefore, we can make the above example work by changing the regexp to
`^\* [^:]*::'.  The `\*' sequence tells the regular expression engine
to match only a single asterisk in the target string.

   Since the backslash is itself a metacharacter, you may force a
regexp to match a backslash in the target string by preceding the
backslash with itself.  For example, to find variable references in a
TeX program, you might want to find occurrences of the string `\let\'
followed by any number of alphabetic characters.  The regular expression
`\\let\\[A-Za-z]*' would do this: the double backslashes in the regexp
each match a single backslash in the target string.

**** Function: regexp-quote STR
     Quote each special character found in STR with a backslash, and
     return the resulting string.

   *Very important:* Using backslash escapes in Guile source code (as
in Emacs Lisp or C) can be tricky, because the backslash character has
special meaning for the Guile reader.  For example, if Guile encounters
the character sequence `\n' in the middle of a string while processing
Scheme code, it replaces those characters with a newline character.
Similarly, the character sequence `\t' is replaced by a horizontal tab.
Several of these "escape sequences" are processed by the Guile reader
before your code is executed.  Unrecognized escape sequences are
ignored: if the characters `\*' appear in a string, they will be
translated to the single character `*'.

   This translation is obviously undesirable for regular expressions,
since we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use *two*
consecutive backslashes:

     (define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))

   The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to `make-regexp' is the
string `^\* [^:]*', which is what we really want.

   This also means that in order to write a regular expression that
matches a single backslash character, the regular expression string in
the source code must include *four* backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

     (define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))

   The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings described
above.  The POSIX regular expression specification and ANSI C standard
both require these semantics.  Attempting to abandon either convention
would cause other kinds of compatibility problems, possibly more severe
ones.  Therefore, without extending the Scheme reader to support
strings with different quoting conventions (an ungainly and confusing
extension when implemented in other languages), we must adhere to this
cumbersome escape syntax.

* Changes to the gh_ interface

* Changes to the scm_ interface

* Changes to system call interfaces:

** The value returned by `raise' is now unspecified.  It throws an exception
if an error occurs.

*** A new procedure `sigaction' can be used to install signal handlers

(sigaction signum [action] [flags])

signum is the signal number, which can be specified using the value
of SIGINT etc.

If action is omitted, sigaction returns a pair: the CAR is the current
signal hander, which will be either an integer with the value SIG_DFL
(default action) or SIG_IGN (ignore), or the Scheme procedure which
handles the signal, or #f if a non-Scheme procedure handles the
signal.  The CDR contains the current sigaction flags for the handler.

If action is provided, it is installed as the new handler for signum.
action can be a Scheme procedure taking one argument, or the value of
SIG_DFL (default action) or SIG_IGN (ignore), or #f to restore
whatever signal handler was installed before sigaction was first used.
Flags can optionally be specified for the new handler (SA_RESTART is
always used if the system provides it, so need not be specified.)  The
return value is a pair with information about the old handler as
described above.

This interface does not provide access to the "signal blocking"
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.

*** A new procedure `flush-all-ports' is equivalent to running
`force-output' on every port open for output.

** Guile now provides information on how it was built, via the new
global variable, %guile-build-info.  This variable records the values
of the standard GNU makefile directory variables as an assocation
list, mapping variable names (symbols) onto directory paths (strings).
For example, to find out where the Guile link libraries were
installed, you can say:

guile -c "(display (assq-ref %guile-build-info 'libdir)) (newline)"


* Changes to the scm_ interface

** The new function scm_handle_by_message_noexit is just like the
existing scm_handle_by_message function, except that it doesn't call
exit to terminate the process.  Instead, it prints a message and just
returns #f.  This might be a more appropriate catch-all handler for
new dynamic roots and threads.


Changes in Guile 1.1 (released Friday, May 16 1997):

* Changes to the distribution.

The Guile 1.0 distribution has been split up into several smaller
pieces:
guile-core --- the Guile interpreter itself.
guile-tcltk --- the interface between the Guile interpreter and
	Tcl/Tk; Tcl is an interpreter for a stringy language, and Tk
	is a toolkit for building graphical user interfaces.
guile-rgx-ctax --- the interface between Guile and the Rx regular
	expression matcher, and the translator for the Ctax
	programming language.  These are packaged together because the
	Ctax translator uses Rx to parse Ctax source code.

This NEWS file describes the changes made to guile-core since the 1.0
release.

We no longer distribute the documentation, since it was either out of
date, or incomplete.  As soon as we have current documentation, we
will distribute it.



* Changes to the stand-alone interpreter

** guile now accepts command-line arguments compatible with SCSH, Olin
Shivers' Scheme Shell.

In general, arguments are evaluated from left to right, but there are
exceptions.  The following switches stop argument processing, and
stash all remaining command-line arguments as the value returned by
the (command-line) function.
  -s SCRIPT      load Scheme source code from FILE, and exit
  -c EXPR        evalute Scheme expression EXPR, and exit
  --             stop scanning arguments; run interactively

The switches below are processed as they are encountered.
  -l FILE        load Scheme source code from FILE
  -e FUNCTION    after reading script, apply FUNCTION to
                 command line arguments
  -ds            do -s script at this point
  --emacs        enable Emacs protocol (experimental)
  -h, --help     display this help and exit
  -v, --version  display version information and exit
  \              read arguments from following script lines

So, for example, here is a Guile script named `ekko' (thanks, Olin)
which re-implements the traditional "echo" command:

#!/usr/local/bin/guile -s
!#
(define (main args)
	(map (lambda (arg) (display arg) (display " "))
	     (cdr args))
	(newline))

(main (command-line))

Suppose we invoke this script as follows:

	ekko a speckled gecko

Through the magic of Unix script processing (triggered by the `#!'
token at the top of the file), /usr/local/bin/guile receives the
following list of command-line arguments:

	("-s" "./ekko" "a" "speckled" "gecko")

Unix inserts the name of the script after the argument specified on
the first line of the file (in this case, "-s"), and then follows that
with the arguments given to the script.  Guile loads the script, which
defines the `main' function, and then applies it to the list of
remaining command-line arguments, ("a" "speckled" "gecko").

In Unix, the first line of a script file must take the following form:

#!INTERPRETER ARGUMENT

where INTERPRETER is the absolute filename of the interpreter
executable, and ARGUMENT is a single command-line argument to pass to
the interpreter.

You may only pass one argument to the interpreter, and its length is
limited.  These restrictions can be annoying to work around, so Guile
provides a general mechanism (borrowed from, and compatible with,
SCSH) for circumventing them.

If the ARGUMENT in a Guile script is a single backslash character,
`\', Guile will open the script file, parse arguments from its second
and subsequent lines, and replace the `\' with them.  So, for example,
here is another implementation of the `ekko' script:

#!/usr/local/bin/guile \
-e main -s
!#
(define (main args)
  (for-each (lambda (arg) (display arg) (display " "))
            (cdr args))
  (newline))

If the user invokes this script as follows:

	ekko a speckled gecko

Unix expands this into

	/usr/local/bin/guile \ ekko a speckled gecko

When Guile sees the `\' argument, it replaces it with the arguments
read from the second line of the script, producing:

	/usr/local/bin/guile -e main -s ekko a speckled gecko

This tells Guile to load the `ekko' script, and apply the function
`main' to the argument list ("a" "speckled" "gecko").

Here is how Guile parses the command-line arguments:
- Each space character terminates an argument.  This means that two
  spaces in a row introduce an empty-string argument.
- The tab character is not permitted (unless you quote it with the
  backslash character, as described below), to avoid confusion.
- The newline character terminates the sequence of arguments, and will
  also terminate a final non-empty argument.  (However, a newline
  following a space will not introduce a final empty-string argument;
  it only terminates the argument list.)
- The backslash character is the escape character.  It escapes
  backslash, space, tab, and newline.  The ANSI C escape sequences
  like \n and \t are also supported.  These produce argument
  constituents; the two-character combination \n doesn't act like a
  terminating newline.  The escape sequence \NNN for exactly three
  octal digits reads as the character whose ASCII code is NNN.  As
  above, characters produced this way are argument constituents.
  Backslash followed by other characters is not allowed.

* Changes to the procedure for linking libguile with your programs

** Guile now builds and installs a shared guile library, if your
system support shared libraries.  (It still builds a static library on
all systems.)  Guile automatically detects whether your system
supports shared libraries.  To prevent Guile from buildisg shared
libraries, pass the `--disable-shared' flag to the configure script.

Guile takes longer to compile when it builds shared libraries, because
it must compile every file twice --- once to produce position-
independent object code, and once to produce normal object code.

** The libthreads library has been merged into libguile.

To link a program against Guile, you now need only link against
-lguile and -lqt; -lthreads is no longer needed.  If you are using
autoconf to generate configuration scripts for your application, the
following lines should suffice to add the appropriate libraries to
your link command:

### Find quickthreads and libguile.
AC_CHECK_LIB(qt, main)
AC_CHECK_LIB(guile, scm_shell)

* Changes to Scheme functions

** Guile Scheme's special syntax for keyword objects is now optional,
and disabled by default.

The syntax variation from R4RS made it difficult to port some
interesting packages to Guile.  The routines which accepted keyword
arguments (mostly in the module system) have been modified to also
accept symbols whose names begin with `:'.

To change the keyword syntax, you must first import the (ice-9 debug)
module:
	(use-modules (ice-9 debug))

Then you can enable the keyword syntax as follows:
	(read-set! keywords 'prefix)

To disable keyword syntax, do this:
	(read-set! keywords #f)

** Many more primitive functions accept shared substrings as
arguments.  In the past, these functions required normal, mutable
strings as arguments, although they never made use of this
restriction.

** The uniform array functions now operate on byte vectors.  These
functions are `array-fill!', `serial-array-copy!', `array-copy!',
`serial-array-map', `array-map', `array-for-each', and
`array-index-map!'.

** The new functions `trace' and `untrace' implement simple debugging
support for Scheme functions.

The `trace' function accepts any number of procedures as arguments,
and tells the Guile interpreter to display each procedure's name and
arguments each time the procedure is invoked.  When invoked with no
arguments, `trace' returns the list of procedures currently being
traced.

The `untrace' function accepts any number of procedures as arguments,
and tells the Guile interpreter not to trace them any more.  When
invoked with no arguments, `untrace' untraces all curretly traced
procedures.

The tracing in Guile has an advantage over most other systems: we
don't create new procedure objects, but mark the procedure objects
themselves.  This means that anonymous and internal procedures can be
traced.

** The function `assert-repl-prompt' has been renamed to
`set-repl-prompt!'.  It takes one argument, PROMPT.
- If PROMPT is #f, the Guile read-eval-print loop will not prompt.
- If PROMPT is a string, we use it as a prompt.
- If PROMPT is a procedure accepting no arguments, we call it, and
  display the result as a prompt.
- Otherwise, we display "> ".

** The new function `eval-string' reads Scheme expressions from a
string and evaluates them, returning the value of the last expression
in the string.  If the string contains no expressions, it returns an
unspecified value.

** The new function `thunk?' returns true iff its argument is a
procedure of zero arguments.

** `defined?' is now a builtin function, instead of syntax.  This
means that its argument should be quoted.  It returns #t iff its
argument is bound in the current module.

** The new syntax `use-modules' allows you to add new modules to your
environment without re-typing a complete `define-module' form.  It
accepts any number of module names as arguments, and imports their
public bindings into the current module.

** The new function (module-defined? NAME MODULE) returns true iff
NAME, a symbol, is defined in MODULE, a module object.

** The new function `builtin-bindings' creates and returns a hash
table containing copies of all the root module's bindings.

** The new function `builtin-weak-bindings' does the same as
`builtin-bindings', but creates a doubly-weak hash table.

** The `equal?' function now considers variable objects to be
equivalent if they have the same name and the same value.

** The new function `command-line' returns the command-line arguments
given to Guile, as a list of strings.

When using guile as a script interpreter, `command-line' returns the
script's arguments; those processed by the interpreter (like `-s' or
`-c') are omitted.  (In other words, you get the normal, expected
behavior.)  Any application that uses scm_shell to process its
command-line arguments gets this behavior as well.

** The new function `load-user-init' looks for a file called `.guile'
in the user's home directory, and loads it if it exists.  This is
mostly for use by the code generated by scm_compile_shell_switches,
but we thought it might also be useful in other circumstances.

** The new function `log10' returns the base-10 logarithm of its
argument.

** Changes to I/O functions

*** The functions `read', `primitive-load', `read-and-eval!', and
`primitive-load-path' no longer take optional arguments controlling
case insensitivity and a `#' parser.

Case sensitivity is now controlled by a read option called
`case-insensitive'.  The user can add new `#' syntaxes with the
`read-hash-extend' function (see below).

*** The new function `read-hash-extend' allows the user to change the
syntax of Guile Scheme in a somewhat controlled way.

(read-hash-extend CHAR PROC)
  When parsing S-expressions, if we read a `#' character followed by
  the character CHAR, use PROC to parse an object from the stream.
  If PROC is #f, remove any parsing procedure registered for CHAR.

  The reader applies PROC to two arguments: CHAR and an input port.

*** The new functions read-delimited and read-delimited! provide a
general mechanism for doing delimited input on streams.

(read-delimited DELIMS [PORT HANDLE-DELIM])
  Read until we encounter one of the characters in DELIMS (a string),
  or end-of-file.  PORT is the input port to read from; it defaults to
  the current input port.  The HANDLE-DELIM parameter determines how
  the terminating character is handled; it should be one of the
  following symbols:

    'trim     omit delimiter from result
    'peek     leave delimiter character in input stream
    'concat   append delimiter character to returned value
    'split    return a pair: (RESULT . TERMINATOR)

  HANDLE-DELIM defaults to 'peek.

(read-delimited! DELIMS BUF [PORT HANDLE-DELIM START END])
  A side-effecting variant of `read-delimited'.

  The data is written into the string BUF at the indices in the
  half-open interval [START, END); the default interval is the whole
  string: START = 0 and END = (string-length BUF).  The values of
  START and END must specify a well-defined interval in BUF, i.e.
  0 <= START <= END <= (string-length BUF).

  It returns NBYTES, the number of bytes read.  If the buffer filled
  up without a delimiter character being found, it returns #f.  If the
  port is at EOF when the read starts, it returns the EOF object.

  If an integer is returned (i.e., the read is successfully terminated
  by reading a delimiter character), then the HANDLE-DELIM parameter
  determines how to handle the terminating character.  It is described
  above, and defaults to 'peek.

(The descriptions of these functions were borrowed from the SCSH
manual, by Olin Shivers and Brian Carlstrom.)

*** The `%read-delimited!' function is the primitive used to implement
`read-delimited' and `read-delimited!'.

(%read-delimited! DELIMS BUF GOBBLE? [PORT START END])

This returns a pair of values: (TERMINATOR . NUM-READ).
- TERMINATOR describes why the read was terminated.  If it is a
  character or the eof object, then that is the value that terminated
  the read.  If it is #f, the function filled the buffer without finding
  a delimiting character.
- NUM-READ is the number of characters read into BUF.

If the read is successfully terminated by reading a delimiter
character, then the gobble? parameter determines what to do with the
terminating character.  If true, the character is removed from the
input stream; if false, the character is left in the input stream
where a subsequent read operation will retrieve it.  In either case,
the character is also the first value returned by the procedure call.

(The descriptions of this function was borrowed from the SCSH manual,
by Olin Shivers and Brian Carlstrom.)

*** The `read-line' and `read-line!' functions have changed; they now
trim the terminator by default; previously they appended it to the
returned string.  For the old behavior, use (read-line PORT 'concat).

*** The functions `uniform-array-read!' and `uniform-array-write!' now
take new optional START and END arguments, specifying the region of
the array to read and write.

*** The `ungetc-char-ready?' function has been removed.  We feel it's
inappropriate for an interface to expose implementation details this
way.

** Changes to the Unix library and system call interface

*** The new fcntl function provides access to the Unix `fcntl' system
call.

(fcntl PORT COMMAND VALUE)
  Apply COMMAND to PORT's file descriptor, with VALUE as an argument.
  Values for COMMAND are:

    F_DUPFD	duplicate a file descriptor
    F_GETFD	read the descriptor's close-on-exec flag
    F_SETFD     set the descriptor's close-on-exec flag to VALUE
    F_GETFL	read the descriptor's flags, as set on open
    F_SETFL	set the descriptor's flags, as set on open to VALUE
    F_GETOWN    return the process ID of a socket's owner, for SIGIO
    F_SETOWN    set the process that owns a socket to VALUE, for SIGIO
    FD_CLOEXEC  not sure what this is

For details, see the documentation for the fcntl system call.

*** The arguments to `select' have changed, for compatibility with
SCSH.  The TIMEOUT parameter may now be non-integral, yielding the
expected behavior.  The MILLISECONDS parameter has been changed to
MICROSECONDS, to more closely resemble the underlying system call.
The RVEC, WVEC, and EVEC arguments can now be vectors; the type of the
corresponding return set will be the same.

*** The arguments to the `mknod' system call have changed.  They are
now:

(mknod PATH TYPE PERMS DEV)
  Create a new file (`node') in the file system.  PATH is the name of
  the file to create.  TYPE is the kind of file to create; it should
  be 'fifo, 'block-special, or 'char-special.  PERMS specifies the
  permission bits to give the newly created file.  If TYPE is
  'block-special or 'char-special, DEV specifies which device the
  special file refers to; its interpretation depends on the kind of
  special file being created.

*** The `fork' function has been renamed to `primitive-fork', to avoid
clashing with various SCSH forks.

*** The `recv' and `recvfrom' functions have been renamed to `recv!'
and `recvfrom!'.  They no longer accept a size for a second argument;
you must pass a string to hold the received value.  They no longer
return the buffer.  Instead, `recv' returns the length of the message
received, and `recvfrom' returns a pair containing the packet's length
and originating address.

*** The file descriptor datatype has been removed, as have the
`read-fd', `write-fd', `close', `lseek', and `dup' functions.
We plan to replace these functions with a SCSH-compatible interface.

*** The `create' function has been removed; it's just a special case
of `open'.

*** There are new functions to break down process termination status
values.  In the descriptions below, STATUS is a value returned by
`waitpid'.

(status:exit-val STATUS)
  If the child process exited normally, this function returns the exit
  code for the child process (i.e., the value passed to exit, or
  returned from main).  If the child process did not exit normally,
  this function returns #f.

(status:stop-sig STATUS)
  If the child process was suspended by a signal, this function
  returns the signal that suspended the child.  Otherwise, it returns
  #f.

(status:term-sig STATUS)
  If the child process terminated abnormally, this function returns
  the signal that terminated the child.  Otherwise, this function
  returns false.

POSIX promises that exactly one of these functions will return true on
a valid STATUS value.

These functions are compatible with SCSH.

*** There are new accessors and setters for the broken-out time vectors
returned by `localtime', `gmtime', and that ilk.  They are:

  Component                 Accessor     Setter
  ========================= ============ ============
  seconds                   tm:sec       set-tm:sec
  minutes                   tm:min       set-tm:min
  hours                     tm:hour      set-tm:hour
  day of the month          tm:mday      set-tm:mday
  month                     tm:mon       set-tm:mon
  year                      tm:year      set-tm:year
  day of the week           tm:wday      set-tm:wday
  day in the year           tm:yday      set-tm:yday
  daylight saving time      tm:isdst     set-tm:isdst
  GMT offset, seconds       tm:gmtoff    set-tm:gmtoff
  name of time zone         tm:zone      set-tm:zone

*** There are new accessors for the vectors returned by `uname',
describing the host system:

  Component                                      Accessor
  ============================================== ================
  name of the operating system implementation    utsname:sysname
  network name of this machine                   utsname:nodename
  release level of the operating system          utsname:release
  version level of the operating system          utsname:version
  machine hardware platform                      utsname:machine

*** There are new accessors for the vectors returned by `getpw',
`getpwnam', `getpwuid', and `getpwent', describing entries from the
system's user database:

  Component              Accessor
  ====================== =================
  user name              passwd:name
  user password		 passwd:passwd
  user id		 passwd:uid
  group id		 passwd:gid
  real name		 passwd:gecos
  home directory	 passwd:dir
  shell program		 passwd:shell

*** There are new accessors for the vectors returned by `getgr',
`getgrnam', `getgrgid', and `getgrent', describing entries from the
system's group database:

  Component               Accessor
  ======================= ============
  group name              group:name
  group password 	  group:passwd
  group id       	  group:gid
  group members  	  group:mem

*** There are new accessors for the vectors returned by `gethost',
`gethostbyaddr', `gethostbyname', and `gethostent', describing
internet hosts:

  Component                 Accessor
  ========================= ===============
  official name of host     hostent:name
  alias list		    hostent:aliases
  host address type	    hostent:addrtype
  length of address	    hostent:length
  list of addresses	    hostent:addr-list

*** There are new accessors for the vectors returned by `getnet',
`getnetbyaddr', `getnetbyname', and `getnetent', describing internet
networks:

  Component                 Accessor
  ========================= ===============
  official name of net      netent:name
  alias list		    netent:aliases
  net number type	    netent:addrtype
  net number		    netent:net

*** There are new accessors for the vectors returned by `getproto',
`getprotobyname', `getprotobynumber', and `getprotoent', describing
internet protocols:

  Component                 Accessor
  ========================= ===============
  official protocol name    protoent:name
  alias list		    protoent:aliases
  protocol number	    protoent:proto

*** There are new accessors for the vectors returned by `getserv',
`getservbyname', `getservbyport', and `getservent', describing
internet protocols:

  Component                 Accessor
  ========================= ===============
  official service name     servent:name
  alias list		    servent:aliases
  port number		    servent:port
  protocol to use	    servent:proto

*** There are new accessors for the sockaddr structures returned by
`accept', `getsockname', `getpeername', `recvfrom!':

  Component                                Accessor
  ======================================== ===============
  address format (`family')                sockaddr:fam
  path, for file domain addresses	   sockaddr:path
  address, for internet domain addresses   sockaddr:addr
  TCP or UDP port, for internet		   sockaddr:port

*** The `getpwent', `getgrent', `gethostent', `getnetent',
`getprotoent', and `getservent' functions now return #f at the end of
the user database.  (They used to throw an exception.)

Note that calling MUMBLEent function is equivalent to calling the
corresponding MUMBLE function with no arguments.

*** The `setpwent', `setgrent', `sethostent', `setnetent',
`setprotoent', and `setservent' routines now take no arguments.

*** The `gethost', `getproto', `getnet', and `getserv' functions now
provide more useful information when they throw an exception.

*** The `lnaof' function has been renamed to `inet-lnaof'.

*** Guile now claims to have the `current-time' feature.

*** The `mktime' function now takes an optional second argument ZONE,
giving the time zone to use for the conversion.  ZONE should be a
string, in the same format as expected for the "TZ" environment variable.

*** The `strptime' function now returns a pair (TIME . COUNT), where
TIME is the parsed time as a vector, and COUNT is the number of
characters from the string left unparsed.  This function used to
return the remaining characters as a string.

*** The `gettimeofday' function has replaced the old `time+ticks' function.
The return value is now (SECONDS . MICROSECONDS); the fractional
component is no longer expressed in "ticks".

*** The `ticks/sec' constant has been removed, in light of the above change.

* Changes to the gh_ interface

** gh_eval_str() now returns an SCM object which is the result of the
evaluation

** gh_scm2str() now copies the Scheme data to a caller-provided C
array

** gh_scm2newstr() now makes a C array, copies the Scheme data to it,
and returns the array

** gh_scm2str0() is gone: there is no need to distinguish
null-terminated from non-null-terminated, since gh_scm2newstr() allows
the user to interpret the data both ways.

* Changes to the scm_ interface

** The new function scm_symbol_value0 provides an easy way to get a
symbol's value from C code:

SCM scm_symbol_value0 (char *NAME)
  Return the value of the symbol named by the null-terminated string
  NAME in the current module.  If the symbol named NAME is unbound in
  the current module, return SCM_UNDEFINED.

** The new function scm_sysintern0 creates new top-level variables,
without assigning them a value.

SCM scm_sysintern0 (char *NAME)
  Create a new Scheme top-level variable named NAME.  NAME is a
  null-terminated string.  Return the variable's value cell.

** The function scm_internal_catch is the guts of catch.  It handles
all the mechanics of setting up a catch target, invoking the catch
body, and perhaps invoking the handler if the body does a throw.

The function is designed to be usable from C code, but is general
enough to implement all the semantics Guile Scheme expects from throw.

TAG is the catch tag.  Typically, this is a symbol, but this function
doesn't actually care about that.

BODY is a pointer to a C function which runs the body of the catch;
this is the code you can throw from.  We call it like this:
   BODY (BODY_DATA, JMPBUF)
where:
   BODY_DATA is just the BODY_DATA argument we received; we pass it
      through to BODY as its first argument.  The caller can make
      BODY_DATA point to anything useful that BODY might need.
   JMPBUF is the Scheme jmpbuf object corresponding to this catch,
      which we have just created and initialized.

HANDLER is a pointer to a C function to deal with a throw to TAG,
should one occur.  We call it like this:
   HANDLER (HANDLER_DATA, THROWN_TAG, THROW_ARGS)
where
   HANDLER_DATA is the HANDLER_DATA argument we recevied; it's the
      same idea as BODY_DATA above.
   THROWN_TAG is the tag that the user threw to; usually this is
      TAG, but it could be something else if TAG was #t (i.e., a
      catch-all), or the user threw to a jmpbuf.
   THROW_ARGS is the list of arguments the user passed to the THROW
      function.

BODY_DATA is just a pointer we pass through to BODY.  HANDLER_DATA
is just a pointer we pass through to HANDLER.  We don't actually
use either of those pointers otherwise ourselves.  The idea is
that, if our caller wants to communicate something to BODY or
HANDLER, it can pass a pointer to it as MUMBLE_DATA, which BODY and
HANDLER can then use.  Think of it as a way to make BODY and
HANDLER closures, not just functions; MUMBLE_DATA points to the
enclosed variables.

Of course, it's up to the caller to make sure that any data a
MUMBLE_DATA needs is protected from GC.  A common way to do this is
to make MUMBLE_DATA a pointer to data stored in an automatic
structure variable; since the collector must scan the stack for
references anyway, this assures that any references in MUMBLE_DATA
will be found.

** The new function scm_internal_lazy_catch is exactly like
scm_internal_catch, except:

- It does not unwind the stack (this is the major difference).
- If handler returns, its value is returned from the throw.
- BODY always receives #f as its JMPBUF argument (since there's no
  jmpbuf associated with a lazy catch, because we don't unwind the
  stack.)

** scm_body_thunk is a new body function you can pass to
scm_internal_catch if you want the body to be like Scheme's `catch'
--- a thunk, or a function of one argument if the tag is #f.

BODY_DATA is a pointer to a scm_body_thunk_data structure, which
contains the Scheme procedure to invoke as the body, and the tag
we're catching.  If the tag is #f, then we pass JMPBUF (created by
scm_internal_catch) to the body procedure; otherwise, the body gets
no arguments.

** scm_handle_by_proc is a new handler function you can pass to
scm_internal_catch if you want the handler to act like Scheme's catch
--- call a procedure with the tag and the throw arguments.

If the user does a throw to this catch, this function runs a handler
procedure written in Scheme.  HANDLER_DATA is a pointer to an SCM
variable holding the Scheme procedure object to invoke.  It ought to
be a pointer to an automatic variable (i.e., one living on the stack),
or the procedure object should be otherwise protected from GC.

** scm_handle_by_message is a new handler function to use with
`scm_internal_catch' if you want Guile to print a message and die.
It's useful for dealing with throws to uncaught keys at the top level.

HANDLER_DATA, if non-zero, is assumed to be a char * pointing to a
message header to print; if zero, we use "guile" instead.  That
text is followed by a colon, then the message described by ARGS.

** The return type of scm_boot_guile is now void; the function does
not return a value, and indeed, never returns at all.

** The new function scm_shell makes it easy for user applications to
process command-line arguments in a way that is compatible with the
stand-alone guile interpreter (which is in turn compatible with SCSH,
the Scheme shell).

To use the scm_shell function, first initialize any guile modules
linked into your application, and then call scm_shell with the values
of ARGC and ARGV your `main' function received.  scm_shell will add
any SCSH-style meta-arguments from the top of the script file to the
argument vector, and then process the command-line arguments.  This
generally means loading a script file or starting up an interactive
command interpreter.  For details, see "Changes to the stand-alone
interpreter" above.

** The new functions scm_get_meta_args and scm_count_argv help you
implement the SCSH-style meta-argument, `\'.

char **scm_get_meta_args (int ARGC, char **ARGV)
  If the second element of ARGV is a string consisting of a single
  backslash character (i.e. "\\" in Scheme notation), open the file
  named by the following argument, parse arguments from it, and return
  the spliced command line.  The returned array is terminated by a
  null pointer.

  For details of argument parsing, see above, under "guile now accepts
  command-line arguments compatible with SCSH..."

int scm_count_argv (char **ARGV)
  Count the arguments in ARGV, assuming it is terminated by a null
  pointer.

For an example of how these functions might be used, see the source
code for the function scm_shell in libguile/script.c.

You will usually want to use scm_shell instead of calling this
function yourself.

** The new function scm_compile_shell_switches turns an array of
command-line arguments into Scheme code to carry out the actions they
describe.  Given ARGC and ARGV, it returns a Scheme expression to
evaluate, and calls scm_set_program_arguments to make any remaining
command-line arguments available to the Scheme code.  For example,
given the following arguments:

	-e main -s ekko a speckled gecko

scm_set_program_arguments will return the following expression:

	(begin (load "ekko") (main (command-line)) (quit))

You will usually want to use scm_shell instead of calling this
function yourself.

** The function scm_shell_usage prints a usage message appropriate for
an interpreter that uses scm_compile_shell_switches to handle its
command-line arguments.

void scm_shell_usage (int FATAL, char *MESSAGE)
  Print a usage message to the standard error output.  If MESSAGE is
  non-zero, write it before the usage message, followed by a newline.
  If FATAL is non-zero, exit the process, using FATAL as the
  termination status.  (If you want to be compatible with Guile,
  always use 1 as the exit status when terminating due to command-line
  usage problems.)

You will usually want to use scm_shell instead of calling this
function yourself.

** scm_eval_0str now returns SCM_UNSPECIFIED if the string contains no
expressions.  It used to return SCM_EOL.  Earth-shattering.

** The macros for declaring scheme objects in C code have been
rearranged slightly.  They are now:

SCM_SYMBOL (C_NAME, SCHEME_NAME)
  Declare a static SCM variable named C_NAME, and initialize it to
  point to the Scheme symbol whose name is SCHEME_NAME.  C_NAME should
  be a C identifier, and SCHEME_NAME should be a C string.

SCM_GLOBAL_SYMBOL (C_NAME, SCHEME_NAME)
  Just like SCM_SYMBOL, but make C_NAME globally visible.

SCM_VCELL (C_NAME, SCHEME_NAME)
  Create a global variable at the Scheme level named SCHEME_NAME.
  Declare a static SCM variable named C_NAME, and initialize it to
  point to the Scheme variable's value cell.

SCM_GLOBAL_VCELL (C_NAME, SCHEME_NAME)
  Just like SCM_VCELL, but make C_NAME globally visible.

The `guile-snarf' script writes initialization code for these macros
to its standard output, given C source code as input.

The SCM_GLOBAL macro is gone.

** The scm_read_line and scm_read_line_x functions have been replaced
by Scheme code based on the %read-delimited! procedure (known to C
code as scm_read_delimited_x).  See its description above for more
information.

** The function scm_sys_open has been renamed to scm_open.  It now
returns a port instead of an FD object.

* The dynamic linking support has changed.  For more information, see
libguile/DYNAMIC-LINKING.


Guile 1.0b3

User-visible changes from Thursday, September 5, 1996 until Guile 1.0
(Sun 5 Jan 1997):

* Changes to the 'guile' program:

** Guile now loads some new files when it starts up.  Guile first
searches the load path for init.scm, and loads it if found.  Then, if
Guile is not being used to execute a script, and the user's home
directory contains a file named `.guile', Guile loads that.

** You can now use Guile as a shell script interpreter.

To paraphrase the SCSH manual:

    When Unix tries to execute an executable file whose first two
    characters are the `#!', it treats the file not as machine code to
    be directly executed by the native processor, but as source code
    to be executed by some interpreter.  The interpreter to use is
    specified immediately after the #! sequence on the first line of
    the source file.  The kernel reads in the name of the interpreter,
    and executes that instead.  It passes the interpreter the source
    filename as its first argument, with the original arguments
    following.  Consult the Unix man page for the `exec' system call
    for more information.

Now you can use Guile as an interpreter, using a mechanism which is a
compatible subset of that provided by SCSH.

Guile now recognizes a '-s' command line switch, whose argument is the
name of a file of Scheme code to load.  It also treats the two
characters `#!' as the start of a comment, terminated by `!#'.  Thus,
to make a file of Scheme code directly executable by Unix, insert the
following two lines at the top of the file:

#!/usr/local/bin/guile -s
!#

Guile treats the argument of the `-s' command-line switch as the name
of a file of Scheme code to load, and treats the sequence `#!' as the
start of a block comment, terminated by `!#'.

For example, here's a version of 'echo' written in Scheme:

#!/usr/local/bin/guile -s
!#
(let loop ((args (cdr (program-arguments))))
  (if (pair? args)
      (begin
	(display (car args))
	(if (pair? (cdr args))
	    (display " "))
	(loop (cdr args)))))
(newline)

Why does `#!' start a block comment terminated by `!#', instead of the
end of the line?  That is the notation SCSH uses, and although we
don't yet support the other SCSH features that motivate that choice,
we would like to be backward-compatible with any existing Guile
scripts once we do.  Furthermore, if the path to Guile on your system
is too long for your kernel, you can start the script with this
horrible hack:

#!/bin/sh
exec /really/long/path/to/guile -s "$0" ${1+"$@"}
!#

Note that some very old Unix systems don't support the `#!' syntax.


** You can now run Guile without installing it.

Previous versions of the interactive Guile interpreter (`guile')
couldn't start up unless Guile's Scheme library had been installed;
they used the value of the environment variable `SCHEME_LOAD_PATH'
later on in the startup process, but not to find the startup code
itself.  Now Guile uses `SCHEME_LOAD_PATH' in all searches for Scheme
code.

To run Guile without installing it, build it in the normal way, and
then set the environment variable `SCHEME_LOAD_PATH' to a
colon-separated list of directories, including the top-level directory
of the Guile sources.  For example, if you unpacked Guile so that the
full filename of this NEWS file is /home/jimb/guile-1.0b3/NEWS, then
you might say

	export SCHEME_LOAD_PATH=/home/jimb/my-scheme:/home/jimb/guile-1.0b3


** Guile's read-eval-print loop no longer prints #<unspecified>
results.  If the user wants to see this, she can evaluate the
expression (assert-repl-print-unspecified #t), perhaps in her startup
file.

** Guile no longer shows backtraces by default when an error occurs;
however, it does display a message saying how to get one, and how to
request that they be displayed by default.  After an error, evaluate
   (backtrace)
to see a backtrace, and
   (debug-enable 'backtrace)
to see them by default.



* Changes to Guile Scheme:

** Guile now distinguishes between #f and the empty list.

This is for compatibility with the IEEE standard, the (possibly)
upcoming Revised^5 Report on Scheme, and many extant Scheme
implementations.

Guile used to have #f and '() denote the same object, to make Scheme's
type system more compatible with Emacs Lisp's.  However, the change
caused too much trouble for Scheme programmers, and we found another
way to reconcile Emacs Lisp with Scheme that didn't require this.


** Guile's delq, delv, delete functions, and their destructive
counterparts, delq!, delv!, and delete!, now remove all matching
elements from the list, not just the first.  This matches the behavior
of the corresponding Emacs Lisp functions, and (I believe) the Maclisp
functions which inspired them.

I recognize that this change may break code in subtle ways, but it
seems best to make the change before the FSF's first Guile release,
rather than after.


** The compiled-library-path function has been deleted from libguile.

** The facilities for loading Scheme source files have changed.

*** The variable %load-path now tells Guile which directories to search
for Scheme code.  Its value is a list of strings, each of which names
a directory.

*** The variable %load-extensions now tells Guile which extensions to
try appending to a filename when searching the load path.  Its value
is a list of strings.  Its default value is ("" ".scm").

*** (%search-load-path FILENAME) searches the directories listed in the
value of the %load-path variable for a Scheme file named FILENAME,
with all the extensions listed in %load-extensions.  If it finds a
match, then it returns its full filename.  If FILENAME is absolute, it
returns it unchanged.  Otherwise, it returns #f.

%search-load-path will not return matches that refer to directories.

*** (primitive-load FILENAME :optional CASE-INSENSITIVE-P SHARP)
uses %seach-load-path to find a file named FILENAME, and loads it if
it finds it.  If it can't read FILENAME for any reason, it throws an
error.

The arguments CASE-INSENSITIVE-P and SHARP are interpreted as by the
`read' function.

*** load uses the same searching semantics as primitive-load.

*** The functions %try-load, try-load-with-path, %load, load-with-path,
basic-try-load-with-path, basic-load-with-path, try-load-module-with-
path, and load-module-with-path have been deleted.  The functions
above should serve their purposes.

*** If the value of the variable %load-hook is a procedure,
`primitive-load' applies its value to the name of the file being
loaded (without the load path directory name prepended).  If its value
is #f, it is ignored.  Otherwise, an error occurs.

This is mostly useful for printing load notification messages.


** The function `eval!' is no longer accessible from the scheme level.
We can't allow operations which introduce glocs into the scheme level,
because Guile's type system can't handle these as data.  Use `eval' or
`read-and-eval!' (see below) as replacement.

** The new function read-and-eval! reads an expression from PORT,
evaluates it, and returns the result.  This is more efficient than
simply calling `read' and `eval', since it is not necessary to make a
copy of the expression for the evaluator to munge.

Its optional arguments CASE_INSENSITIVE_P and SHARP are interpreted as
for the `read' function.


** The function `int?' has been removed; its definition was identical
to that of `integer?'.

** The functions `<?', `<?', `<=?', `=?', `>?', and `>=?'.  Code should
use the R4RS names for these functions.

** The function object-properties no longer returns the hash handle;
it simply returns the object's property list.

** Many functions have been changed to throw errors, instead of
returning #f on failure.  The point of providing exception handling in
the language is to simplify the logic of user code, but this is less
useful if Guile's primitives don't throw exceptions.

** The function `fileno' has been renamed from `%fileno'.

** The function primitive-mode->fdes returns #t or #f now, not 1 or 0.


* Changes to Guile's C interface:

** The library's initialization procedure has been simplified.
scm_boot_guile now has the prototype:

void scm_boot_guile (int ARGC,
                     char **ARGV,
	             void (*main_func) (),
	             void *closure);

scm_boot_guile calls MAIN_FUNC, passing it CLOSURE, ARGC, and ARGV.
MAIN_FUNC should do all the work of the program (initializing other
packages, reading user input, etc.) before returning.  When MAIN_FUNC
returns, call exit (0); this function never returns.  If you want some
other exit value, MAIN_FUNC may call exit itself.

scm_boot_guile arranges for program-arguments to return the strings
given by ARGC and ARGV.  If MAIN_FUNC modifies ARGC/ARGV, should call
scm_set_program_arguments with the final list, so Scheme code will
know which arguments have been processed.

scm_boot_guile establishes a catch-all catch handler which prints an
error message and exits the process.  This means that Guile exits in a
coherent way when system errors occur and the user isn't prepared to
handle it.  If the user doesn't like this behavior, they can establish
their own universal catcher in MAIN_FUNC to shadow this one.

Why must the caller do all the real work from MAIN_FUNC?  The garbage
collector assumes that all local variables of type SCM will be above
scm_boot_guile's stack frame on the stack.  If you try to manipulate
SCM values after this function returns, it's the luck of the draw
whether the GC will be able to find the objects you allocate.  So,
scm_boot_guile function exits, rather than returning, to discourage
people from making that mistake.

The IN, OUT, and ERR arguments were removed; there are other
convenient ways to override these when desired.

The RESULT argument was deleted; this function should never return.

The BOOT_CMD argument was deleted; the MAIN_FUNC argument is more
general.


** Guile's header files should no longer conflict with your system's
header files.

In order to compile code which #included <libguile.h>, previous
versions of Guile required you to add a directory containing all the
Guile header files to your #include path.  This was a problem, since
Guile's header files have names which conflict with many systems'
header files.

Now only <libguile.h> need appear in your #include path; you must
refer to all Guile's other header files as <libguile/mumble.h>.
Guile's installation procedure puts libguile.h in $(includedir), and
the rest in $(includedir)/libguile.


** Two new C functions, scm_protect_object and scm_unprotect_object,
have been added to the Guile library.

scm_protect_object (OBJ) protects OBJ from the garbage collector.
OBJ will not be freed, even if all other references are dropped,
until someone does scm_unprotect_object (OBJ).  Both functions
return OBJ.

Note that calls to scm_protect_object do not nest.  You can call
scm_protect_object any number of times on a given object, and the
next call to scm_unprotect_object will unprotect it completely.

Basically, scm_protect_object and scm_unprotect_object just
maintain a list of references to things.  Since the GC knows about
this list, all objects it mentions stay alive.  scm_protect_object
adds its argument to the list; scm_unprotect_object remove its
argument from the list.


** scm_eval_0str now returns the value of the last expression
evaluated.

** The new function scm_read_0str reads an s-expression from a
null-terminated string, and returns it.

** The new function `scm_stdio_to_port' converts a STDIO file pointer
to a Scheme port object.

** The new function `scm_set_program_arguments' allows C code to set
the value returned by the Scheme `program-arguments' function.


Older changes:

* Guile no longer includes sophisticated Tcl/Tk support.

The old Tcl/Tk support was unsatisfying to us, because it required the
user to link against the Tcl library, as well as Tk and Guile.  The
interface was also un-lispy, in that it preserved Tcl/Tk's practice of
referring to widgets by names, rather than exporting widgets to Scheme
code as a special datatype.

In the Usenix Tk Developer's Workshop held in July 1996, the Tcl/Tk
maintainers described some very interesting changes in progress to the
Tcl/Tk internals, which would facilitate clean interfaces between lone
Tk and other interpreters --- even for garbage-collected languages
like Scheme.  They expected the new Tk to be publicly available in the
fall of 1996.

Since it seems that Guile might soon have a new, cleaner interface to
lone Tk, and that the old Guile/Tk glue code would probably need to be
completely rewritten, we (Jim Blandy and Richard Stallman) have
decided not to support the old code.  We'll spend the time instead on
a good interface to the newer Tk, as soon as it is available.

Until then, gtcltk-lib provides trivial, low-maintenance functionality.


Copyright information:

Copyright (C) 1996,1997 Free Software Foundation, Inc.

   Permission is granted to anyone to make or distribute verbatim copies
   of this document as received, in any medium, provided that the
   copyright notice and this permission notice are preserved,
   thus giving the recipient permission to redistribute in turn.

   Permission is granted to distribute modified versions
   of this document, or of portions of it,
   under the above conditions, provided also that they
   carry prominent notices stating who last changed them.


Local variables:
mode: outline
paragraph-separate: "[ 	]*$"
end:

