
acons
@c snarfed from alist.c:36
@deffn {Scheme Procedure} acons key value alist
@deffnx {C Function} scm_acons (key, value, alist)
Add a new key-value pair to @var{alist}.  A new pair is
created whose car is @var{key} and whose cdr is @var{value}, and the
pair is consed onto @var{alist}, and the new list is returned.  This
function is @emph{not} destructive; @var{alist} is not modified.
@end deffn

sloppy-assq
@c snarfed from alist.c:50
@deffn {Scheme Procedure} sloppy-assq key alist
@deffnx {C Function} scm_sloppy_assq (key, alist)
Behaves like @code{assq} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

sloppy-assv
@c snarfed from alist.c:68
@deffn {Scheme Procedure} sloppy-assv key alist
@deffnx {C Function} scm_sloppy_assv (key, alist)
Behaves like @code{assv} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

sloppy-assoc
@c snarfed from alist.c:86
@deffn {Scheme Procedure} sloppy-assoc key alist
@deffnx {C Function} scm_sloppy_assoc (key, alist)
Behaves like @code{assoc} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

assq
@c snarfed from alist.c:113
@deffn {Scheme Procedure} assq key alist
@deffnx {Scheme Procedure} assv key alist
@deffnx {Scheme Procedure} assoc key alist
@deffnx {C Function} scm_assq (key, alist)
Fetch the entry in @var{alist} that is associated with @var{key}.  To
decide whether the argument @var{key} matches a particular entry in
@var{alist}, @code{assq} compares keys with @code{eq?}, @code{assv}
uses @code{eqv?} and @code{assoc} uses @code{equal?}.  If @var{key}
cannot be found in @var{alist} (according to whichever equality
predicate is in use), then return @code{#f}.  These functions
return the entire alist entry found (i.e. both the key and the value).
@end deffn

assv
@c snarfed from alist.c:134
@deffn {Scheme Procedure} assv key alist
@deffnx {C Function} scm_assv (key, alist)
Behaves like @code{assq} but uses @code{eqv?} for key comparison.
@end deffn

assoc
@c snarfed from alist.c:155
@deffn {Scheme Procedure} assoc key alist
@deffnx {C Function} scm_assoc (key, alist)
Behaves like @code{assq} but uses @code{equal?} for key comparison.
@end deffn

assq-ref
@c snarfed from alist.c:199
@deffn {Scheme Procedure} assq-ref alist key
@deffnx {Scheme Procedure} assv-ref alist key
@deffnx {Scheme Procedure} assoc-ref alist key
@deffnx {C Function} scm_assq_ref (alist, key)
Like @code{assq}, @code{assv} and @code{assoc}, except that only the
value associated with @var{key} in @var{alist} is returned.  These
functions are equivalent to

@lisp
(let ((ent (@var{associator} @var{key} @var{alist})))
  (and ent (cdr ent)))
@end lisp

where @var{associator} is one of @code{assq}, @code{assv} or @code{assoc}.
@end deffn

assv-ref
@c snarfed from alist.c:216
@deffn {Scheme Procedure} assv-ref alist key
@deffnx {C Function} scm_assv_ref (alist, key)
Behaves like @code{assq-ref} but uses @code{eqv?} for key comparison.
@end deffn

assoc-ref
@c snarfed from alist.c:233
@deffn {Scheme Procedure} assoc-ref alist key
@deffnx {C Function} scm_assoc_ref (alist, key)
Behaves like @code{assq-ref} but uses @code{equal?} for key comparison.
@end deffn

assq-set!
@c snarfed from alist.c:262
@deffn {Scheme Procedure} assq-set! alist key val
@deffnx {Scheme Procedure} assv-set! alist key value
@deffnx {Scheme Procedure} assoc-set! alist key value
@deffnx {C Function} scm_assq_set_x (alist, key, val)
Reassociate @var{key} in @var{alist} with @var{value}: find any existing
@var{alist} entry for @var{key} and associate it with the new
@var{value}.  If @var{alist} does not contain an entry for @var{key},
add a new one.  Return the (possibly new) alist.

These functions do not attempt to verify the structure of @var{alist},
and so may cause unusual results if passed an object that is not an
association list.
@end deffn

assv-set!
@c snarfed from alist.c:280
@deffn {Scheme Procedure} assv-set! alist key val
@deffnx {C Function} scm_assv_set_x (alist, key, val)
Behaves like @code{assq-set!} but uses @code{eqv?} for key comparison.
@end deffn

assoc-set!
@c snarfed from alist.c:298
@deffn {Scheme Procedure} assoc-set! alist key val
@deffnx {C Function} scm_assoc_set_x (alist, key, val)
Behaves like @code{assq-set!} but uses @code{equal?} for key comparison.
@end deffn

assq-remove!
@c snarfed from alist.c:322
@deffn {Scheme Procedure} assq-remove! alist key
@deffnx {Scheme Procedure} assv-remove! alist key
@deffnx {Scheme Procedure} assoc-remove! alist key
@deffnx {C Function} scm_assq_remove_x (alist, key)
Delete the first entry in @var{alist} associated with @var{key}, and return
the resulting alist.
@end deffn

assv-remove!
@c snarfed from alist.c:338
@deffn {Scheme Procedure} assv-remove! alist key
@deffnx {C Function} scm_assv_remove_x (alist, key)
Behaves like @code{assq-remove!} but uses @code{eqv?} for key comparison.
@end deffn

assoc-remove!
@c snarfed from alist.c:354
@deffn {Scheme Procedure} assoc-remove! alist key
@deffnx {C Function} scm_assoc_remove_x (alist, key)
Behaves like @code{assq-remove!} but uses @code{equal?} for key comparison.
@end deffn

make-arbiter
@c snarfed from arbiters.c:99
@deffn {Scheme Procedure} make-arbiter name
@deffnx {C Function} scm_make_arbiter (name)
Return an arbiter object, initially unlocked.  Currently
@var{name} is only used for diagnostic output.
@end deffn

try-arbiter
@c snarfed from arbiters.c:116
@deffn {Scheme Procedure} try-arbiter arb
@deffnx {C Function} scm_try_arbiter (arb)
If @var{arb} is unlocked, then lock it and return @code{#t}.
If @var{arb} is already locked, then do nothing and return
@code{#f}.
@end deffn

release-arbiter
@c snarfed from arbiters.c:142
@deffn {Scheme Procedure} release-arbiter arb
@deffnx {C Function} scm_release_arbiter (arb)
If @var{arb} is locked, then unlock it and return @code{#t}.
If @var{arb} is already unlocked, then do nothing and return
@code{#f}.

Typical usage is for the thread which locked an arbiter to
later release it, but that's not required, any thread can
release it.
@end deffn

async
@c snarfed from async.c:97
@deffn {Scheme Procedure} async thunk
@deffnx {C Function} scm_async (thunk)
Create a new async for the procedure @var{thunk}.
@end deffn

async-mark
@c snarfed from async.c:106
@deffn {Scheme Procedure} async-mark a
@deffnx {C Function} scm_async_mark (a)
Mark the async @var{a} for future execution.
@end deffn

run-asyncs
@c snarfed from async.c:117
@deffn {Scheme Procedure} run-asyncs list_of_a
@deffnx {C Function} scm_run_asyncs (list_of_a)
Execute all thunks from the asyncs of the list @var{list_of_a}.
@end deffn

system-async
@c snarfed from async.c:180
@deffn {Scheme Procedure} system-async thunk
@deffnx {C Function} scm_system_async (thunk)
This function is deprecated.  You can use @var{thunk} directly
instead of explicitly creating an async object.

@end deffn

system-async-mark
@c snarfed from async.c:296
@deffn {Scheme Procedure} system-async-mark proc [thread]
@deffnx {C Function} scm_system_async_mark_for_thread (proc, thread)
Mark @var{proc} (a procedure with zero arguments) for future execution
in @var{thread}.  If @var{proc} has already been marked for
@var{thread} but has not been executed yet, this call has no effect.
If @var{thread} is omitted, the thread that called
@code{system-async-mark} is used.

This procedure is not safe to be called from C signal handlers.  Use
@code{scm_sigaction} or @code{scm_sigaction_for_thread} to install
signal handlers.
@end deffn

noop
@c snarfed from async.c:335
@deffn {Scheme Procedure} noop . args
@deffnx {C Function} scm_noop (args)
Do nothing.  When called without arguments, return @code{#f},
otherwise return the first argument.
@end deffn

unmask-signals
@c snarfed from async.c:350
@deffn {Scheme Procedure} unmask-signals
@deffnx {C Function} scm_unmask_signals ()
Unmask signals. The returned value is not specified.
@end deffn

mask-signals
@c snarfed from async.c:370
@deffn {Scheme Procedure} mask-signals
@deffnx {C Function} scm_mask_signals ()
Mask signals. The returned value is not specified.
@end deffn

call-with-blocked-asyncs
@c snarfed from async.c:404
@deffn {Scheme Procedure} call-with-blocked-asyncs proc
@deffnx {C Function} scm_call_with_blocked_asyncs (proc)
Call @var{proc} with no arguments and block the execution
of system asyncs by one level for the current thread while
it is running.  Return the value returned by @var{proc}.

@end deffn

call-with-unblocked-asyncs
@c snarfed from async.c:430
@deffn {Scheme Procedure} call-with-unblocked-asyncs proc
@deffnx {C Function} scm_call_with_unblocked_asyncs (proc)
Call @var{proc} with no arguments and unblock the execution
of system asyncs by one level for the current thread while
it is running.  Return the value returned by @var{proc}.

@end deffn

display-error
@c snarfed from backtrace.c:303
@deffn {Scheme Procedure} display-error stack port subr message args rest
@deffnx {C Function} scm_display_error (stack, port, subr, message, args, rest)
Display an error message to the output port @var{port}.
@var{stack} is the saved stack for the error, @var{subr} is
the name of the procedure in which the error occurred and
@var{message} is the actual error message, which may contain
formatting instructions. These will format the arguments in
the list @var{args} accordingly.  @var{rest} is currently
ignored.
@end deffn

display-application
@c snarfed from backtrace.c:425
@deffn {Scheme Procedure} display-application frame [port [indent]]
@deffnx {C Function} scm_display_application (frame, port, indent)
Display a procedure application @var{frame} to the output port
@var{port}. @var{indent} specifies the indentation of the
output.
@end deffn

display-backtrace
@c snarfed from backtrace.c:740
@deffn {Scheme Procedure} display-backtrace stack port [first [depth [highlights]]]
@deffnx {C Function} scm_display_backtrace_with_highlights (stack, port, first, depth, highlights)
Display a backtrace to the output port @var{port}. @var{stack}
is the stack to take the backtrace from, @var{first} specifies
where in the stack to start and @var{depth} how much frames
to display. Both @var{first} and @var{depth} can be @code{#f},
which means that default values will be used.
When @var{highlights} is given,
it should be a list and all members of it are highligthed in
the backtrace.
@end deffn

backtrace
@c snarfed from backtrace.c:776
@deffn {Scheme Procedure} backtrace [highlights]
@deffnx {C Function} scm_backtrace_with_highlights (highlights)
Display a backtrace of the stack saved by the last error
to the current output port.  When @var{highlights} is given,
it should be a list and all members of it are highligthed in
the backtrace.
@end deffn

not
@c snarfed from boolean.c:33
@deffn {Scheme Procedure} not x
@deffnx {C Function} scm_not (x)
Return @code{#t} iff @var{x} is @code{#f}, else return @code{#f}.
@end deffn

boolean?
@c snarfed from boolean.c:43
@deffn {Scheme Procedure} boolean? obj
@deffnx {C Function} scm_boolean_p (obj)
Return @code{#t} iff @var{obj} is either @code{#t} or @code{#f}.
@end deffn

char?
@c snarfed from chars.c:33
@deffn {Scheme Procedure} char? x
@deffnx {C Function} scm_char_p (x)
Return @code{#t} iff @var{x} is a character, else @code{#f}.
@end deffn

char=?
@c snarfed from chars.c:42
@deffn {Scheme Procedure} char=? x y
Return @code{#t} iff @var{x} is the same character as @var{y}, else @code{#f}.
@end deffn

char<?
@c snarfed from chars.c:55
@deffn {Scheme Procedure} char<? x y
Return @code{#t} iff @var{x} is less than @var{y} in the ASCII sequence,
else @code{#f}.
@end deffn

char<=?
@c snarfed from chars.c:67
@deffn {Scheme Procedure} char<=? x y
Return @code{#t} iff @var{x} is less than or equal to @var{y} in the
ASCII sequence, else @code{#f}.
@end deffn

char>?
@c snarfed from chars.c:79
@deffn {Scheme Procedure} char>? x y
Return @code{#t} iff @var{x} is greater than @var{y} in the ASCII
sequence, else @code{#f}.
@end deffn

char>=?
@c snarfed from chars.c:91
@deffn {Scheme Procedure} char>=? x y
Return @code{#t} iff @var{x} is greater than or equal to @var{y} in the
ASCII sequence, else @code{#f}.
@end deffn

char-ci=?
@c snarfed from chars.c:103
@deffn {Scheme Procedure} char-ci=? x y
Return @code{#t} iff @var{x} is the same character as @var{y} ignoring
case, else @code{#f}.
@end deffn

char-ci<?
@c snarfed from chars.c:115
@deffn {Scheme Procedure} char-ci<? x y
Return @code{#t} iff @var{x} is less than @var{y} in the ASCII sequence
ignoring case, else @code{#f}.
@end deffn

char-ci<=?
@c snarfed from chars.c:127
@deffn {Scheme Procedure} char-ci<=? x y
Return @code{#t} iff @var{x} is less than or equal to @var{y} in the
ASCII sequence ignoring case, else @code{#f}.
@end deffn

char-ci>?
@c snarfed from chars.c:139
@deffn {Scheme Procedure} char-ci>? x y
Return @code{#t} iff @var{x} is greater than @var{y} in the ASCII
sequence ignoring case, else @code{#f}.
@end deffn

char-ci>=?
@c snarfed from chars.c:151
@deffn {Scheme Procedure} char-ci>=? x y
Return @code{#t} iff @var{x} is greater than or equal to @var{y} in the
ASCII sequence ignoring case, else @code{#f}.
@end deffn

char-alphabetic?
@c snarfed from chars.c:163
@deffn {Scheme Procedure} char-alphabetic? chr
@deffnx {C Function} scm_char_alphabetic_p (chr)
Return @code{#t} iff @var{chr} is alphabetic, else @code{#f}.

@end deffn

char-numeric?
@c snarfed from chars.c:172
@deffn {Scheme Procedure} char-numeric? chr
@deffnx {C Function} scm_char_numeric_p (chr)
Return @code{#t} iff @var{chr} is numeric, else @code{#f}.

@end deffn

char-whitespace?
@c snarfed from chars.c:181
@deffn {Scheme Procedure} char-whitespace? chr
@deffnx {C Function} scm_char_whitespace_p (chr)
Return @code{#t} iff @var{chr} is whitespace, else @code{#f}.

@end deffn

char-upper-case?
@c snarfed from chars.c:192
@deffn {Scheme Procedure} char-upper-case? chr
@deffnx {C Function} scm_char_upper_case_p (chr)
Return @code{#t} iff @var{chr} is uppercase, else @code{#f}.

@end deffn

char-lower-case?
@c snarfed from chars.c:202
@deffn {Scheme Procedure} char-lower-case? chr
@deffnx {C Function} scm_char_lower_case_p (chr)
Return @code{#t} iff @var{chr} is lowercase, else @code{#f}.

@end deffn

char-is-both?
@c snarfed from chars.c:213
@deffn {Scheme Procedure} char-is-both? chr
@deffnx {C Function} scm_char_is_both_p (chr)
Return @code{#t} iff @var{chr} is either uppercase or lowercase, else @code{#f}.

@end deffn

char->integer
@c snarfed from chars.c:228
@deffn {Scheme Procedure} char->integer chr
@deffnx {C Function} scm_char_to_integer (chr)
Return the number corresponding to ordinal position of @var{chr} in the
ASCII sequence.
@end deffn

integer->char
@c snarfed from chars.c:240
@deffn {Scheme Procedure} integer->char n
@deffnx {C Function} scm_integer_to_char (n)
Return the character at position @var{n} in the ASCII sequence.
@end deffn

char-upcase
@c snarfed from chars.c:250
@deffn {Scheme Procedure} char-upcase chr
@deffnx {C Function} scm_char_upcase (chr)
Return the uppercase character version of @var{chr}.
@end deffn

char-downcase
@c snarfed from chars.c:261
@deffn {Scheme Procedure} char-downcase chr
@deffnx {C Function} scm_char_downcase (chr)
Return the lowercase character version of @var{chr}.
@end deffn

with-continuation-barrier
@c snarfed from continuations.c:412
@deffn {Scheme Procedure} with-continuation-barrier proc
@deffnx {C Function} scm_with_continuation_barrier (proc)
Call @var{proc} and return its result.  Do not allow the invocation of
continuations that would leave or enter the dynamic extent of the call
to @code{with-continuation-barrier}.  Such an attempt causes an error
to be signaled.

Throws (such as errors) that are not caught from within @var{proc} are
caught by @code{with-continuation-barrier}.  In that case, a short
message is printed to the current error port and @code{#f} is returned.

Thus, @code{with-continuation-barrier} returns exactly once.

@end deffn

debug-options-interface
@c snarfed from debug.c:54
@deffn {Scheme Procedure} debug-options-interface [setting]
@deffnx {C Function} scm_debug_options (setting)
Option interface for the debug options. Instead of using
this procedure directly, use the procedures @code{debug-enable},
@code{debug-disable}, @code{debug-set!} and @code{debug-options}.
@end deffn

with-traps
@c snarfed from debug.c:101
@deffn {Scheme Procedure} with-traps thunk
@deffnx {C Function} scm_with_traps (thunk)
Call @var{thunk} with traps enabled.
@end deffn

memoized?
@c snarfed from debug.c:139
@deffn {Scheme Procedure} memoized? obj
@deffnx {C Function} scm_memoized_p (obj)
Return @code{#t} if @var{obj} is memoized.
@end deffn

unmemoize-expr
@c snarfed from debug.c:271
@deffn {Scheme Procedure} unmemoize-expr m
@deffnx {C Function} scm_i_unmemoize_expr (m)
Unmemoize the memoized expression @var{m},
@end deffn

memoized-environment
@c snarfed from debug.c:281
@deffn {Scheme Procedure} memoized-environment m
@deffnx {C Function} scm_memoized_environment (m)
Return the environment of the memoized expression @var{m}.
@end deffn

procedure-name
@c snarfed from debug.c:291
@deffn {Scheme Procedure} procedure-name proc
@deffnx {C Function} scm_procedure_name (proc)
Return the name of the procedure @var{proc}
@end deffn

procedure-source
@c snarfed from debug.c:317
@deffn {Scheme Procedure} procedure-source proc
@deffnx {C Function} scm_procedure_source (proc)
Return the source of the procedure @var{proc}.
@end deffn

procedure-environment
@c snarfed from debug.c:374
@deffn {Scheme Procedure} procedure-environment proc
@deffnx {C Function} scm_procedure_environment (proc)
Return the environment of the procedure @var{proc}.
@end deffn

local-eval
@c snarfed from debug.c:406
@deffn {Scheme Procedure} local-eval exp [env]
@deffnx {C Function} scm_local_eval (exp, env)
Evaluate @var{exp} in its environment.  If @var{env} is supplied,
it is the environment in which to evaluate @var{exp}.  Otherwise,
@var{exp} must be a memoized code object (in which case, its environment
is implicit).
@end deffn

debug-object?
@c snarfed from debug.c:493
@deffn {Scheme Procedure} debug-object? obj
@deffnx {C Function} scm_debug_object_p (obj)
Return @code{#t} if @var{obj} is a debug object.
@end deffn

issue-deprecation-warning
@c snarfed from deprecation.c:99
@deffn {Scheme Procedure} issue-deprecation-warning . msgs
@deffnx {C Function} scm_issue_deprecation_warning (msgs)
Output @var{msgs} to @code{(current-error-port)} when this is the first call to @code{issue-deprecation-warning} with this specific @var{msgs}.  Do nothing otherwise. The argument @var{msgs} should be a list of strings; they are printed in turn, each one followed by a newline.
@end deffn

include-deprecated-features
@c snarfed from deprecation.c:144
@deffn {Scheme Procedure} include-deprecated-features
@deffnx {C Function} scm_include_deprecated_features ()
Return @code{#t} iff deprecated features should be included in public interfaces.
@end deffn

substring-move-left!
@c snarfed from deprecated.c:73
@deffn {Scheme Procedure} substring-move-left!
implemented by the C function "scm_substring_move_x"
@end deffn

substring-move-right!
@c snarfed from deprecated.c:75
@deffn {Scheme Procedure} substring-move-right!
implemented by the C function "scm_substring_move_x"
@end deffn

c-registered-modules
@c snarfed from deprecated.c:178
@deffn {Scheme Procedure} c-registered-modules
@deffnx {C Function} scm_registered_modules ()
Return a list of the object code modules that have been imported into
the current Guile process.  Each element of the list is a pair whose
car is the name of the module, and whose cdr is the function handle
for that module's initializer function.  The name is the string that
has been passed to scm_register_module_xxx.
@end deffn

c-clear-registered-modules
@c snarfed from deprecated.c:199
@deffn {Scheme Procedure} c-clear-registered-modules
@deffnx {C Function} scm_clear_registered_modules ()
Destroy the list of modules registered with the current Guile process.
The return value is unspecified.  @strong{Warning:} this function does
not actually unlink or deallocate these modules, but only destroys the
records of which modules have been loaded.  It should therefore be used
only by module bookkeeping operations.
@end deffn

close-all-ports-except
@c snarfed from deprecated.c:342
@deffn {Scheme Procedure} close-all-ports-except . ports
@deffnx {C Function} scm_close_all_ports_except (ports)
[DEPRECATED] Close all open file ports used by the interpreter
except for those supplied as arguments.  This procedure
was intended to be used before an exec call to close file descriptors
which are not needed in the new process.  However it has the
undesirable side effect of flushing buffers, so it's deprecated.
Use port-for-each instead.
@end deffn

variable-set-name-hint!
@c snarfed from deprecated.c:359
@deffn {Scheme Procedure} variable-set-name-hint! var hint
@deffnx {C Function} scm_variable_set_name_hint (var, hint)
Do not use this function.
@end deffn

builtin-variable
@c snarfed from deprecated.c:372
@deffn {Scheme Procedure} builtin-variable name
@deffnx {C Function} scm_builtin_variable (name)
Do not use this function.
@end deffn

sloppy-memq
@c snarfed from deprecated.c:446
@deffn {Scheme Procedure} sloppy-memq x lst
@deffnx {C Function} scm_sloppy_memq (x, lst)
This procedure behaves like @code{memq}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

sloppy-memv
@c snarfed from deprecated.c:466
@deffn {Scheme Procedure} sloppy-memv x lst
@deffnx {C Function} scm_sloppy_memv (x, lst)
This procedure behaves like @code{memv}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

sloppy-member
@c snarfed from deprecated.c:486
@deffn {Scheme Procedure} sloppy-member x lst
@deffnx {C Function} scm_sloppy_member (x, lst)
This procedure behaves like @code{member}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

read-and-eval!
@c snarfed from deprecated.c:508
@deffn {Scheme Procedure} read-and-eval! [port]
@deffnx {C Function} scm_read_and_eval_x (port)
Read a form from @var{port} (standard input by default), and evaluate it
(memoizing it in the process) in the top-level environment.  If no data
is left to be read from @var{port}, an @code{end-of-file} error is
signalled.
@end deffn

string->obarray-symbol
@c snarfed from deprecated.c:825
@deffn {Scheme Procedure} string->obarray-symbol o s [softp]
@deffnx {C Function} scm_string_to_obarray_symbol (o, s, softp)
Intern a new symbol in @var{obarray}, a symbol table, with name
@var{string}.

If @var{obarray} is @code{#f}, use the default system symbol table.  If
@var{obarray} is @code{#t}, the symbol should not be interned in any
symbol table; merely return the pair (@var{symbol}
. @var{#<undefined>}).

The @var{soft?} argument determines whether new symbol table entries
should be created when the specified symbol is not already present in
@var{obarray}.  If @var{soft?} is specified and is a true value, then
new entries should not be added for symbols not already present in the
table; instead, simply return @code{#f}.
@end deffn

intern-symbol
@c snarfed from deprecated.c:863
@deffn {Scheme Procedure} intern-symbol o s
@deffnx {C Function} scm_intern_symbol (o, s)
Add a new symbol to @var{obarray} with name @var{string}, bound to an
unspecified initial value.  The symbol table is not modified if a symbol
with this name is already present.
@end deffn

unintern-symbol
@c snarfed from deprecated.c:905
@deffn {Scheme Procedure} unintern-symbol o s
@deffnx {C Function} scm_unintern_symbol (o, s)
Remove the symbol with name @var{string} from @var{obarray}.  This
function returns @code{#t} if the symbol was present and @code{#f}
otherwise.
@end deffn

symbol-binding
@c snarfed from deprecated.c:950
@deffn {Scheme Procedure} symbol-binding o s
@deffnx {C Function} scm_symbol_binding (o, s)
Look up in @var{obarray} the symbol whose name is @var{string}, and
return the value to which it is bound.  If @var{obarray} is @code{#f},
use the global symbol table.  If @var{string} is not interned in
@var{obarray}, an error is signalled.
@end deffn

symbol-bound?
@c snarfed from deprecated.c:1003
@deffn {Scheme Procedure} symbol-bound? o s
@deffnx {C Function} scm_symbol_bound_p (o, s)
Return @code{#t} if @var{obarray} contains a symbol with name
@var{string} bound to a defined value.  This differs from
@var{symbol-interned?} in that the mere mention of a symbol
usually causes it to be interned; @code{symbol-bound?}
determines whether a symbol has been given any meaningful
value.
@end deffn

symbol-set!
@c snarfed from deprecated.c:1030
@deffn {Scheme Procedure} symbol-set! o s v
@deffnx {C Function} scm_symbol_set_x (o, s, v)
Find the symbol in @var{obarray} whose name is @var{string}, and rebind
it to @var{value}.  An error is signalled if @var{string} is not present
in @var{obarray}.
@end deffn

gentemp
@c snarfed from deprecated.c:1063
@deffn {Scheme Procedure} gentemp [prefix [obarray]]
@deffnx {C Function} scm_gentemp (prefix, obarray)
Create a new symbol with a name unique in an obarray.
The name is constructed from an optional string @var{prefix}
and a counter value.  The default prefix is @code{t}.  The
@var{obarray} is specified as a second optional argument.
Default is the system obarray where all normal symbols are
interned.  The counter is increased by 1 at each
call.  There is no provision for resetting the counter.
@end deffn

make-keyword-from-dash-symbol
@c snarfed from discouraged.c:161
@deffn {Scheme Procedure} make-keyword-from-dash-symbol symbol
@deffnx {C Function} scm_make_keyword_from_dash_symbol (symbol)
Make a keyword object from a @var{symbol} that starts with a dash.
@end deffn

keyword-dash-symbol
@c snarfed from discouraged.c:183
@deffn {Scheme Procedure} keyword-dash-symbol keyword
@deffnx {C Function} scm_keyword_dash_symbol (keyword)
Return the dash symbol for @var{keyword}.
This is the inverse of @code{make-keyword-from-dash-symbol}.
@end deffn

dynamic-link
@c snarfed from dynl.c:149
@deffn {Scheme Procedure} dynamic-link filename
@deffnx {C Function} scm_dynamic_link (filename)
Find the shared object (shared library) denoted by
@var{filename} and link it into the running Guile
application.  The returned
scheme object is a ``handle'' for the library which can
be passed to @code{dynamic-func}, @code{dynamic-call} etc.

Searching for object files is system dependent.  Normally,
if @var{filename} does have an explicit directory it will
be searched for in locations
such as @file{/usr/lib} and @file{/usr/local/lib}.
@end deffn

dynamic-object?
@c snarfed from dynl.c:168
@deffn {Scheme Procedure} dynamic-object? obj
@deffnx {C Function} scm_dynamic_object_p (obj)
Return @code{#t} if @var{obj} is a dynamic object handle,
or @code{#f} otherwise.
@end deffn

dynamic-unlink
@c snarfed from dynl.c:182
@deffn {Scheme Procedure} dynamic-unlink dobj
@deffnx {C Function} scm_dynamic_unlink (dobj)
Unlink a dynamic object from the application, if possible.  The
object must have been linked by @code{dynamic-link}, with 
@var{dobj} the corresponding handle.  After this procedure
is called, the handle can no longer be used to access the
object.
@end deffn

dynamic-func
@c snarfed from dynl.c:207
@deffn {Scheme Procedure} dynamic-func name dobj
@deffnx {C Function} scm_dynamic_func (name, dobj)
Return a ``handle'' for the function @var{name} in the
shared object referred to by @var{dobj}.  The handle
can be passed to @code{dynamic-call} to actually
call the function.

Regardless whether your C compiler prepends an underscore
@samp{_} to the global names in a program, you should
@strong{not} include this underscore in @var{name}
since it will be added automatically when necessary.
@end deffn

dynamic-call
@c snarfed from dynl.c:253
@deffn {Scheme Procedure} dynamic-call func dobj
@deffnx {C Function} scm_dynamic_call (func, dobj)
Call a C function in a dynamic object.  Two styles of
invocation are supported:

@itemize @bullet
@item @var{func} can be a function handle returned by
@code{dynamic-func}.  In this case @var{dobj} is
ignored
@item @var{func} can be a string with the name of the
function to call, with @var{dobj} the handle of the
dynamic object in which to find the function.
This is equivalent to
@smallexample

(dynamic-call (dynamic-func @var{func} @var{dobj}) #f)
@end smallexample
@end itemize

In either case, the function is passed no arguments
and its return value is ignored.
@end deffn

dynamic-args-call
@c snarfed from dynl.c:285
@deffn {Scheme Procedure} dynamic-args-call func dobj args
@deffnx {C Function} scm_dynamic_args_call (func, dobj, args)
Call the C function indicated by @var{func} and @var{dobj},
just like @code{dynamic-call}, but pass it some arguments and
return its return value.  The C function is expected to take
two arguments and return an @code{int}, just like @code{main}:
@smallexample
int c_func (int argc, char **argv);
@end smallexample

The parameter @var{args} must be a list of strings and is
converted into an array of @code{char *}.  The array is passed
in @var{argv} and its size in @var{argc}.  The return value is
converted to a Scheme number and returned from the call to
@code{dynamic-args-call}.
@end deffn

dynamic-wind
@c snarfed from dynwind.c:97
@deffn {Scheme Procedure} dynamic-wind in_guard thunk out_guard
@deffnx {C Function} scm_dynamic_wind (in_guard, thunk, out_guard)
All three arguments must be 0-argument procedures.
@var{in_guard} is called, then @var{thunk}, then
@var{out_guard}.

If, any time during the execution of @var{thunk}, the
continuation of the @code{dynamic_wind} expression is escaped
non-locally, @var{out_guard} is called.  If the continuation of
the dynamic-wind is re-entered, @var{in_guard} is called.  Thus
@var{in_guard} and @var{out_guard} may be called any number of
times.
@lisp
(define x 'normal-binding)
@result{} x
(define a-cont  (call-with-current-continuation
		  (lambda (escape)
		     (let ((old-x x))
		       (dynamic-wind
			  ;; in-guard:
			  ;;
			  (lambda () (set! x 'special-binding))

			  ;; thunk
			  ;;
		 	  (lambda () (display x) (newline)
				     (call-with-current-continuation escape)
				     (display x) (newline)
				     x)

			  ;; out-guard:
			  ;;
			  (lambda () (set! x old-x)))))))

;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont
x
@result{} normal-binding
(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont  ;; the value of the (define a-cont...)
x
@result{} normal-binding
a-cont
@result{} special-binding
@end lisp
@end deffn

environment?
@c snarfed from environments.c:106
@deffn {Scheme Procedure} environment? obj
@deffnx {C Function} scm_environment_p (obj)
Return @code{#t} if @var{obj} is an environment, or @code{#f}
otherwise.
@end deffn

environment-bound?
@c snarfed from environments.c:117
@deffn {Scheme Procedure} environment-bound? env sym
@deffnx {C Function} scm_environment_bound_p (env, sym)
Return @code{#t} if @var{sym} is bound in @var{env}, or
@code{#f} otherwise.
@end deffn

environment-ref
@c snarfed from environments.c:132
@deffn {Scheme Procedure} environment-ref env sym
@deffnx {C Function} scm_environment_ref (env, sym)
Return the value of the location bound to @var{sym} in
@var{env}. If @var{sym} is unbound in @var{env}, signal an
@code{environment:unbound} error.
@end deffn

environment-fold
@c snarfed from environments.c:202
@deffn {Scheme Procedure} environment-fold env proc init
@deffnx {C Function} scm_environment_fold (env, proc, init)
Iterate over all the bindings in @var{env}, accumulating some
value.
For each binding in @var{env}, apply @var{proc} to the symbol
bound, its value, and the result from the previous application
of @var{proc}.
Use @var{init} as @var{proc}'s third argument the first time
@var{proc} is applied.
If @var{env} contains no bindings, this function simply returns
@var{init}.
If @var{env} binds the symbol sym1 to the value val1, sym2 to
val2, and so on, then this procedure computes:
@lisp
  (proc sym1 val1
        (proc sym2 val2
              ...
              (proc symn valn
                    init)))
@end lisp
Each binding in @var{env} will be processed exactly once.
@code{environment-fold} makes no guarantees about the order in
which the bindings are processed.
Here is a function which, given an environment, constructs an
association list representing that environment's bindings,
using environment-fold:
@lisp
  (define (environment->alist env)
    (environment-fold env
                      (lambda (sym val tail)
                        (cons (cons sym val) tail))
                      '()))
@end lisp
@end deffn

environment-define
@c snarfed from environments.c:237
@deffn {Scheme Procedure} environment-define env sym val
@deffnx {C Function} scm_environment_define (env, sym, val)
Bind @var{sym} to a new location containing @var{val} in
@var{env}. If @var{sym} is already bound to another location
in @var{env} and the binding is mutable, that binding is
replaced.  The new binding and location are both mutable. The
return value is unspecified.
If @var{sym} is already bound in @var{env}, and the binding is
immutable, signal an @code{environment:immutable-binding} error.
@end deffn

environment-undefine
@c snarfed from environments.c:263
@deffn {Scheme Procedure} environment-undefine env sym
@deffnx {C Function} scm_environment_undefine (env, sym)
Remove any binding for @var{sym} from @var{env}. If @var{sym}
is unbound in @var{env}, do nothing.  The return value is
unspecified.
If @var{sym} is already bound in @var{env}, and the binding is
immutable, signal an @code{environment:immutable-binding} error.
@end deffn

environment-set!
@c snarfed from environments.c:291
@deffn {Scheme Procedure} environment-set! env sym val
@deffnx {C Function} scm_environment_set_x (env, sym, val)
If @var{env} binds @var{sym} to some location, change that
location's value to @var{val}.  The return value is
unspecified.
If @var{sym} is not bound in @var{env}, signal an
@code{environment:unbound} error.  If @var{env} binds @var{sym}
to an immutable location, signal an
@code{environment:immutable-location} error.
@end deffn

environment-cell
@c snarfed from environments.c:326
@deffn {Scheme Procedure} environment-cell env sym for_write
@deffnx {C Function} scm_environment_cell (env, sym, for_write)
Return the value cell which @var{env} binds to @var{sym}, or
@code{#f} if the binding does not live in a value cell.
The argument @var{for-write} indicates whether the caller
intends to modify the variable's value by mutating the value
cell.  If the variable is immutable, then
@code{environment-cell} signals an
@code{environment:immutable-location} error.
If @var{sym} is unbound in @var{env}, signal an
@code{environment:unbound} error.
If you use this function, you should consider using
@code{environment-observe}, to be notified when @var{sym} gets
re-bound to a new value cell, or becomes undefined.
@end deffn

environment-observe
@c snarfed from environments.c:378
@deffn {Scheme Procedure} environment-observe env proc
@deffnx {C Function} scm_environment_observe (env, proc)
Whenever @var{env}'s bindings change, apply @var{proc} to
@var{env}.
This function returns an object, token, which you can pass to
@code{environment-unobserve} to remove @var{proc} from the set
of procedures observing @var{env}.  The type and value of
token is unspecified.
@end deffn

environment-observe-weak
@c snarfed from environments.c:395
@deffn {Scheme Procedure} environment-observe-weak env proc
@deffnx {C Function} scm_environment_observe_weak (env, proc)
This function is the same as environment-observe, except that
the reference @var{env} retains to @var{proc} is a weak
reference. This means that, if there are no other live,
non-weak references to @var{proc}, it will be
garbage-collected, and dropped from @var{env}'s
list of observing procedures.
@end deffn

environment-unobserve
@c snarfed from environments.c:431
@deffn {Scheme Procedure} environment-unobserve token
@deffnx {C Function} scm_environment_unobserve (token)
Cancel the observation request which returned the value
@var{token}.  The return value is unspecified.
If a call @code{(environment-observe env proc)} returns
@var{token}, then the call @code{(environment-unobserve token)}
will cause @var{proc} to no longer be called when @var{env}'s
bindings change.
@end deffn

make-leaf-environment
@c snarfed from environments.c:1017
@deffn {Scheme Procedure} make-leaf-environment
@deffnx {C Function} scm_make_leaf_environment ()
Create a new leaf environment, containing no bindings.
All bindings and locations created in the new environment
will be mutable.
@end deffn

leaf-environment?
@c snarfed from environments.c:1040
@deffn {Scheme Procedure} leaf-environment? object
@deffnx {C Function} scm_leaf_environment_p (object)
Return @code{#t} if object is a leaf environment, or @code{#f}
otherwise.
@end deffn

make-eval-environment
@c snarfed from environments.c:1405
@deffn {Scheme Procedure} make-eval-environment local imported
@deffnx {C Function} scm_make_eval_environment (local, imported)
Return a new environment object eval whose bindings are the
union of the bindings in the environments @var{local} and
@var{imported}, with bindings from @var{local} taking
precedence. Definitions made in eval are placed in @var{local}.
Applying @code{environment-define} or
@code{environment-undefine} to eval has the same effect as
applying the procedure to @var{local}.
Note that eval incorporates @var{local} and @var{imported} by
reference:
If, after creating eval, the program changes the bindings of
@var{local} or @var{imported}, those changes will be visible
in eval.
Since most Scheme evaluation takes place in eval environments,
they transparently cache the bindings received from @var{local}
and @var{imported}. Thus, the first time the program looks up
a symbol in eval, eval may make calls to @var{local} or
@var{imported} to find their bindings, but subsequent
references to that symbol will be as fast as references to
bindings in finite environments.
In typical use, @var{local} will be a finite environment, and
@var{imported} will be an import environment
@end deffn

eval-environment?
@c snarfed from environments.c:1442
@deffn {Scheme Procedure} eval-environment? object
@deffnx {C Function} scm_eval_environment_p (object)
Return @code{#t} if object is an eval environment, or @code{#f}
otherwise.
@end deffn

eval-environment-local
@c snarfed from environments.c:1452
@deffn {Scheme Procedure} eval-environment-local env
@deffnx {C Function} scm_eval_environment_local (env)
Return the local environment of eval environment @var{env}.
@end deffn

eval-environment-set-local!
@c snarfed from environments.c:1464
@deffn {Scheme Procedure} eval-environment-set-local! env local
@deffnx {C Function} scm_eval_environment_set_local_x (env, local)
Change @var{env}'s local environment to @var{local}.
@end deffn

eval-environment-imported
@c snarfed from environments.c:1490
@deffn {Scheme Procedure} eval-environment-imported env
@deffnx {C Function} scm_eval_environment_imported (env)
Return the imported environment of eval environment @var{env}.
@end deffn

eval-environment-set-imported!
@c snarfed from environments.c:1502
@deffn {Scheme Procedure} eval-environment-set-imported! env imported
@deffnx {C Function} scm_eval_environment_set_imported_x (env, imported)
Change @var{env}'s imported environment to @var{imported}.
@end deffn

make-import-environment
@c snarfed from environments.c:1825
@deffn {Scheme Procedure} make-import-environment imports conflict_proc
@deffnx {C Function} scm_make_import_environment (imports, conflict_proc)
Return a new environment @var{imp} whose bindings are the union
of the bindings from the environments in @var{imports};
@var{imports} must be a list of environments. That is,
@var{imp} binds a symbol to a location when some element of
@var{imports} does.
If two different elements of @var{imports} have a binding for
the same symbol, the @var{conflict-proc} is called with the
following parameters:  the import environment, the symbol and
the list of the imported environments that bind the symbol.
If the @var{conflict-proc} returns an environment @var{env},
the conflict is considered as resolved and the binding from
@var{env} is used.  If the @var{conflict-proc} returns some
non-environment object, the conflict is considered unresolved
and the symbol is treated as unspecified in the import
environment.
The checking for conflicts may be performed lazily, i. e. at
the moment when a value or binding for a certain symbol is
requested instead of the moment when the environment is
created or the bindings of the imports change.
All bindings in @var{imp} are immutable. If you apply
@code{environment-define} or @code{environment-undefine} to
@var{imp}, Guile will signal an
 @code{environment:immutable-binding} error. However,
notice that the set of bindings in @var{imp} may still change,
if one of its imported environments changes.
@end deffn

import-environment?
@c snarfed from environments.c:1854
@deffn {Scheme Procedure} import-environment? object
@deffnx {C Function} scm_import_environment_p (object)
Return @code{#t} if object is an import environment, or
@code{#f} otherwise.
@end deffn

import-environment-imports
@c snarfed from environments.c:1865
@deffn {Scheme Procedure} import-environment-imports env
@deffnx {C Function} scm_import_environment_imports (env)
Return the list of environments imported by the import
environment @var{env}.
@end deffn

import-environment-set-imports!
@c snarfed from environments.c:1878
@deffn {Scheme Procedure} import-environment-set-imports! env imports
@deffnx {C Function} scm_import_environment_set_imports_x (env, imports)
Change @var{env}'s list of imported environments to
@var{imports}, and check for conflicts.
@end deffn

make-export-environment
@c snarfed from environments.c:2145
@deffn {Scheme Procedure} make-export-environment private signature
@deffnx {C Function} scm_make_export_environment (private, signature)
Return a new environment @var{exp} containing only those
bindings in private whose symbols are present in
@var{signature}. The @var{private} argument must be an
environment.

The environment @var{exp} binds symbol to location when
@var{env} does, and symbol is exported by @var{signature}.

@var{signature} is a list specifying which of the bindings in
@var{private} should be visible in @var{exp}. Each element of
@var{signature} should be a list of the form:
  (symbol attribute ...)
where each attribute is one of the following:
@table @asis
@item the symbol @code{mutable-location}
  @var{exp} should treat the
  location bound to symbol as mutable. That is, @var{exp}
  will pass calls to @code{environment-set!} or
  @code{environment-cell} directly through to private.
@item the symbol @code{immutable-location}
  @var{exp} should treat
  the location bound to symbol as immutable. If the program
  applies @code{environment-set!} to @var{exp} and symbol, or
  calls @code{environment-cell} to obtain a writable value
  cell, @code{environment-set!} will signal an
  @code{environment:immutable-location} error. Note that, even
  if an export environment treats a location as immutable, the
  underlying environment may treat it as mutable, so its
  value may change.
@end table
It is an error for an element of signature to specify both
@code{mutable-location} and @code{immutable-location}. If
neither is specified, @code{immutable-location} is assumed.

As a special case, if an element of signature is a lone
symbol @var{sym}, it is equivalent to an element of the form
@code{(sym)}.

All bindings in @var{exp} are immutable. If you apply
@code{environment-define} or @code{environment-undefine} to
@var{exp}, Guile will signal an
@code{environment:immutable-binding} error. However,
notice that the set of bindings in @var{exp} may still change,
if the bindings in private change.
@end deffn

export-environment?
@c snarfed from environments.c:2180
@deffn {Scheme Procedure} export-environment? object
@deffnx {C Function} scm_export_environment_p (object)
Return @code{#t} if object is an export environment, or
@code{#f} otherwise.
@end deffn

export-environment-private
@c snarfed from environments.c:2190
@deffn {Scheme Procedure} export-environment-private env
@deffnx {C Function} scm_export_environment_private (env)
Return the private environment of export environment @var{env}.
@end deffn

export-environment-set-private!
@c snarfed from environments.c:2202
@deffn {Scheme Procedure} export-environment-set-private! env private
@deffnx {C Function} scm_export_environment_set_private_x (env, private)
Change the private environment of export environment @var{env}.
@end deffn

export-environment-signature
@c snarfed from environments.c:2224
@deffn {Scheme Procedure} export-environment-signature env
@deffnx {C Function} scm_export_environment_signature (env)
Return the signature of export environment @var{env}.
@end deffn

export-environment-set-signature!
@c snarfed from environments.c:2298
@deffn {Scheme Procedure} export-environment-set-signature! env signature
@deffnx {C Function} scm_export_environment_set_signature_x (env, signature)
Change the signature of export environment @var{env}.
@end deffn

eq?
@c snarfed from eq.c:81
@deffn {Scheme Procedure} eq? x y
Return @code{#t} if @var{x} and @var{y} are the same object,
except for numbers and characters.  For example,

@example
(define x (vector 1 2 3))
(define y (vector 1 2 3))

(eq? x x)  @result{} #t
(eq? x y)  @result{} #f
@end example

Numbers and characters are not equal to any other object, but
the problem is they're not necessarily @code{eq?} to themselves
either.  This is even so when the number comes directly from a
variable,

@example
(let ((n (+ 2 3)))
  (eq? n n))       @result{} *unspecified*
@end example

Generally @code{eqv?} should be used when comparing numbers or
characters.  @code{=} or @code{char=?} can be used too.

It's worth noting that end-of-list @code{()}, @code{#t},
@code{#f}, a symbol of a given name, and a keyword of a given
name, are unique objects.  There's just one of each, so for
instance no matter how @code{()} arises in a program, it's the
same object and can be compared with @code{eq?},

@example
(define x (cdr '(123)))
(define y (cdr '(456)))
(eq? x y) @result{} #t

(define x (string->symbol "foo"))
(eq? x 'foo) @result{} #t
@end example
@end deffn

eqv?
@c snarfed from eq.c:116
@deffn {Scheme Procedure} eqv? x y
Return @code{#t} if @var{x} and @var{y} are the same object, or
for characters and numbers the same value.

On objects except characters and numbers, @code{eqv?} is the
same as @code{eq?}, it's true if @var{x} and @var{y} are the
same object.

If @var{x} and @var{y} are numbers or characters, @code{eqv?}
compares their type and value.  An exact number is not
@code{eqv?} to an inexact number (even if their value is the
same).

@example
(eqv? 3 (+ 1 2)) @result{} #t
(eqv? 1 1.0)     @result{} #f
@end example
@end deffn

equal?
@c snarfed from eq.c:212
@deffn {Scheme Procedure} equal? x y
Return @code{#t} if @var{x} and @var{y} are the same type, and
their contents or value are equal.

For a pair, string, vector or array, @code{equal?} compares the
contents, and does so using using the same @code{equal?}
recursively, so a deep structure can be traversed.

@example
(equal? (list 1 2 3) (list 1 2 3))   @result{} #t
(equal? (list 1 2 3) (vector 1 2 3)) @result{} #f
@end example

For other objects, @code{equal?} compares as per @code{eqv?},
which means characters and numbers are compared by type and
value (and like @code{eqv?}, exact and inexact numbers are not
@code{equal?}, even if their value is the same).

@example
(equal? 3 (+ 1 2)) @result{} #t
(equal? 1 1.0)     @result{} #f
@end example

Hash tables are currently only compared as per @code{eq?}, so
two different tables are not @code{equal?}, even if their
contents are the same.

@code{equal?} does not support circular data structures, it may
go into an infinite loop if asked to compare two circular lists
or similar.

New application-defined object types (Smobs) have an
@code{equalp} handler which is called by @code{equal?}.  This
lets an application traverse the contents or control what is
considered @code{equal?} for two such objects.  If there's no
handler, the default is to just compare as per @code{eq?}.
@end deffn

scm-error
@c snarfed from error.c:82
@deffn {Scheme Procedure} scm-error key subr message args data
@deffnx {C Function} scm_error_scm (key, subr, message, args, data)
Raise an error with key @var{key}.  @var{subr} can be a string
naming the procedure associated with the error, or @code{#f}.
@var{message} is the error message string, possibly containing
@code{~S} and @code{~A} escapes.  When an error is reported,
these are replaced by formatting the corresponding members of
@var{args}: @code{~A} (was @code{%s} in older versions of
Guile) formats using @code{display} and @code{~S} (was
@code{%S}) formats using @code{write}.  @var{data} is a list or
@code{#f} depending on @var{key}: if @var{key} is
@code{system-error} then it should be a list containing the
Unix @code{errno} value; If @var{key} is @code{signal} then it
should be a list containing the Unix signal number; If
@var{key} is @code{out-of-range} or @code{wrong-type-arg},
it is a list containing the bad value; otherwise
it will usually be @code{#f}.
@end deffn

strerror
@c snarfed from error.c:129
@deffn {Scheme Procedure} strerror err
@deffnx {C Function} scm_strerror (err)
Return the Unix error message corresponding to @var{err}, which
must be an integer value.
@end deffn

apply:nconc2last
@c snarfed from eval.c:4686
@deffn {Scheme Procedure} apply:nconc2last lst
@deffnx {C Function} scm_nconc2last (lst)
Given a list (@var{arg1} @dots{} @var{args}), this function
conses the @var{arg1} @dots{} arguments onto the front of
@var{args}, and returns the resulting list. Note that
@var{args} is a list; thus, the argument to this function is
a list whose last element is a list.
Note: Rather than do new consing, @code{apply:nconc2last}
destroys its argument, so use with care.
@end deffn

force
@c snarfed from eval.c:5598
@deffn {Scheme Procedure} force promise
@deffnx {C Function} scm_force (promise)
If the promise @var{x} has not been computed yet, compute and
return @var{x}, otherwise just return the previously computed
value.
@end deffn

promise?
@c snarfed from eval.c:5621
@deffn {Scheme Procedure} promise? obj
@deffnx {C Function} scm_promise_p (obj)
Return true if @var{obj} is a promise, i.e. a delayed computation
(@pxref{Delayed evaluation,,,r5rs.info,The Revised^5 Report on Scheme}).
@end deffn

cons-source
@c snarfed from eval.c:5633
@deffn {Scheme Procedure} cons-source xorig x y
@deffnx {C Function} scm_cons_source (xorig, x, y)
Create and return a new pair whose car and cdr are @var{x} and @var{y}.
Any source properties associated with @var{xorig} are also associated
with the new pair.
@end deffn

copy-tree
@c snarfed from eval.c:5790
@deffn {Scheme Procedure} copy-tree obj
@deffnx {C Function} scm_copy_tree (obj)
Recursively copy the data tree that is bound to @var{obj}, and return a
the new data structure.  @code{copy-tree} recurses down the
contents of both pairs and vectors (since both cons cells and vector
cells may point to arbitrary objects), and stops recursing when it hits
any other object.
@end deffn

primitive-eval
@c snarfed from eval.c:5878
@deffn {Scheme Procedure} primitive-eval exp
@deffnx {C Function} scm_primitive_eval (exp)
Evaluate @var{exp} in the top-level environment specified by
the current module.
@end deffn

eval
@c snarfed from eval.c:5922
@deffn {Scheme Procedure} eval exp module_or_state
@deffnx {C Function} scm_eval (exp, module_or_state)
Evaluate @var{exp}, a list representing a Scheme expression,
in the top-level environment specified by
@var{module_or_state}.
While @var{exp} is evaluated (using @code{primitive-eval}),
@var{module_or_state} is made the current module when
it is a module, or the current dynamic state when it is
a dynamic state.Example: (eval '(+ 1 2) (interaction-environment))
@end deffn

eval-options-interface
@c snarfed from eval.c:3086
@deffn {Scheme Procedure} eval-options-interface [setting]
@deffnx {C Function} scm_eval_options_interface (setting)
Option interface for the evaluation options. Instead of using
this procedure directly, use the procedures @code{eval-enable},
@code{eval-disable}, @code{eval-set!} and @code{eval-options}.
@end deffn

evaluator-traps-interface
@c snarfed from eval.c:3104
@deffn {Scheme Procedure} evaluator-traps-interface [setting]
@deffnx {C Function} scm_evaluator_traps (setting)
Option interface for the evaluator trap options.
@end deffn

defined?
@c snarfed from evalext.c:34
@deffn {Scheme Procedure} defined? sym [env]
@deffnx {C Function} scm_defined_p (sym, env)
Return @code{#t} if @var{sym} is defined in the lexical environment @var{env}.  When @var{env} is not specified, look in the top-level environment as defined by the current module.
@end deffn

map-in-order
@c snarfed from evalext.c:80
@deffn {Scheme Procedure} map-in-order
implemented by the C function "scm_map"
@end deffn

self-evaluating?
@c snarfed from evalext.c:85
@deffn {Scheme Procedure} self-evaluating? obj
@deffnx {C Function} scm_self_evaluating_p (obj)
Return #t for objects which Guile considers self-evaluating
@end deffn

load-extension
@c snarfed from extensions.c:143
@deffn {Scheme Procedure} load-extension lib init
@deffnx {C Function} scm_load_extension (lib, init)
Load and initialize the extension designated by LIB and INIT.
When there is no pre-registered function for LIB/INIT, this is
equivalent to

@lisp
(dynamic-call INIT (dynamic-link LIB))
@end lisp

When there is a pre-registered function, that function is called
instead.

Normally, there is no pre-registered function.  This option exists
only for situations where dynamic linking is unavailable or unwanted.
In that case, you would statically link your program with the desired
library, and register its init function right after Guile has been
initialized.

LIB should be a string denoting a shared library without any file type
suffix such as ".so".  The suffix is provided automatically.  It
should also not contain any directory components.  Libraries that
implement Guile Extensions should be put into the normal locations for
shared libraries.  We recommend to use the naming convention
libguile-bla-blum for a extension related to a module `(bla blum)'.

The normal way for a extension to be used is to write a small Scheme
file that defines a module, and to load the extension into this
module.  When the module is auto-loaded, the extension is loaded as
well.  For example,

@lisp
(define-module (bla blum))

(load-extension "libguile-bla-blum" "bla_init_blum")
@end lisp
@end deffn

program-arguments
@c snarfed from feature.c:57
@deffn {Scheme Procedure} program-arguments
@deffnx {Scheme Procedure} command-line
@deffnx {C Function} scm_program_arguments ()
Return the list of command line arguments passed to Guile, as a list of
strings.  The list includes the invoked program name, which is usually
@code{"guile"}, but excludes switches and parameters for command line
options like @code{-e} and @code{-l}.
@end deffn

make-fluid
@c snarfed from fluids.c:260
@deffn {Scheme Procedure} make-fluid
@deffnx {C Function} scm_make_fluid ()
Return a newly created fluid.
Fluids are objects that can hold one
value per dynamic state.  That is, modifications to this value are
only visible to code that executes with the same dynamic state as
the modifying code.  When a new dynamic state is constructed, it
inherits the values from its parent.  Because each thread normally executes
with its own dynamic state, you can use fluids for thread local storage.
@end deffn

fluid?
@c snarfed from fluids.c:283
@deffn {Scheme Procedure} fluid? obj
@deffnx {C Function} scm_fluid_p (obj)
Return @code{#t} iff @var{obj} is a fluid; otherwise, return
@code{#f}.
@end deffn

fluid-ref
@c snarfed from fluids.c:306
@deffn {Scheme Procedure} fluid-ref fluid
@deffnx {C Function} scm_fluid_ref (fluid)
Return the value associated with @var{fluid} in the current
dynamic root.  If @var{fluid} has not been set, then return
@code{#f}.
@end deffn

fluid-set!
@c snarfed from fluids.c:325
@deffn {Scheme Procedure} fluid-set! fluid value
@deffnx {C Function} scm_fluid_set_x (fluid, value)
Set the value associated with @var{fluid} in the current dynamic root.
@end deffn

with-fluids*
@c snarfed from fluids.c:395
@deffn {Scheme Procedure} with-fluids* fluids values thunk
@deffnx {C Function} scm_with_fluids (fluids, values, thunk)
Set @var{fluids} to @var{values} temporary, and call @var{thunk}.
@var{fluids} must be a list of fluids and @var{values} must be the same
number of their values to be applied.  Each substitution is done
one after another.  @var{thunk} must be a procedure with no argument.
@end deffn

with-fluid*
@c snarfed from fluids.c:434
@deffn {Scheme Procedure} with-fluid* fluid value thunk
@deffnx {C Function} scm_with_fluid (fluid, value, thunk)
Set @var{fluid} to @var{value} temporarily, and call @var{thunk}.
@var{thunk} must be a procedure with no argument.
@end deffn

make-dynamic-state
@c snarfed from fluids.c:487
@deffn {Scheme Procedure} make-dynamic-state [parent]
@deffnx {C Function} scm_make_dynamic_state (parent)
Return a copy of the dynamic state object @var{parent}
or of the current dynamic state when @var{parent} is omitted.
@end deffn

dynamic-state?
@c snarfed from fluids.c:515
@deffn {Scheme Procedure} dynamic-state? obj
@deffnx {C Function} scm_dynamic_state_p (obj)
Return @code{#t} if @var{obj} is a dynamic state object;
return @code{#f} otherwise
@end deffn

current-dynamic-state
@c snarfed from fluids.c:530
@deffn {Scheme Procedure} current-dynamic-state
@deffnx {C Function} scm_current_dynamic_state ()
Return the current dynamic state object.
@end deffn

set-current-dynamic-state
@c snarfed from fluids.c:540
@deffn {Scheme Procedure} set-current-dynamic-state state
@deffnx {C Function} scm_set_current_dynamic_state (state)
Set the current dynamic state object to @var{state}
and return the previous current dynamic state object.
@end deffn

with-dynamic-state
@c snarfed from fluids.c:582
@deffn {Scheme Procedure} with-dynamic-state state proc
@deffnx {C Function} scm_with_dynamic_state (state, proc)
Call @var{proc} while @var{state} is the current dynamic
state object.
@end deffn

setvbuf
@c snarfed from fports.c:137
@deffn {Scheme Procedure} setvbuf port mode [size]
@deffnx {C Function} scm_setvbuf (port, mode, size)
Set the buffering mode for @var{port}.  @var{mode} can be:
@table @code
@item _IONBF
non-buffered
@item _IOLBF
line buffered
@item _IOFBF
block buffered, using a newly allocated buffer of @var{size} bytes.
If @var{size} is omitted, a default size will be used.
@end table
@end deffn

file-port?
@c snarfed from fports.c:230
@deffn {Scheme Procedure} file-port? obj
@deffnx {C Function} scm_file_port_p (obj)
Determine whether @var{obj} is a port that is related to a file.
@end deffn

open-file
@c snarfed from fports.c:284
@deffn {Scheme Procedure} open-file filename mode
@deffnx {C Function} scm_open_file (filename, mode)
Open the file whose name is @var{filename}, and return a port
representing that file.  The attributes of the port are
determined by the @var{mode} string.  The way in which this is
interpreted is similar to C stdio.  The first character must be
one of the following:
@table @samp
@item r
Open an existing file for input.
@item w
Open a file for output, creating it if it doesn't already exist
or removing its contents if it does.
@item a
Open a file for output, creating it if it doesn't already
exist.  All writes to the port will go to the end of the file.
The "append mode" can be turned off while the port is in use
@pxref{Ports and File Descriptors, fcntl}
@end table
The following additional characters can be appended:
@table @samp
@item +
Open the port for both input and output.  E.g., @code{r+}: open
an existing file for both input and output.
@item 0
Create an "unbuffered" port.  In this case input and output
operations are passed directly to the underlying port
implementation without additional buffering.  This is likely to
slow down I/O operations.  The buffering mode can be changed
while a port is in use @pxref{Ports and File Descriptors,
setvbuf}
@item l
Add line-buffering to the port.  The port output buffer will be
automatically flushed whenever a newline character is written.
@end table
In theory we could create read/write ports which were buffered
in one direction only.  However this isn't included in the
current interfaces.  If a file cannot be opened with the access
requested, @code{open-file} throws an exception.
@end deffn

gc-live-object-stats
@c snarfed from gc.c:276
@deffn {Scheme Procedure} gc-live-object-stats
@deffnx {C Function} scm_gc_live_object_stats ()
Return an alist of statistics of the current live objects. 
@end deffn

gc-stats
@c snarfed from gc.c:293
@deffn {Scheme Procedure} gc-stats
@deffnx {C Function} scm_gc_stats ()
Return an association list of statistics about Guile's current
use of storage.

@end deffn

object-address
@c snarfed from gc.c:429
@deffn {Scheme Procedure} object-address obj
@deffnx {C Function} scm_object_address (obj)
Return an integer that for the lifetime of @var{obj} is uniquely
returned by this function for @var{obj}
@end deffn

gc
@c snarfed from gc.c:440
@deffn {Scheme Procedure} gc
@deffnx {C Function} scm_gc ()
Scans all of SCM objects and reclaims for further use those that are
no longer accessible.
@end deffn

class-of
@c snarfed from goops.c:166
@deffn {Scheme Procedure} class-of x
@deffnx {C Function} scm_class_of (x)
Return the class of @var{x}.
@end deffn

%compute-slots
@c snarfed from goops.c:407
@deffn {Scheme Procedure} %compute-slots class
@deffnx {C Function} scm_sys_compute_slots (class)
Return a list consisting of the names of all slots belonging to
class @var{class}, i. e. the slots of @var{class} and of all of
its superclasses.
@end deffn

get-keyword
@c snarfed from goops.c:498
@deffn {Scheme Procedure} get-keyword key l default_value
@deffnx {C Function} scm_get_keyword (key, l, default_value)
Determine an associated value for the keyword @var{key} from
the list @var{l}.  The list @var{l} has to consist of an even
number of elements, where, starting with the first, every
second element is a keyword, followed by its associated value.
If @var{l} does not hold a value for @var{key}, the value
@var{default_value} is returned.
@end deffn

%initialize-object
@c snarfed from goops.c:521
@deffn {Scheme Procedure} %initialize-object obj initargs
@deffnx {C Function} scm_sys_initialize_object (obj, initargs)
Initialize the object @var{obj} with the given arguments
@var{initargs}.
@end deffn

%prep-layout!
@c snarfed from goops.c:619
@deffn {Scheme Procedure} %prep-layout! class
@deffnx {C Function} scm_sys_prep_layout_x (class)

@end deffn

%inherit-magic!
@c snarfed from goops.c:718
@deffn {Scheme Procedure} %inherit-magic! class dsupers
@deffnx {C Function} scm_sys_inherit_magic_x (class, dsupers)

@end deffn

instance?
@c snarfed from goops.c:958
@deffn {Scheme Procedure} instance? obj
@deffnx {C Function} scm_instance_p (obj)
Return @code{#t} if @var{obj} is an instance.
@end deffn

class-name
@c snarfed from goops.c:973
@deffn {Scheme Procedure} class-name obj
@deffnx {C Function} scm_class_name (obj)
Return the class name of @var{obj}.
@end deffn

class-direct-supers
@c snarfed from goops.c:983
@deffn {Scheme Procedure} class-direct-supers obj
@deffnx {C Function} scm_class_direct_supers (obj)
Return the direct superclasses of the class @var{obj}.
@end deffn

class-direct-slots
@c snarfed from goops.c:993
@deffn {Scheme Procedure} class-direct-slots obj
@deffnx {C Function} scm_class_direct_slots (obj)
Return the direct slots of the class @var{obj}.
@end deffn

class-direct-subclasses
@c snarfed from goops.c:1003
@deffn {Scheme Procedure} class-direct-subclasses obj
@deffnx {C Function} scm_class_direct_subclasses (obj)
Return the direct subclasses of the class @var{obj}.
@end deffn

class-direct-methods
@c snarfed from goops.c:1013
@deffn {Scheme Procedure} class-direct-methods obj
@deffnx {C Function} scm_class_direct_methods (obj)
Return the direct methods of the class @var{obj}
@end deffn

class-precedence-list
@c snarfed from goops.c:1023
@deffn {Scheme Procedure} class-precedence-list obj
@deffnx {C Function} scm_class_precedence_list (obj)
Return the class precedence list of the class @var{obj}.
@end deffn

class-slots
@c snarfed from goops.c:1033
@deffn {Scheme Procedure} class-slots obj
@deffnx {C Function} scm_class_slots (obj)
Return the slot list of the class @var{obj}.
@end deffn

class-environment
@c snarfed from goops.c:1043
@deffn {Scheme Procedure} class-environment obj
@deffnx {C Function} scm_class_environment (obj)
Return the environment of the class @var{obj}.
@end deffn

generic-function-name
@c snarfed from goops.c:1054
@deffn {Scheme Procedure} generic-function-name obj
@deffnx {C Function} scm_generic_function_name (obj)
Return the name of the generic function @var{obj}.
@end deffn

generic-function-methods
@c snarfed from goops.c:1099
@deffn {Scheme Procedure} generic-function-methods obj
@deffnx {C Function} scm_generic_function_methods (obj)
Return the methods of the generic function @var{obj}.
@end deffn

method-generic-function
@c snarfed from goops.c:1112
@deffn {Scheme Procedure} method-generic-function obj
@deffnx {C Function} scm_method_generic_function (obj)
Return the generic function for the method @var{obj}.
@end deffn

method-specializers
@c snarfed from goops.c:1122
@deffn {Scheme Procedure} method-specializers obj
@deffnx {C Function} scm_method_specializers (obj)
Return specializers of the method @var{obj}.
@end deffn

method-procedure
@c snarfed from goops.c:1132
@deffn {Scheme Procedure} method-procedure obj
@deffnx {C Function} scm_method_procedure (obj)
Return the procedure of the method @var{obj}.
@end deffn

accessor-method-slot-definition
@c snarfed from goops.c:1142
@deffn {Scheme Procedure} accessor-method-slot-definition obj
@deffnx {C Function} scm_accessor_method_slot_definition (obj)
Return the slot definition of the accessor @var{obj}.
@end deffn

%tag-body
@c snarfed from goops.c:1152
@deffn {Scheme Procedure} %tag-body body
@deffnx {C Function} scm_sys_tag_body (body)
Internal GOOPS magic---don't use this function!
@end deffn

make-unbound
@c snarfed from goops.c:1167
@deffn {Scheme Procedure} make-unbound
@deffnx {C Function} scm_make_unbound ()
Return the unbound value.
@end deffn

unbound?
@c snarfed from goops.c:1176
@deffn {Scheme Procedure} unbound? obj
@deffnx {C Function} scm_unbound_p (obj)
Return @code{#t} if @var{obj} is unbound.
@end deffn

assert-bound
@c snarfed from goops.c:1186
@deffn {Scheme Procedure} assert-bound value obj
@deffnx {C Function} scm_assert_bound (value, obj)
Return @var{value} if it is bound, and invoke the
@var{slot-unbound} method of @var{obj} if it is not.
@end deffn

@@assert-bound-ref
@c snarfed from goops.c:1198
@deffn {Scheme Procedure} @@assert-bound-ref obj index
@deffnx {C Function} scm_at_assert_bound_ref (obj, index)
Like @code{assert-bound}, but use @var{index} for accessing
the value from @var{obj}.
@end deffn

%fast-slot-ref
@c snarfed from goops.c:1210
@deffn {Scheme Procedure} %fast-slot-ref obj index
@deffnx {C Function} scm_sys_fast_slot_ref (obj, index)
Return the slot value with index @var{index} from @var{obj}.
@end deffn

%fast-slot-set!
@c snarfed from goops.c:1224
@deffn {Scheme Procedure} %fast-slot-set! obj index value
@deffnx {C Function} scm_sys_fast_slot_set_x (obj, index, value)
Set the slot with index @var{index} in @var{obj} to
@var{value}.
@end deffn

slot-ref-using-class
@c snarfed from goops.c:1361
@deffn {Scheme Procedure} slot-ref-using-class class obj slot_name
@deffnx {C Function} scm_slot_ref_using_class (class, obj, slot_name)

@end deffn

slot-set-using-class!
@c snarfed from goops.c:1380
@deffn {Scheme Procedure} slot-set-using-class! class obj slot_name value
@deffnx {C Function} scm_slot_set_using_class_x (class, obj, slot_name, value)

@end deffn

slot-bound-using-class?
@c snarfed from goops.c:1394
@deffn {Scheme Procedure} slot-bound-using-class? class obj slot_name
@deffnx {C Function} scm_slot_bound_using_class_p (class, obj, slot_name)

@end deffn

slot-exists-using-class?
@c snarfed from goops.c:1409
@deffn {Scheme Procedure} slot-exists-using-class? class obj slot_name
@deffnx {C Function} scm_slot_exists_using_class_p (class, obj, slot_name)

@end deffn

slot-ref
@c snarfed from goops.c:1425
@deffn {Scheme Procedure} slot-ref obj slot_name
@deffnx {C Function} scm_slot_ref (obj, slot_name)
Return the value from @var{obj}'s slot with the name
@var{slot_name}.
@end deffn

slot-set!
@c snarfed from goops.c:1442
@deffn {Scheme Procedure} slot-set! obj slot_name value
@deffnx {C Function} scm_slot_set_x (obj, slot_name, value)
Set the slot named @var{slot_name} of @var{obj} to @var{value}.
@end deffn

slot-bound?
@c snarfed from goops.c:1459
@deffn {Scheme Procedure} slot-bound? obj slot_name
@deffnx {C Function} scm_slot_bound_p (obj, slot_name)
Return @code{#t} if the slot named @var{slot_name} of @var{obj}
is bound.
@end deffn

slot-exists?
@c snarfed from goops.c:1477
@deffn {Scheme Procedure} slot-exists? obj slot_name
@deffnx {C Function} scm_slot_exists_p (obj, slot_name)
Return @code{#t} if @var{obj} has a slot named @var{slot_name}.
@end deffn

%allocate-instance
@c snarfed from goops.c:1516
@deffn {Scheme Procedure} %allocate-instance class initargs
@deffnx {C Function} scm_sys_allocate_instance (class, initargs)
Create a new instance of class @var{class} and initialize it
from the arguments @var{initargs}.
@end deffn

%set-object-setter!
@c snarfed from goops.c:1586
@deffn {Scheme Procedure} %set-object-setter! obj setter
@deffnx {C Function} scm_sys_set_object_setter_x (obj, setter)

@end deffn

%modify-instance
@c snarfed from goops.c:1611
@deffn {Scheme Procedure} %modify-instance old new
@deffnx {C Function} scm_sys_modify_instance (old, new)

@end deffn

%modify-class
@c snarfed from goops.c:1637
@deffn {Scheme Procedure} %modify-class old new
@deffnx {C Function} scm_sys_modify_class (old, new)

@end deffn

%invalidate-class
@c snarfed from goops.c:1661
@deffn {Scheme Procedure} %invalidate-class class
@deffnx {C Function} scm_sys_invalidate_class (class)

@end deffn

%invalidate-method-cache!
@c snarfed from goops.c:1783
@deffn {Scheme Procedure} %invalidate-method-cache! gf
@deffnx {C Function} scm_sys_invalidate_method_cache_x (gf)

@end deffn

generic-capability?
@c snarfed from goops.c:1809
@deffn {Scheme Procedure} generic-capability? proc
@deffnx {C Function} scm_generic_capability_p (proc)

@end deffn

enable-primitive-generic!
@c snarfed from goops.c:1822
@deffn {Scheme Procedure} enable-primitive-generic! . subrs
@deffnx {C Function} scm_enable_primitive_generic_x (subrs)

@end deffn

primitive-generic-generic
@c snarfed from goops.c:1843
@deffn {Scheme Procedure} primitive-generic-generic subr
@deffnx {C Function} scm_primitive_generic_generic (subr)

@end deffn

make
@c snarfed from goops.c:2209
@deffn {Scheme Procedure} make . args
@deffnx {C Function} scm_make (args)
Make a new object.  @var{args} must contain the class and
all necessary initialization information.
@end deffn

find-method
@c snarfed from goops.c:2298
@deffn {Scheme Procedure} find-method . l
@deffnx {C Function} scm_find_method (l)

@end deffn

%method-more-specific?
@c snarfed from goops.c:2318
@deffn {Scheme Procedure} %method-more-specific? m1 m2 targs
@deffnx {C Function} scm_sys_method_more_specific_p (m1, m2, targs)
Return true if method @var{m1} is more specific than @var{m2} given the argument types (classes) listed in @var{targs}.
@end deffn

%goops-loaded
@c snarfed from goops.c:2944
@deffn {Scheme Procedure} %goops-loaded
@deffnx {C Function} scm_sys_goops_loaded ()
Announce that GOOPS is loaded and perform initialization
on the C level which depends on the loaded GOOPS modules.
@end deffn

make-guardian
@c snarfed from guardians.c:307
@deffn {Scheme Procedure} make-guardian [greedy_p]
@deffnx {C Function} scm_make_guardian (greedy_p)
Create a new guardian.
A guardian protects a set of objects from garbage collection,
allowing a program to apply cleanup or other actions.

@code{make-guardian} returns a procedure representing the guardian.
Calling the guardian procedure with an argument adds the
argument to the guardian's set of protected objects.
Calling the guardian procedure without an argument returns
one of the protected objects which are ready for garbage
collection, or @code{#f} if no such object is available.
Objects which are returned in this way are removed from
the guardian.

@code{make-guardian} takes one optional argument that says whether the
new guardian should be greedy or sharing.  If there is any chance
that any object protected by the guardian may be resurrected,
then you should make the guardian greedy (this is the default).

See R. Kent Dybvig, Carl Bruggeman, and David Eby (1993)
"Guardians in a Generation-Based Garbage Collector".
ACM SIGPLAN Conference on Programming Language Design
and Implementation, June 1993.

(the semantics are slightly different at this point, but the
paper still (mostly) accurately describes the interface).
@end deffn

guardian-destroyed?
@c snarfed from guardians.c:335
@deffn {Scheme Procedure} guardian-destroyed? guardian
@deffnx {C Function} scm_guardian_destroyed_p (guardian)
Return @code{#t} if @var{guardian} has been destroyed, otherwise @code{#f}.
@end deffn

guardian-greedy?
@c snarfed from guardians.c:353
@deffn {Scheme Procedure} guardian-greedy? guardian
@deffnx {C Function} scm_guardian_greedy_p (guardian)
Return @code{#t} if @var{guardian} is a greedy guardian, otherwise @code{#f}.
@end deffn

destroy-guardian!
@c snarfed from guardians.c:364
@deffn {Scheme Procedure} destroy-guardian! guardian
@deffnx {C Function} scm_destroy_guardian_x (guardian)
Destroys @var{guardian}, by making it impossible to put any more
objects in it or get any objects from it.  It also unguards any
objects guarded by @var{guardian}.
@end deffn

hashq
@c snarfed from hash.c:183
@deffn {Scheme Procedure} hashq key size
@deffnx {C Function} scm_hashq (key, size)
Determine a hash value for @var{key} that is suitable for
lookups in a hashtable of size @var{size}, where @code{eq?} is
used as the equality predicate.  The function returns an
integer in the range 0 to @var{size} - 1.  Note that
@code{hashq} may use internal addresses.  Thus two calls to
hashq where the keys are @code{eq?} are not guaranteed to
deliver the same value if the key object gets garbage collected
in between.  This can happen, for example with symbols:
@code{(hashq 'foo n) (gc) (hashq 'foo n)} may produce two
different values, since @code{foo} will be garbage collected.
@end deffn

hashv
@c snarfed from hash.c:219
@deffn {Scheme Procedure} hashv key size
@deffnx {C Function} scm_hashv (key, size)
Determine a hash value for @var{key} that is suitable for
lookups in a hashtable of size @var{size}, where @code{eqv?} is
used as the equality predicate.  The function returns an
integer in the range 0 to @var{size} - 1.  Note that
@code{(hashv key)} may use internal addresses.  Thus two calls
to hashv where the keys are @code{eqv?} are not guaranteed to
deliver the same value if the key object gets garbage collected
in between.  This can happen, for example with symbols:
@code{(hashv 'foo n) (gc) (hashv 'foo n)} may produce two
different values, since @code{foo} will be garbage collected.
@end deffn

hash
@c snarfed from hash.c:242
@deffn {Scheme Procedure} hash key size
@deffnx {C Function} scm_hash (key, size)
Determine a hash value for @var{key} that is suitable for
lookups in a hashtable of size @var{size}, where @code{equal?}
is used as the equality predicate.  The function returns an
integer in the range 0 to @var{size} - 1.
@end deffn

make-hash-table
@c snarfed from hashtab.c:332
@deffn {Scheme Procedure} make-hash-table [n]
@deffnx {C Function} scm_make_hash_table (n)
Make a new abstract hash table object with minimum number of buckets @var{n}

@end deffn

make-weak-key-hash-table
@c snarfed from hashtab.c:349
@deffn {Scheme Procedure} make-weak-key-hash-table [n]
@deffnx {Scheme Procedure} make-weak-value-hash-table size
@deffnx {Scheme Procedure} make-doubly-weak-hash-table size
@deffnx {C Function} scm_make_weak_key_hash_table (n)
Return a weak hash table with @var{size} buckets.

You can modify weak hash tables in exactly the same way you
would modify regular hash tables. (@pxref{Hash Tables})
@end deffn

make-weak-value-hash-table
@c snarfed from hashtab.c:364
@deffn {Scheme Procedure} make-weak-value-hash-table [n]
@deffnx {C Function} scm_make_weak_value_hash_table (n)
Return a hash table with weak values with @var{size} buckets.
(@pxref{Hash Tables})
@end deffn

make-doubly-weak-hash-table
@c snarfed from hashtab.c:381
@deffn {Scheme Procedure} make-doubly-weak-hash-table n
@deffnx {C Function} scm_make_doubly_weak_hash_table (n)
Return a hash table with weak keys and values with @var{size}
buckets.  (@pxref{Hash Tables})
@end deffn

hash-table?
@c snarfed from hashtab.c:400
@deffn {Scheme Procedure} hash-table? obj
@deffnx {C Function} scm_hash_table_p (obj)
Return @code{#t} if @var{obj} is an abstract hash table object.
@end deffn

weak-key-hash-table?
@c snarfed from hashtab.c:414
@deffn {Scheme Procedure} weak-key-hash-table? obj
@deffnx {Scheme Procedure} weak-value-hash-table? obj
@deffnx {Scheme Procedure} doubly-weak-hash-table? obj
@deffnx {C Function} scm_weak_key_hash_table_p (obj)
Return @code{#t} if @var{obj} is the specified weak hash
table. Note that a doubly weak hash table is neither a weak key
nor a weak value hash table.
@end deffn

weak-value-hash-table?
@c snarfed from hashtab.c:424
@deffn {Scheme Procedure} weak-value-hash-table? obj
@deffnx {C Function} scm_weak_value_hash_table_p (obj)
Return @code{#t} if @var{obj} is a weak value hash table.
@end deffn

doubly-weak-hash-table?
@c snarfed from hashtab.c:434
@deffn {Scheme Procedure} doubly-weak-hash-table? obj
@deffnx {C Function} scm_doubly_weak_hash_table_p (obj)
Return @code{#t} if @var{obj} is a doubly weak hash table.
@end deffn

hash-clear!
@c snarfed from hashtab.c:586
@deffn {Scheme Procedure} hash-clear! table
@deffnx {C Function} scm_hash_clear_x (table)
Remove all items from @var{table} (without triggering a resize).
@end deffn

hashq-get-handle
@c snarfed from hashtab.c:607
@deffn {Scheme Procedure} hashq-get-handle table key
@deffnx {C Function} scm_hashq_get_handle (table, key)
This procedure returns the @code{(key . value)} pair from the
hash table @var{table}.  If @var{table} does not hold an
associated value for @var{key}, @code{#f} is returned.
Uses @code{eq?} for equality testing.
@end deffn

hashq-create-handle!
@c snarfed from hashtab.c:619
@deffn {Scheme Procedure} hashq-create-handle! table key init
@deffnx {C Function} scm_hashq_create_handle_x (table, key, init)
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

hashq-ref
@c snarfed from hashtab.c:632
@deffn {Scheme Procedure} hashq-ref table key [dflt]
@deffnx {C Function} scm_hashq_ref (table, key, dflt)
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument
is supplied).  Uses @code{eq?} for equality testing.
@end deffn

hashq-set!
@c snarfed from hashtab.c:646
@deffn {Scheme Procedure} hashq-set! table key val
@deffnx {C Function} scm_hashq_set_x (table, key, val)
Find the entry in @var{table} associated with @var{key}, and
store @var{value} there. Uses @code{eq?} for equality testing.
@end deffn

hashq-remove!
@c snarfed from hashtab.c:658
@deffn {Scheme Procedure} hashq-remove! table key
@deffnx {C Function} scm_hashq_remove_x (table, key)
Remove @var{key} (and any value associated with it) from
@var{table}.  Uses @code{eq?} for equality tests.
@end deffn

hashv-get-handle
@c snarfed from hashtab.c:673
@deffn {Scheme Procedure} hashv-get-handle table key
@deffnx {C Function} scm_hashv_get_handle (table, key)
This procedure returns the @code{(key . value)} pair from the
hash table @var{table}.  If @var{table} does not hold an
associated value for @var{key}, @code{#f} is returned.
Uses @code{eqv?} for equality testing.
@end deffn

hashv-create-handle!
@c snarfed from hashtab.c:685
@deffn {Scheme Procedure} hashv-create-handle! table key init
@deffnx {C Function} scm_hashv_create_handle_x (table, key, init)
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

hashv-ref
@c snarfed from hashtab.c:699
@deffn {Scheme Procedure} hashv-ref table key [dflt]
@deffnx {C Function} scm_hashv_ref (table, key, dflt)
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument
is supplied).  Uses @code{eqv?} for equality testing.
@end deffn

hashv-set!
@c snarfed from hashtab.c:713
@deffn {Scheme Procedure} hashv-set! table key val
@deffnx {C Function} scm_hashv_set_x (table, key, val)
Find the entry in @var{table} associated with @var{key}, and
store @var{value} there. Uses @code{eqv?} for equality testing.
@end deffn

hashv-remove!
@c snarfed from hashtab.c:724
@deffn {Scheme Procedure} hashv-remove! table key
@deffnx {C Function} scm_hashv_remove_x (table, key)
Remove @var{key} (and any value associated with it) from
@var{table}.  Uses @code{eqv?} for equality tests.
@end deffn

hash-get-handle
@c snarfed from hashtab.c:738
@deffn {Scheme Procedure} hash-get-handle table key
@deffnx {C Function} scm_hash_get_handle (table, key)
This procedure returns the @code{(key . value)} pair from the
hash table @var{table}.  If @var{table} does not hold an
associated value for @var{key}, @code{#f} is returned.
Uses @code{equal?} for equality testing.
@end deffn

hash-create-handle!
@c snarfed from hashtab.c:750
@deffn {Scheme Procedure} hash-create-handle! table key init
@deffnx {C Function} scm_hash_create_handle_x (table, key, init)
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

hash-ref
@c snarfed from hashtab.c:763
@deffn {Scheme Procedure} hash-ref table key [dflt]
@deffnx {C Function} scm_hash_ref (table, key, dflt)
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument
is supplied).  Uses @code{equal?} for equality testing.
@end deffn

hash-set!
@c snarfed from hashtab.c:778
@deffn {Scheme Procedure} hash-set! table key val
@deffnx {C Function} scm_hash_set_x (table, key, val)
Find the entry in @var{table} associated with @var{key}, and
store @var{value} there. Uses @code{equal?} for equality
testing.
@end deffn

hash-remove!
@c snarfed from hashtab.c:790
@deffn {Scheme Procedure} hash-remove! table key
@deffnx {C Function} scm_hash_remove_x (table, key)
Remove @var{key} (and any value associated with it) from
@var{table}.  Uses @code{equal?} for equality tests.
@end deffn

hashx-get-handle
@c snarfed from hashtab.c:831
@deffn {Scheme Procedure} hashx-get-handle hash assoc table key
@deffnx {C Function} scm_hashx_get_handle (hash, assoc, table, key)
This behaves the same way as the corresponding
@code{-get-handle} function, but uses @var{hash} as a hash
function and @var{assoc} to compare keys.  @code{hash} must be
a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.
@end deffn

hashx-create-handle!
@c snarfed from hashtab.c:850
@deffn {Scheme Procedure} hashx-create-handle! hash assoc table key init
@deffnx {C Function} scm_hashx_create_handle_x (hash, assoc, table, key, init)
This behaves the same way as the corresponding
@code{-create-handle} function, but uses @var{hash} as a hash
function and @var{assoc} to compare keys.  @code{hash} must be
a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.
@end deffn

hashx-ref
@c snarfed from hashtab.c:873
@deffn {Scheme Procedure} hashx-ref hash assoc table key [dflt]
@deffnx {C Function} scm_hashx_ref (hash, assoc, table, key, dflt)
This behaves the same way as the corresponding @code{ref}
function, but uses @var{hash} as a hash function and
@var{assoc} to compare keys.  @code{hash} must be a function
that takes two arguments, a key to be hashed and a table size.
@code{assoc} must be an associator function, like @code{assoc},
@code{assq} or @code{assv}.

By way of illustration, @code{hashq-ref table key} is
equivalent to @code{hashx-ref hashq assq table key}.
@end deffn

hashx-set!
@c snarfed from hashtab.c:899
@deffn {Scheme Procedure} hashx-set! hash assoc table key val
@deffnx {C Function} scm_hashx_set_x (hash, assoc, table, key, val)
This behaves the same way as the corresponding @code{set!}
function, but uses @var{hash} as a hash function and
@var{assoc} to compare keys.  @code{hash} must be a function
that takes two arguments, a key to be hashed and a table size.
@code{assoc} must be an associator function, like @code{assoc},
@code{assq} or @code{assv}.

 By way of illustration, @code{hashq-set! table key} is
equivalent to @code{hashx-set!  hashq assq table key}.
@end deffn

hashx-remove!
@c snarfed from hashtab.c:920
@deffn {Scheme Procedure} hashx-remove! hash assoc table obj
@deffnx {C Function} scm_hashx_remove_x (hash, assoc, table, obj)
This behaves the same way as the corresponding @code{remove!}
function, but uses @var{hash} as a hash function and
@var{assoc} to compare keys.  @code{hash} must be a function
that takes two arguments, a key to be hashed and a table size.
@code{assoc} must be an associator function, like @code{assoc},
@code{assq} or @code{assv}.

 By way of illustration, @code{hashq-remove! table key} is
equivalent to @code{hashx-remove!  hashq assq #f table key}.
@end deffn

hash-fold
@c snarfed from hashtab.c:1009
@deffn {Scheme Procedure} hash-fold proc init table
@deffnx {C Function} scm_hash_fold (proc, init, table)
An iterator over hash-table elements.
Accumulates and returns a result by applying PROC successively.
The arguments to PROC are "(key value prior-result)" where key
and value are successive pairs from the hash table TABLE, and
prior-result is either INIT (for the first application of PROC)
or the return value of the previous application of PROC.
For example, @code{(hash-fold acons '() tab)} will convert a hash
table into an a-list of key-value pairs.
@end deffn

hash-for-each
@c snarfed from hashtab.c:1030
@deffn {Scheme Procedure} hash-for-each proc table
@deffnx {C Function} scm_hash_for_each (proc, table)
An iterator over hash-table elements.
Applies PROC successively on all hash table items.
The arguments to PROC are "(key value)" where key
and value are successive pairs from the hash table TABLE.
@end deffn

hash-for-each-handle
@c snarfed from hashtab.c:1047
@deffn {Scheme Procedure} hash-for-each-handle proc table
@deffnx {C Function} scm_hash_for_each_handle (proc, table)
An iterator over hash-table elements.
Applies PROC successively on all hash table handles.
@end deffn

hash-map->list
@c snarfed from hashtab.c:1073
@deffn {Scheme Procedure} hash-map->list proc table
@deffnx {C Function} scm_hash_map_to_list (proc, table)
An iterator over hash-table elements.
Accumulates and returns as a list the results of applying PROC successively.
The arguments to PROC are "(key value)" where key
and value are successive pairs from the hash table TABLE.
@end deffn

make-hook
@c snarfed from hooks.c:154
@deffn {Scheme Procedure} make-hook [n_args]
@deffnx {C Function} scm_make_hook (n_args)
Create a hook for storing procedure of arity @var{n_args}.
@var{n_args} defaults to zero.  The returned value is a hook
object to be used with the other hook procedures.
@end deffn

hook?
@c snarfed from hooks.c:171
@deffn {Scheme Procedure} hook? x
@deffnx {C Function} scm_hook_p (x)
Return @code{#t} if @var{x} is a hook, @code{#f} otherwise.
@end deffn

hook-empty?
@c snarfed from hooks.c:182
@deffn {Scheme Procedure} hook-empty? hook
@deffnx {C Function} scm_hook_empty_p (hook)
Return @code{#t} if @var{hook} is an empty hook, @code{#f}
otherwise.
@end deffn

add-hook!
@c snarfed from hooks.c:196
@deffn {Scheme Procedure} add-hook! hook proc [append_p]
@deffnx {C Function} scm_add_hook_x (hook, proc, append_p)
Add the procedure @var{proc} to the hook @var{hook}. The
procedure is added to the end if @var{append_p} is true,
otherwise it is added to the front.  The return value of this
procedure is not specified.
@end deffn

remove-hook!
@c snarfed from hooks.c:223
@deffn {Scheme Procedure} remove-hook! hook proc
@deffnx {C Function} scm_remove_hook_x (hook, proc)
Remove the procedure @var{proc} from the hook @var{hook}.  The
return value of this procedure is not specified.
@end deffn

reset-hook!
@c snarfed from hooks.c:237
@deffn {Scheme Procedure} reset-hook! hook
@deffnx {C Function} scm_reset_hook_x (hook)
Remove all procedures from the hook @var{hook}.  The return
value of this procedure is not specified.
@end deffn

run-hook
@c snarfed from hooks.c:251
@deffn {Scheme Procedure} run-hook hook . args
@deffnx {C Function} scm_run_hook (hook, args)
Apply all procedures from the hook @var{hook} to the arguments
@var{args}.  The order of the procedure application is first to
last.  The return value of this procedure is not specified.
@end deffn

hook->list
@c snarfed from hooks.c:278
@deffn {Scheme Procedure} hook->list hook
@deffnx {C Function} scm_hook_to_list (hook)
Convert the procedure list of @var{hook} to a list.
@end deffn

gettext
@c snarfed from i18n.c:90
@deffn {Scheme Procedure} gettext msgid [domain [category]]
@deffnx {C Function} scm_gettext (msgid, domain, category)
Return the translation of @var{msgid} in the message domain @var{domain}. @var{domain} is optional and defaults to the domain set through (textdomain).  @var{category} is optional and defaults to LC_MESSAGES.
@end deffn

ngettext
@c snarfed from i18n.c:146
@deffn {Scheme Procedure} ngettext msgid msgid_plural n [domain [category]]
@deffnx {C Function} scm_ngettext (msgid, msgid_plural, n, domain, category)
Return the translation of @var{msgid}/@var{msgid_plural} in the message domain @var{domain}, with the plural form being chosen appropriately for the number @var{n}.  @var{domain} is optional and defaults to the domain set through (textdomain). @var{category} is optional and defaults to LC_MESSAGES.
@end deffn

textdomain
@c snarfed from i18n.c:209
@deffn {Scheme Procedure} textdomain [domainname]
@deffnx {C Function} scm_textdomain (domainname)
If optional parameter @var{domainname} is supplied, set the textdomain.  Return the textdomain.
@end deffn

bindtextdomain
@c snarfed from i18n.c:241
@deffn {Scheme Procedure} bindtextdomain domainname [directory]
@deffnx {C Function} scm_bindtextdomain (domainname, directory)
If optional parameter @var{directory} is supplied, set message catalogs to directory @var{directory}.  Return the directory bound to @var{domainname}.
@end deffn

bind-textdomain-codeset
@c snarfed from i18n.c:280
@deffn {Scheme Procedure} bind-textdomain-codeset domainname [encoding]
@deffnx {C Function} scm_bind_textdomain_codeset (domainname, encoding)
If optional parameter @var{encoding} is supplied, set encoding for message catalogs of @var{domainname}.  Return the encoding of @var{domainname}.
@end deffn

ftell
@c snarfed from ioext.c:54
@deffn {Scheme Procedure} ftell fd_port
@deffnx {C Function} scm_ftell (fd_port)
Return an integer representing the current position of
@var{fd/port}, measured from the beginning.  Equivalent to:

@lisp
(seek port 0 SEEK_CUR)
@end lisp
@end deffn

redirect-port
@c snarfed from ioext.c:72
@deffn {Scheme Procedure} redirect-port old new
@deffnx {C Function} scm_redirect_port (old, new)
This procedure takes two ports and duplicates the underlying file
descriptor from @var{old-port} into @var{new-port}.  The
current file descriptor in @var{new-port} will be closed.
After the redirection the two ports will share a file position
and file status flags.

The return value is unspecified.

Unexpected behaviour can result if both ports are subsequently used
and the original and/or duplicate ports are buffered.

This procedure does not have any side effects on other ports or
revealed counts.
@end deffn

dup->fdes
@c snarfed from ioext.c:111
@deffn {Scheme Procedure} dup->fdes fd_or_port [fd]
@deffnx {C Function} scm_dup_to_fdes (fd_or_port, fd)
Return a new integer file descriptor referring to the open file
designated by @var{fd_or_port}, which must be either an open
file port or a file descriptor.
@end deffn

dup2
@c snarfed from ioext.c:158
@deffn {Scheme Procedure} dup2 oldfd newfd
@deffnx {C Function} scm_dup2 (oldfd, newfd)
A simple wrapper for the @code{dup2} system call.
Copies the file descriptor @var{oldfd} to descriptor
number @var{newfd}, replacing the previous meaning
of @var{newfd}.  Both @var{oldfd} and @var{newfd} must
be integers.
Unlike for dup->fdes or primitive-move->fdes, no attempt
is made to move away ports which are using @var{newfd}.
The return value is unspecified.
@end deffn

fileno
@c snarfed from ioext.c:177
@deffn {Scheme Procedure} fileno port
@deffnx {C Function} scm_fileno (port)
Return the integer file descriptor underlying @var{port}.  Does
not change its revealed count.
@end deffn

isatty?
@c snarfed from ioext.c:197
@deffn {Scheme Procedure} isatty? port
@deffnx {C Function} scm_isatty_p (port)
Return @code{#t} if @var{port} is using a serial non--file
device, otherwise @code{#f}.
@end deffn

fdopen
@c snarfed from ioext.c:219
@deffn {Scheme Procedure} fdopen fdes modes
@deffnx {C Function} scm_fdopen (fdes, modes)
Return a new port based on the file descriptor @var{fdes}.
Modes are given by the string @var{modes}.  The revealed count
of the port is initialized to zero.  The modes string is the
same as that accepted by @ref{File Ports, open-file}.
@end deffn

primitive-move->fdes
@c snarfed from ioext.c:241
@deffn {Scheme Procedure} primitive-move->fdes port fd
@deffnx {C Function} scm_primitive_move_to_fdes (port, fd)
Moves the underlying file descriptor for @var{port} to the integer
value @var{fdes} without changing the revealed count of @var{port}.
Any other ports already using this descriptor will be automatically
shifted to new descriptors and their revealed counts reset to zero.
The return value is @code{#f} if the file descriptor already had the
required value or @code{#t} if it was moved.
@end deffn

fdes->ports
@c snarfed from ioext.c:274
@deffn {Scheme Procedure} fdes->ports fd
@deffnx {C Function} scm_fdes_to_ports (fd)
Return a list of existing ports which have @var{fdes} as an
underlying file descriptor, without changing their revealed
counts.
@end deffn

keyword?
@c snarfed from keywords.c:52
@deffn {Scheme Procedure} keyword? obj
@deffnx {C Function} scm_keyword_p (obj)
Return @code{#t} if the argument @var{obj} is a keyword, else
@code{#f}.
@end deffn

symbol->keyword
@c snarfed from keywords.c:61
@deffn {Scheme Procedure} symbol->keyword symbol
@deffnx {C Function} scm_symbol_to_keyword (symbol)
Return the keyword with the same name as @var{symbol}.
@end deffn

keyword->symbol
@c snarfed from keywords.c:82
@deffn {Scheme Procedure} keyword->symbol keyword
@deffnx {C Function} scm_keyword_to_symbol (keyword)
Return the symbol with the same name as @var{keyword}.
@end deffn

list
@c snarfed from list.c:104
@deffn {Scheme Procedure} list . objs
@deffnx {C Function} scm_list (objs)
Return a list containing @var{objs}, the arguments to
@code{list}.
@end deffn

cons*
@c snarfed from list.c:119
@deffn {Scheme Procedure} cons* arg . rest
@deffnx {C Function} scm_cons_star (arg, rest)
Like @code{list}, but the last arg provides the tail of the
constructed list, returning @code{(cons @var{arg1} (cons
@var{arg2} (cons @dots{} @var{argn})))}.  Requires at least one
argument.  If given one argument, that argument is returned as
result.  This function is called @code{list*} in some other
Schemes and in Common LISP.
@end deffn

null?
@c snarfed from list.c:143
@deffn {Scheme Procedure} null? x
@deffnx {C Function} scm_null_p (x)
Return @code{#t} iff @var{x} is the empty list, else @code{#f}.
@end deffn

list?
@c snarfed from list.c:153
@deffn {Scheme Procedure} list? x
@deffnx {C Function} scm_list_p (x)
Return @code{#t} iff @var{x} is a proper list, else @code{#f}.
@end deffn

length
@c snarfed from list.c:194
@deffn {Scheme Procedure} length lst
@deffnx {C Function} scm_length (lst)
Return the number of elements in list @var{lst}.
@end deffn

append
@c snarfed from list.c:223
@deffn {Scheme Procedure} append . args
@deffnx {C Function} scm_append (args)
Return a list consisting of the elements the lists passed as
arguments.
@lisp
(append '(x) '(y))          @result{}  (x y)
(append '(a) '(b c d))      @result{}  (a b c d)
(append '(a (b)) '((c)))    @result{}  (a (b) (c))
@end lisp
The resulting list is always newly allocated, except that it
shares structure with the last list argument.  The last
argument may actually be any object; an improper list results
if the last argument is not a proper list.
@lisp
(append '(a b) '(c . d))    @result{}  (a b c . d)
(append '() 'a)             @result{}  a
@end lisp
@end deffn

append!
@c snarfed from list.c:259
@deffn {Scheme Procedure} append! . lists
@deffnx {C Function} scm_append_x (lists)
A destructive version of @code{append} (@pxref{Pairs and
Lists,,,r5rs, The Revised^5 Report on Scheme}).  The cdr field
of each list's final pair is changed to point to the head of
the next list, so no consing is performed.  Return
the mutated list.
@end deffn

last-pair
@c snarfed from list.c:291
@deffn {Scheme Procedure} last-pair lst
@deffnx {C Function} scm_last_pair (lst)
Return the last pair in @var{lst}, signalling an error if
@var{lst} is circular.
@end deffn

reverse
@c snarfed from list.c:321
@deffn {Scheme Procedure} reverse lst
@deffnx {C Function} scm_reverse (lst)
Return a new list that contains the elements of @var{lst} but
in reverse order.
@end deffn

reverse!
@c snarfed from list.c:355
@deffn {Scheme Procedure} reverse! lst [new_tail]
@deffnx {C Function} scm_reverse_x (lst, new_tail)
A destructive version of @code{reverse} (@pxref{Pairs and Lists,,,r5rs,
The Revised^5 Report on Scheme}).  The cdr of each cell in @var{lst} is
modified to point to the previous list element.  Return the
reversed list.

Caveat: because the list is modified in place, the tail of the original
list now becomes its head, and the head of the original list now becomes
the tail.  Therefore, the @var{lst} symbol to which the head of the
original list was bound now points to the tail.  To ensure that the head
of the modified list is not lost, it is wise to save the return value of
@code{reverse!}
@end deffn

list-ref
@c snarfed from list.c:381
@deffn {Scheme Procedure} list-ref list k
@deffnx {C Function} scm_list_ref (list, k)
Return the @var{k}th element from @var{list}.
@end deffn

list-set!
@c snarfed from list.c:405
@deffn {Scheme Procedure} list-set! list k val
@deffnx {C Function} scm_list_set_x (list, k, val)
Set the @var{k}th element of @var{list} to @var{val}.
@end deffn

list-cdr-ref
@c snarfed from list.c:427
@deffn {Scheme Procedure} list-cdr-ref
implemented by the C function "scm_list_tail"
@end deffn

list-tail
@c snarfed from list.c:436
@deffn {Scheme Procedure} list-tail lst k
@deffnx {Scheme Procedure} list-cdr-ref lst k
@deffnx {C Function} scm_list_tail (lst, k)
Return the "tail" of @var{lst} beginning with its @var{k}th element.
The first element of the list is considered to be element 0.

@code{list-tail} and @code{list-cdr-ref} are identical.  It may help to
think of @code{list-cdr-ref} as accessing the @var{k}th cdr of the list,
or returning the results of cdring @var{k} times down @var{lst}.
@end deffn

list-cdr-set!
@c snarfed from list.c:451
@deffn {Scheme Procedure} list-cdr-set! list k val
@deffnx {C Function} scm_list_cdr_set_x (list, k, val)
Set the @var{k}th cdr of @var{list} to @var{val}.
@end deffn

list-head
@c snarfed from list.c:479
@deffn {Scheme Procedure} list-head lst k
@deffnx {C Function} scm_list_head (lst, k)
Copy the first @var{k} elements from @var{lst} into a new list, and
return it.
@end deffn

list-copy
@c snarfed from list.c:530
@deffn {Scheme Procedure} list-copy lst
@deffnx {C Function} scm_list_copy (lst)
Return a (newly-created) copy of @var{lst}.
@end deffn

memq
@c snarfed from list.c:584
@deffn {Scheme Procedure} memq x lst
@deffnx {C Function} scm_memq (x, lst)
Return the first sublist of @var{lst} whose car is @code{eq?}
to @var{x} where the sublists of @var{lst} are the non-empty
lists returned by @code{(list-tail @var{lst} @var{k})} for
@var{k} less than the length of @var{lst}.  If @var{x} does not
occur in @var{lst}, then @code{#f} (not the empty list) is
returned.
@end deffn

memv
@c snarfed from list.c:600
@deffn {Scheme Procedure} memv x lst
@deffnx {C Function} scm_memv (x, lst)
Return the first sublist of @var{lst} whose car is @code{eqv?}
to @var{x} where the sublists of @var{lst} are the non-empty
lists returned by @code{(list-tail @var{lst} @var{k})} for
@var{k} less than the length of @var{lst}.  If @var{x} does not
occur in @var{lst}, then @code{#f} (not the empty list) is
returned.
@end deffn

member
@c snarfed from list.c:621
@deffn {Scheme Procedure} member x lst
@deffnx {C Function} scm_member (x, lst)
Return the first sublist of @var{lst} whose car is
@code{equal?} to @var{x} where the sublists of @var{lst} are
the non-empty lists returned by @code{(list-tail @var{lst}
@var{k})} for @var{k} less than the length of @var{lst}.  If
@var{x} does not occur in @var{lst}, then @code{#f} (not the
empty list) is returned.
@end deffn

delq!
@c snarfed from list.c:646
@deffn {Scheme Procedure} delq! item lst
@deffnx {Scheme Procedure} delv! item lst
@deffnx {Scheme Procedure} delete! item lst
@deffnx {C Function} scm_delq_x (item, lst)
These procedures are destructive versions of @code{delq}, @code{delv}
and @code{delete}: they modify the existing @var{lst}
rather than creating a new list.  Caveat evaluator: Like other
destructive list functions, these functions cannot modify the binding of
@var{lst}, and so cannot be used to delete the first element of
@var{lst} destructively.
@end deffn

delv!
@c snarfed from list.c:670
@deffn {Scheme Procedure} delv! item lst
@deffnx {C Function} scm_delv_x (item, lst)
Destructively remove all elements from @var{lst} that are
@code{eqv?} to @var{item}.
@end deffn

delete!
@c snarfed from list.c:695
@deffn {Scheme Procedure} delete! item lst
@deffnx {C Function} scm_delete_x (item, lst)
Destructively remove all elements from @var{lst} that are
@code{equal?} to @var{item}.
@end deffn

delq
@c snarfed from list.c:724
@deffn {Scheme Procedure} delq item lst
@deffnx {C Function} scm_delq (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{eq?} to @var{item} removed.  This procedure mirrors
@code{memq}: @code{delq} compares elements of @var{lst} against
@var{item} with @code{eq?}.
@end deffn

delv
@c snarfed from list.c:737
@deffn {Scheme Procedure} delv item lst
@deffnx {C Function} scm_delv (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{eqv?}  to @var{item} removed.  This procedure mirrors
@code{memv}: @code{delv} compares elements of @var{lst} against
@var{item} with @code{eqv?}.
@end deffn

delete
@c snarfed from list.c:750
@deffn {Scheme Procedure} delete item lst
@deffnx {C Function} scm_delete (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{equal?}  to @var{item} removed.  This procedure mirrors
@code{member}: @code{delete} compares elements of @var{lst}
against @var{item} with @code{equal?}.
@end deffn

delq1!
@c snarfed from list.c:763
@deffn {Scheme Procedure} delq1! item lst
@deffnx {C Function} scm_delq1_x (item, lst)
Like @code{delq!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{eq?}.  See also @code{delv1!} and @code{delete1!}.
@end deffn

delv1!
@c snarfed from list.c:791
@deffn {Scheme Procedure} delv1! item lst
@deffnx {C Function} scm_delv1_x (item, lst)
Like @code{delv!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{eqv?}.  See also @code{delq1!} and @code{delete1!}.
@end deffn

delete1!
@c snarfed from list.c:819
@deffn {Scheme Procedure} delete1! item lst
@deffnx {C Function} scm_delete1_x (item, lst)
Like @code{delete!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{equal?}.  See also @code{delq1!} and @code{delv1!}.
@end deffn

filter
@c snarfed from list.c:851
@deffn {Scheme Procedure} filter pred list
@deffnx {C Function} scm_filter (pred, list)
Return all the elements of 2nd arg @var{list} that satisfy predicate @var{pred}.
The list is not disordered -- elements that appear in the result list occur
in the same order as they occur in the argument list. The returned list may
share a common tail with the argument list. The dynamic order in which the
various applications of pred are made is not specified.

@lisp
(filter even? '(0 7 8 8 43 -4)) => (0 8 8 -4)
@end lisp
@end deffn

filter!
@c snarfed from list.c:878
@deffn {Scheme Procedure} filter! pred list
@deffnx {C Function} scm_filter_x (pred, list)
Linear-update variant of @code{filter}.
@end deffn

primitive-load
@c snarfed from load.c:72
@deffn {Scheme Procedure} primitive-load filename
@deffnx {C Function} scm_primitive_load (filename)
Load the file named @var{filename} and evaluate its contents in
the top-level environment. The load paths are not searched;
@var{filename} must either be a full pathname or be a pathname
relative to the current directory.  If the  variable
@code{%load-hook} is defined, it should be bound to a procedure
that will be called before any code is loaded.  See the
documentation for @code{%load-hook} later in this section.
@end deffn

%package-data-dir
@c snarfed from load.c:117
@deffn {Scheme Procedure} %package-data-dir
@deffnx {C Function} scm_sys_package_data_dir ()
Return the name of the directory where Scheme packages, modules and
libraries are kept.  On most Unix systems, this will be
@samp{/usr/local/share/guile}.
@end deffn

%library-dir
@c snarfed from load.c:129
@deffn {Scheme Procedure} %library-dir
@deffnx {C Function} scm_sys_library_dir ()
Return the directory where the Guile Scheme library files are installed.
E.g., may return "/usr/share/guile/1.3.5".
@end deffn

%site-dir
@c snarfed from load.c:141
@deffn {Scheme Procedure} %site-dir
@deffnx {C Function} scm_sys_site_dir ()
Return the directory where the Guile site files are installed.
E.g., may return "/usr/share/guile/site".
@end deffn

parse-path
@c snarfed from load.c:166
@deffn {Scheme Procedure} parse-path path [tail]
@deffnx {C Function} scm_parse_path (path, tail)
Parse @var{path}, which is expected to be a colon-separated
string, into a list and return the resulting list with
@var{tail} appended. If @var{path} is @code{#f}, @var{tail}
is returned.
@end deffn

search-path
@c snarfed from load.c:293
@deffn {Scheme Procedure} search-path path filename [extensions]
@deffnx {C Function} scm_search_path (path, filename, extensions)
Search @var{path} for a directory containing a file named
@var{filename}. The file must be readable, and not a directory.
If we find one, return its full filename; otherwise, return
@code{#f}.  If @var{filename} is absolute, return it unchanged.
If given, @var{extensions} is a list of strings; for each
directory in @var{path}, we search for @var{filename}
concatenated with each @var{extension}.
@end deffn

%search-load-path
@c snarfed from load.c:430
@deffn {Scheme Procedure} %search-load-path filename
@deffnx {C Function} scm_sys_search_load_path (filename)
Search @var{%load-path} for the file named @var{filename},
which must be readable by the current user.  If @var{filename}
is found in the list of paths to search or is an absolute
pathname, return its full pathname.  Otherwise, return
@code{#f}.  Filenames may have any of the optional extensions
in the @code{%load-extensions} list; @code{%search-load-path}
will try each extension automatically.
@end deffn

primitive-load-path
@c snarfed from load.c:451
@deffn {Scheme Procedure} primitive-load-path filename
@deffnx {C Function} scm_primitive_load_path (filename)
Search @var{%load-path} for the file named @var{filename} and
load it into the top-level environment.  If @var{filename} is a
relative pathname and is not found in the list of search paths,
an error is signalled.
@end deffn

procedure->memoizing-macro
@c snarfed from macros.c:109
@deffn {Scheme Procedure} procedure->memoizing-macro code
@deffnx {C Function} scm_makmmacro (code)
Return a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, evaluates the
result of applying @var{code} to the expression and the
environment.

@code{procedure->memoizing-macro} is the same as
@code{procedure->macro}, except that the expression returned by
@var{code} replaces the original macro expression in the memoized
form of the containing code.
@end deffn

procedure->syntax
@c snarfed from macros.c:123
@deffn {Scheme Procedure} procedure->syntax code
@deffnx {C Function} scm_makacro (code)
Return a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, returns the
result of applying @var{code} to the expression and the
environment.
@end deffn

procedure->macro
@c snarfed from macros.c:146
@deffn {Scheme Procedure} procedure->macro code
@deffnx {C Function} scm_makmacro (code)
Return a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, evaluates the
result of applying @var{code} to the expression and the
environment.  For example:

@lisp
(define trace
  (procedure->macro
   (lambda (x env) `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))

(trace @i{foo}) @equiv{} (set! @i{foo} (tracef @i{foo} '@i{foo})).
@end lisp
@end deffn

macro?
@c snarfed from macros.c:165
@deffn {Scheme Procedure} macro? obj
@deffnx {C Function} scm_macro_p (obj)
Return @code{#t} if @var{obj} is a regular macro, a memoizing macro, a
syntax transformer, or a syntax-case macro.
@end deffn

macro-type
@c snarfed from macros.c:186
@deffn {Scheme Procedure} macro-type m
@deffnx {C Function} scm_macro_type (m)
Return one of the symbols @code{syntax}, @code{macro},
@code{macro!}, or @code{syntax-case}, depending on whether
@var{m} is a syntax transformer, a regular macro, a memoizing
macro, or a syntax-case macro, respectively.  If @var{m} is
not a macro, @code{#f} is returned.
@end deffn

macro-name
@c snarfed from macros.c:207
@deffn {Scheme Procedure} macro-name m
@deffnx {C Function} scm_macro_name (m)
Return the name of the macro @var{m}.
@end deffn

macro-transformer
@c snarfed from macros.c:218
@deffn {Scheme Procedure} macro-transformer m
@deffnx {C Function} scm_macro_transformer (m)
Return the transformer of the macro @var{m}.
@end deffn

current-module
@c snarfed from modules.c:45
@deffn {Scheme Procedure} current-module
@deffnx {C Function} scm_current_module ()
Return the current module.
@end deffn

set-current-module
@c snarfed from modules.c:57
@deffn {Scheme Procedure} set-current-module module
@deffnx {C Function} scm_set_current_module (module)
Set the current module to @var{module} and return
the previous current module.
@end deffn

interaction-environment
@c snarfed from modules.c:80
@deffn {Scheme Procedure} interaction-environment
@deffnx {C Function} scm_interaction_environment ()
Return a specifier for the environment that contains
implementation--defined bindings, typically a superset of those
listed in the report.  The intent is that this procedure will
return the environment in which the implementation would
evaluate expressions dynamically typed by the user.
@end deffn

env-module
@c snarfed from modules.c:266
@deffn {Scheme Procedure} env-module env
@deffnx {C Function} scm_env_module (env)
Return the module of @var{ENV}, a lexical environment.
@end deffn

standard-eval-closure
@c snarfed from modules.c:342
@deffn {Scheme Procedure} standard-eval-closure module
@deffnx {C Function} scm_standard_eval_closure (module)
Return an eval closure for the module @var{module}.
@end deffn

standard-interface-eval-closure
@c snarfed from modules.c:353
@deffn {Scheme Procedure} standard-interface-eval-closure module
@deffnx {C Function} scm_standard_interface_eval_closure (module)
Return a interface eval closure for the module @var{module}. Such a closure does not allow new bindings to be added.
@end deffn

module-import-interface
@c snarfed from modules.c:399
@deffn {Scheme Procedure} module-import-interface module sym
@deffnx {C Function} scm_module_import_interface (module, sym)
Return the module or interface from which @var{sym} is imported in @var{module}.  If @var{sym} is not imported (i.e., it is not defined in @var{module} or it is a module-local binding instead of an imported one), then @code{#f} is returned.
@end deffn

%get-pre-modules-obarray
@c snarfed from modules.c:616
@deffn {Scheme Procedure} %get-pre-modules-obarray
@deffnx {C Function} scm_get_pre_modules_obarray ()
Return the obarray that is used for all new bindings before the module system is booted.  The first call to @code{set-current-module} will boot the module system.
@end deffn

exact?
@c snarfed from numbers.c:460
@deffn {Scheme Procedure} exact? x
@deffnx {C Function} scm_exact_p (x)
Return @code{#t} if @var{x} is an exact number, @code{#f}
otherwise.
@end deffn

odd?
@c snarfed from numbers.c:479
@deffn {Scheme Procedure} odd? n
@deffnx {C Function} scm_odd_p (n)
Return @code{#t} if @var{n} is an odd number, @code{#f}
otherwise.
@end deffn

even?
@c snarfed from numbers.c:514
@deffn {Scheme Procedure} even? n
@deffnx {C Function} scm_even_p (n)
Return @code{#t} if @var{n} is an even number, @code{#f}
otherwise.
@end deffn

inf?
@c snarfed from numbers.c:548
@deffn {Scheme Procedure} inf? x
@deffnx {C Function} scm_inf_p (x)
Return @code{#t} if @var{x} is either @samp{+inf.0}
or @samp{-inf.0}, @code{#f} otherwise.
@end deffn

nan?
@c snarfed from numbers.c:564
@deffn {Scheme Procedure} nan? n
@deffnx {C Function} scm_nan_p (n)
Return @code{#t} if @var{n} is a NaN, @code{#f}
otherwise.
@end deffn

inf
@c snarfed from numbers.c:634
@deffn {Scheme Procedure} inf
@deffnx {C Function} scm_inf ()
Return Inf.
@end deffn

nan
@c snarfed from numbers.c:649
@deffn {Scheme Procedure} nan
@deffnx {C Function} scm_nan ()
Return NaN.
@end deffn

abs
@c snarfed from numbers.c:665
@deffn {Scheme Procedure} abs x
@deffnx {C Function} scm_abs (x)
Return the absolute value of @var{x}.
@end deffn

logand
@c snarfed from numbers.c:1201
@deffn {Scheme Procedure} logand n1 n2
Return the bitwise AND of the integer arguments.

@lisp
(logand) @result{} -1
(logand 7) @result{} 7
(logand #b111 #b011 #b001) @result{} 1
@end lisp
@end deffn

logior
@c snarfed from numbers.c:1277
@deffn {Scheme Procedure} logior n1 n2
Return the bitwise OR of the integer arguments.

@lisp
(logior) @result{} 0
(logior 7) @result{} 7
(logior #b000 #b001 #b011) @result{} 3
@end lisp
@end deffn

logxor
@c snarfed from numbers.c:1353
@deffn {Scheme Procedure} logxor n1 n2
Return the bitwise XOR of the integer arguments.  A bit is
set in the result if it is set in an odd number of arguments.
@lisp
(logxor) @result{} 0
(logxor 7) @result{} 7
(logxor #b000 #b001 #b011) @result{} 2
(logxor #b000 #b001 #b011 #b011) @result{} 1
@end lisp
@end deffn

logtest
@c snarfed from numbers.c:1428
@deffn {Scheme Procedure} logtest j k
@deffnx {C Function} scm_logtest (j, k)
Test whether @var{j} and @var{k} have any 1 bits in common.
This is equivalent to @code{(not (zero? (logand j k)))}, but
without actually calculating the @code{logand}, just testing
for non-zero.

@lisp
(logtest #b0100 #b1011) @result{} #f
(logtest #b0100 #b0111) @result{} #t
@end lisp
@end deffn

logbit?
@c snarfed from numbers.c:1501
@deffn {Scheme Procedure} logbit? index j
@deffnx {C Function} scm_logbit_p (index, j)
Test whether bit number @var{index} in @var{j} is set.
@var{index} starts from 0 for the least significant bit.

@lisp
(logbit? 0 #b1101) @result{} #t
(logbit? 1 #b1101) @result{} #f
(logbit? 2 #b1101) @result{} #t
(logbit? 3 #b1101) @result{} #t
(logbit? 4 #b1101) @result{} #f
@end lisp
@end deffn

lognot
@c snarfed from numbers.c:1535
@deffn {Scheme Procedure} lognot n
@deffnx {C Function} scm_lognot (n)
Return the integer which is the ones-complement of the integer
argument.

@lisp
(number->string (lognot #b10000000) 2)
   @result{} "-10000001"
(number->string (lognot #b0) 2)
   @result{} "-1"
@end lisp
@end deffn

modulo-expt
@c snarfed from numbers.c:1580
@deffn {Scheme Procedure} modulo-expt n k m
@deffnx {C Function} scm_modulo_expt (n, k, m)
Return @var{n} raised to the integer exponent
@var{k}, modulo @var{m}.

@lisp
(modulo-expt 2 3 5)
   @result{} 3
@end lisp
@end deffn

integer-expt
@c snarfed from numbers.c:1689
@deffn {Scheme Procedure} integer-expt n k
@deffnx {C Function} scm_integer_expt (n, k)
Return @var{n} raised to the power @var{k}.  @var{k} must be an
exact integer, @var{n} can be any number.

Negative @var{k} is supported, and results in @math{1/n^abs(k)}
in the usual way.  @math{@var{n}^0} is 1, as usual, and that
includes @math{0^0} is 1.

@lisp
(integer-expt 2 5)   @result{} 32
(integer-expt -3 3)  @result{} -27
(integer-expt 5 -3)  @result{} 1/125
(integer-expt 0 0)   @result{} 1
@end lisp
@end deffn

ash
@c snarfed from numbers.c:1779
@deffn {Scheme Procedure} ash n cnt
@deffnx {C Function} scm_ash (n, cnt)
Return @var{n} shifted left by @var{cnt} bits, or shifted right
if @var{cnt} is negative.  This is an ``arithmetic'' shift.

This is effectively a multiplication by 2^@var{cnt}, and when
@var{cnt} is negative it's a division, rounded towards negative
infinity.  (Note that this is not the same rounding as
@code{quotient} does.)

With @var{n} viewed as an infinite precision twos complement,
@code{ash} means a left shift introducing zero bits, or a right
shift dropping bits.

@lisp
(number->string (ash #b1 3) 2)     @result{} "1000"
(number->string (ash #b1010 -1) 2) @result{} "101"

;; -23 is bits ...11101001, -6 is bits ...111010
(ash -23 -2) @result{} -6
@end lisp
@end deffn

bit-extract
@c snarfed from numbers.c:1870
@deffn {Scheme Procedure} bit-extract n start end
@deffnx {C Function} scm_bit_extract (n, start, end)
Return the integer composed of the @var{start} (inclusive)
through @var{end} (exclusive) bits of @var{n}.  The
@var{start}th bit becomes the 0-th bit in the result.

@lisp
(number->string (bit-extract #b1101101010 0 4) 2)
   @result{} "1010"
(number->string (bit-extract #b1101101010 4 9) 2)
   @result{} "10110"
@end lisp
@end deffn

logcount
@c snarfed from numbers.c:1949
@deffn {Scheme Procedure} logcount n
@deffnx {C Function} scm_logcount (n)
Return the number of bits in integer @var{n}.  If integer is
positive, the 1-bits in its binary representation are counted.
If negative, the 0-bits in its two's-complement binary
representation are counted.  If 0, 0 is returned.

@lisp
(logcount #b10101010)
   @result{} 4
(logcount 0)
   @result{} 0
(logcount -2)
   @result{} 1
@end lisp
@end deffn

integer-length
@c snarfed from numbers.c:1997
@deffn {Scheme Procedure} integer-length n
@deffnx {C Function} scm_integer_length (n)
Return the number of bits necessary to represent @var{n}.

@lisp
(integer-length #b10101010)
   @result{} 8
(integer-length 0)
   @result{} 0
(integer-length #b1111)
   @result{} 4
@end lisp
@end deffn

number->string
@c snarfed from numbers.c:2337
@deffn {Scheme Procedure} number->string n [radix]
@deffnx {C Function} scm_number_to_string (n, radix)
Return a string holding the external representation of the
number @var{n} in the given @var{radix}.  If @var{n} is
inexact, a radix of 10 will be used.
@end deffn

string->number
@c snarfed from numbers.c:3034
@deffn {Scheme Procedure} string->number string [radix]
@deffnx {C Function} scm_string_to_number (string, radix)
Return a number of the maximally precise representation
expressed by the given @var{string}. @var{radix} must be an
exact integer, either 2, 8, 10, or 16. If supplied, @var{radix}
is a default radix that may be overridden by an explicit radix
prefix in @var{string} (e.g. "#o177"). If @var{radix} is not
supplied, then the default radix is 10. If string is not a
syntactically valid notation for a number, then
@code{string->number} returns @code{#f}.
@end deffn

number?
@c snarfed from numbers.c:3097
@deffn {Scheme Procedure} number? x
@deffnx {C Function} scm_number_p (x)
Return @code{#t} if @var{x} is a number, @code{#f}
otherwise.
@end deffn

complex?
@c snarfed from numbers.c:3110
@deffn {Scheme Procedure} complex? x
@deffnx {C Function} scm_complex_p (x)
Return @code{#t} if @var{x} is a complex number, @code{#f}
otherwise.  Note that the sets of real, rational and integer
values form subsets of the set of complex numbers, i. e. the
predicate will also be fulfilled if @var{x} is a real,
rational or integer number.
@end deffn

real?
@c snarfed from numbers.c:3123
@deffn {Scheme Procedure} real? x
@deffnx {C Function} scm_real_p (x)
Return @code{#t} if @var{x} is a real number, @code{#f}
otherwise.  Note that the set of integer values forms a subset of
the set of real numbers, i. e. the predicate will also be
fulfilled if @var{x} is an integer number.
@end deffn

rational?
@c snarfed from numbers.c:3136
@deffn {Scheme Procedure} rational? x
@deffnx {C Function} scm_rational_p (x)
Return @code{#t} if @var{x} is a rational number, @code{#f}
otherwise.  Note that the set of integer values forms a subset of
the set of rational numbers, i. e. the predicate will also be
fulfilled if @var{x} is an integer number.
@end deffn

integer?
@c snarfed from numbers.c:3159
@deffn {Scheme Procedure} integer? x
@deffnx {C Function} scm_integer_p (x)
Return @code{#t} if @var{x} is an integer number, @code{#f}
else.
@end deffn

inexact?
@c snarfed from numbers.c:3185
@deffn {Scheme Procedure} inexact? x
@deffnx {C Function} scm_inexact_p (x)
Return @code{#t} if @var{x} is an inexact number, @code{#f}
else.
@end deffn

truncate
@c snarfed from numbers.c:5060
@deffn {Scheme Procedure} truncate x
@deffnx {C Function} scm_truncate_number (x)
Round the number @var{x} towards zero.
@end deffn

round
@c snarfed from numbers.c:5076
@deffn {Scheme Procedure} round x
@deffnx {C Function} scm_round_number (x)
Round the number @var{x} towards the nearest integer. When it is exactly halfway between two integers, round towards the even one.
@end deffn

floor
@c snarfed from numbers.c:5102
@deffn {Scheme Procedure} floor x
@deffnx {C Function} scm_floor (x)
Round the number @var{x} towards minus infinity.
@end deffn

ceiling
@c snarfed from numbers.c:5133
@deffn {Scheme Procedure} ceiling x
@deffnx {C Function} scm_ceiling (x)
Round the number @var{x} towards infinity.
@end deffn

$expt
@c snarfed from numbers.c:5242
@deffn {Scheme Procedure} $expt x y
@deffnx {C Function} scm_sys_expt (x, y)
Return @var{x} raised to the power of @var{y}. This
procedure does not accept complex arguments.
@end deffn

$atan2
@c snarfed from numbers.c:5258
@deffn {Scheme Procedure} $atan2 x y
@deffnx {C Function} scm_sys_atan2 (x, y)
Return the arc tangent of the two arguments @var{x} and
@var{y}. This is similar to calculating the arc tangent of
@var{x} / @var{y}, except that the signs of both arguments
are used to determine the quadrant of the result. This
procedure does not accept complex arguments.
@end deffn

make-rectangular
@c snarfed from numbers.c:5286
@deffn {Scheme Procedure} make-rectangular real_part imaginary_part
@deffnx {C Function} scm_make_rectangular (real_part, imaginary_part)
Return a complex number constructed of the given @var{real-part} and @var{imaginary-part} parts.
@end deffn

make-polar
@c snarfed from numbers.c:5310
@deffn {Scheme Procedure} make-polar x y
@deffnx {C Function} scm_make_polar (x, y)
Return the complex number @var{x} * e^(i * @var{y}).
@end deffn

inexact->exact
@c snarfed from numbers.c:5513
@deffn {Scheme Procedure} inexact->exact z
@deffnx {C Function} scm_inexact_to_exact (z)
Return an exact number that is numerically closest to @var{z}.
@end deffn

rationalize
@c snarfed from numbers.c:5550
@deffn {Scheme Procedure} rationalize x err
@deffnx {C Function} scm_rationalize (x, err)
Return an exact number that is within @var{err} of @var{x}.
@end deffn

entity?
@c snarfed from objects.c:192
@deffn {Scheme Procedure} entity? obj
@deffnx {C Function} scm_entity_p (obj)
Return @code{#t} if @var{obj} is an entity.
@end deffn

operator?
@c snarfed from objects.c:201
@deffn {Scheme Procedure} operator? obj
@deffnx {C Function} scm_operator_p (obj)
Return @code{#t} if @var{obj} is an operator.
@end deffn

valid-object-procedure?
@c snarfed from objects.c:217
@deffn {Scheme Procedure} valid-object-procedure? proc
@deffnx {C Function} scm_valid_object_procedure_p (proc)
Return @code{#t} iff @var{proc} is a procedure that can be used with @code{set-object-procedure}.  It is always valid to use a closure constructed by @code{lambda}.
@end deffn

set-object-procedure!
@c snarfed from objects.c:239
@deffn {Scheme Procedure} set-object-procedure! obj proc
@deffnx {C Function} scm_set_object_procedure_x (obj, proc)
Set the object procedure of @var{obj} to @var{proc}.
@var{obj} must be either an entity or an operator.
@end deffn

make-class-object
@c snarfed from objects.c:299
@deffn {Scheme Procedure} make-class-object metaclass layout
@deffnx {C Function} scm_make_class_object (metaclass, layout)
Create a new class object of class @var{metaclass}, with the
slot layout specified by @var{layout}.
@end deffn

make-subclass-object
@c snarfed from objects.c:314
@deffn {Scheme Procedure} make-subclass-object class layout
@deffnx {C Function} scm_make_subclass_object (class, layout)
Create a subclass object of @var{class}, with the slot layout
specified by @var{layout}.
@end deffn

object-properties
@c snarfed from objprop.c:36
@deffn {Scheme Procedure} object-properties obj
@deffnx {C Function} scm_object_properties (obj)
Return @var{obj}'s property list.
@end deffn

set-object-properties!
@c snarfed from objprop.c:46
@deffn {Scheme Procedure} set-object-properties! obj alist
@deffnx {C Function} scm_set_object_properties_x (obj, alist)
Set @var{obj}'s property list to @var{alist}.
@end deffn

object-property
@c snarfed from objprop.c:57
@deffn {Scheme Procedure} object-property obj key
@deffnx {C Function} scm_object_property (obj, key)
Return the property of @var{obj} with name @var{key}.
@end deffn

set-object-property!
@c snarfed from objprop.c:69
@deffn {Scheme Procedure} set-object-property! obj key value
@deffnx {C Function} scm_set_object_property_x (obj, key, value)
In @var{obj}'s property list, set the property named @var{key}
to @var{value}.
@end deffn

cons
@c snarfed from pairs.c:56
@deffn {Scheme Procedure} cons x y
@deffnx {C Function} scm_cons (x, y)
Return a newly allocated pair whose car is @var{x} and whose
cdr is @var{y}.  The pair is guaranteed to be different (in the
sense of @code{eq?}) from every previously existing object.
@end deffn

pair?
@c snarfed from pairs.c:74
@deffn {Scheme Procedure} pair? x
@deffnx {C Function} scm_pair_p (x)
Return @code{#t} if @var{x} is a pair; otherwise return
@code{#f}.
@end deffn

set-car!
@c snarfed from pairs.c:120
@deffn {Scheme Procedure} set-car! pair value
@deffnx {C Function} scm_set_car_x (pair, value)
Stores @var{value} in the car field of @var{pair}.  The value returned
by @code{set-car!} is unspecified.
@end deffn

set-cdr!
@c snarfed from pairs.c:133
@deffn {Scheme Procedure} set-cdr! pair value
@deffnx {C Function} scm_set_cdr_x (pair, value)
Stores @var{value} in the cdr field of @var{pair}.  The value returned
by @code{set-cdr!} is unspecified.
@end deffn

char-ready?
@c snarfed from ports.c:245
@deffn {Scheme Procedure} char-ready? [port]
@deffnx {C Function} scm_char_ready_p (port)
Return @code{#t} if a character is ready on input @var{port}
and return @code{#f} otherwise.  If @code{char-ready?} returns
@code{#t} then the next @code{read-char} operation on
@var{port} is guaranteed not to hang.  If @var{port} is a file
port at end of file then @code{char-ready?} returns @code{#t}.

@code{char-ready?} exists to make it possible for a
program to accept characters from interactive ports without
getting stuck waiting for input.  Any input editors associated
with such ports must make sure that characters whose existence
has been asserted by @code{char-ready?} cannot be rubbed out.
If @code{char-ready?} were to return @code{#f} at end of file,
a port at end of file would be indistinguishable from an
interactive port that has no ready characters.
@end deffn

drain-input
@c snarfed from ports.c:322
@deffn {Scheme Procedure} drain-input port
@deffnx {C Function} scm_drain_input (port)
This procedure clears a port's input buffers, similar
to the way that force-output clears the output buffer.  The
contents of the buffers are returned as a single string, e.g.,

@lisp
(define p (open-input-file ...))
(drain-input p) => empty string, nothing buffered yet.
(unread-char (read-char p) p)
(drain-input p) => initial chars from p, up to the buffer size.
@end lisp

Draining the buffers may be useful for cleanly finishing
buffered I/O so that the file descriptor can be used directly
for further input.
@end deffn

current-input-port
@c snarfed from ports.c:355
@deffn {Scheme Procedure} current-input-port
@deffnx {C Function} scm_current_input_port ()
Return the current input port.  This is the default port used
by many input procedures.  Initially, @code{current-input-port}
returns the @dfn{standard input} in Unix and C terminology.
@end deffn

current-output-port
@c snarfed from ports.c:367
@deffn {Scheme Procedure} current-output-port
@deffnx {C Function} scm_current_output_port ()
Return the current output port.  This is the default port used
by many output procedures.  Initially,
@code{current-output-port} returns the @dfn{standard output} in
Unix and C terminology.
@end deffn

current-error-port
@c snarfed from ports.c:377
@deffn {Scheme Procedure} current-error-port
@deffnx {C Function} scm_current_error_port ()
Return the port to which errors and warnings should be sent (the
@dfn{standard error} in Unix and C terminology).
@end deffn

current-load-port
@c snarfed from ports.c:387
@deffn {Scheme Procedure} current-load-port
@deffnx {C Function} scm_current_load_port ()
Return the current-load-port.
The load port is used internally by @code{primitive-load}.
@end deffn

set-current-input-port
@c snarfed from ports.c:400
@deffn {Scheme Procedure} set-current-input-port port
@deffnx {Scheme Procedure} set-current-output-port port
@deffnx {Scheme Procedure} set-current-error-port port
@deffnx {C Function} scm_set_current_input_port (port)
Change the ports returned by @code{current-input-port},
@code{current-output-port} and @code{current-error-port}, respectively,
so that they use the supplied @var{port} for input or output.
@end deffn

set-current-output-port
@c snarfed from ports.c:413
@deffn {Scheme Procedure} set-current-output-port port
@deffnx {C Function} scm_set_current_output_port (port)
Set the current default output port to @var{port}.
@end deffn

set-current-error-port
@c snarfed from ports.c:427
@deffn {Scheme Procedure} set-current-error-port port
@deffnx {C Function} scm_set_current_error_port (port)
Set the current default error port to @var{port}.
@end deffn

port-revealed
@c snarfed from ports.c:625
@deffn {Scheme Procedure} port-revealed port
@deffnx {C Function} scm_port_revealed (port)
Return the revealed count for @var{port}.
@end deffn

set-port-revealed!
@c snarfed from ports.c:638
@deffn {Scheme Procedure} set-port-revealed! port rcount
@deffnx {C Function} scm_set_port_revealed_x (port, rcount)
Sets the revealed count for a port to a given value.
The return value is unspecified.
@end deffn

port-mode
@c snarfed from ports.c:699
@deffn {Scheme Procedure} port-mode port
@deffnx {C Function} scm_port_mode (port)
Return the port modes associated with the open port @var{port}.
These will not necessarily be identical to the modes used when
the port was opened, since modes such as "append" which are
used only during port creation are not retained.
@end deffn

close-port
@c snarfed from ports.c:736
@deffn {Scheme Procedure} close-port port
@deffnx {C Function} scm_close_port (port)
Close the specified port object.  Return @code{#t} if it
successfully closes a port or @code{#f} if it was already
closed.  An exception may be raised if an error occurs, for
example when flushing buffered output.  See also @ref{Ports and
File Descriptors, close}, for a procedure which can close file
descriptors.
@end deffn

close-input-port
@c snarfed from ports.c:766
@deffn {Scheme Procedure} close-input-port port
@deffnx {C Function} scm_close_input_port (port)
Close the specified input port object.  The routine has no effect if
the file has already been closed.  An exception may be raised if an
error occurs.  The value returned is unspecified.

See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

close-output-port
@c snarfed from ports.c:781
@deffn {Scheme Procedure} close-output-port port
@deffnx {C Function} scm_close_output_port (port)
Close the specified output port object.  The routine has no effect if
the file has already been closed.  An exception may be raised if an
error occurs.  The value returned is unspecified.

See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

port-for-each
@c snarfed from ports.c:827
@deffn {Scheme Procedure} port-for-each proc
@deffnx {C Function} scm_port_for_each (proc)
Apply @var{proc} to each port in the Guile port table
in turn.  The return value is unspecified.  More specifically,
@var{proc} is applied exactly once to every port that exists
in the system at the time @var{port-for-each} is invoked.
Changes to the port table while @var{port-for-each} is running
have no effect as far as @var{port-for-each} is concerned.
@end deffn

input-port?
@c snarfed from ports.c:845
@deffn {Scheme Procedure} input-port? x
@deffnx {C Function} scm_input_port_p (x)
Return @code{#t} if @var{x} is an input port, otherwise return
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

output-port?
@c snarfed from ports.c:856
@deffn {Scheme Procedure} output-port? x
@deffnx {C Function} scm_output_port_p (x)
Return @code{#t} if @var{x} is an output port, otherwise return
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

port?
@c snarfed from ports.c:868
@deffn {Scheme Procedure} port? x
@deffnx {C Function} scm_port_p (x)
Return a boolean indicating whether @var{x} is a port.
Equivalent to @code{(or (input-port? @var{x}) (output-port?
@var{x}))}.
@end deffn

port-closed?
@c snarfed from ports.c:878
@deffn {Scheme Procedure} port-closed? port
@deffnx {C Function} scm_port_closed_p (port)
Return @code{#t} if @var{port} is closed or @code{#f} if it is
open.
@end deffn

eof-object?
@c snarfed from ports.c:889
@deffn {Scheme Procedure} eof-object? x
@deffnx {C Function} scm_eof_object_p (x)
Return @code{#t} if @var{x} is an end-of-file object; otherwise
return @code{#f}.
@end deffn

force-output
@c snarfed from ports.c:903
@deffn {Scheme Procedure} force-output [port]
@deffnx {C Function} scm_force_output (port)
Flush the specified output port, or the current output port if @var{port}
is omitted.  The current output buffer contents are passed to the
underlying port implementation (e.g., in the case of fports, the
data will be written to the file and the output buffer will be cleared.)
It has no effect on an unbuffered port.

The return value is unspecified.
@end deffn

flush-all-ports
@c snarfed from ports.c:921
@deffn {Scheme Procedure} flush-all-ports
@deffnx {C Function} scm_flush_all_ports ()
Equivalent to calling @code{force-output} on
all open output ports.  The return value is unspecified.
@end deffn

read-char
@c snarfed from ports.c:941
@deffn {Scheme Procedure} read-char [port]
@deffnx {C Function} scm_read_char (port)
Return the next character available from @var{port}, updating
@var{port} to point to the following character.  If no more
characters are available, the end-of-file object is returned.
@end deffn

peek-char
@c snarfed from ports.c:1283
@deffn {Scheme Procedure} peek-char [port]
@deffnx {C Function} scm_peek_char (port)
Return the next character available from @var{port},
@emph{without} updating @var{port} to point to the following
character.  If no more characters are available, the
end-of-file object is returned.

The value returned by
a call to @code{peek-char} is the same as the value that would
have been returned by a call to @code{read-char} on the same
port.  The only difference is that the very next call to
@code{read-char} or @code{peek-char} on that @var{port} will
return the value returned by the preceding call to
@code{peek-char}.  In particular, a call to @code{peek-char} on
an interactive port will hang waiting for input whenever a call
to @code{read-char} would have hung.
@end deffn

unread-char
@c snarfed from ports.c:1306
@deffn {Scheme Procedure} unread-char cobj [port]
@deffnx {C Function} scm_unread_char (cobj, port)
Place @var{char} in @var{port} so that it will be read by the
next read operation.  If called multiple times, the unread characters
will be read again in last-in first-out order.  If @var{port} is
not supplied, the current input port is used.
@end deffn

unread-string
@c snarfed from ports.c:1329
@deffn {Scheme Procedure} unread-string str port
@deffnx {C Function} scm_unread_string (str, port)
Place the string @var{str} in @var{port} so that its characters will be
read in subsequent read operations.  If called multiple times, the
unread characters will be read again in last-in first-out order.  If
@var{port} is not supplied, the current-input-port is used.
@end deffn

seek
@c snarfed from ports.c:1368
@deffn {Scheme Procedure} seek fd_port offset whence
@deffnx {C Function} scm_seek (fd_port, offset, whence)
Sets the current position of @var{fd/port} to the integer
@var{offset}, which is interpreted according to the value of
@var{whence}.

One of the following variables should be supplied for
@var{whence}:
@defvar SEEK_SET
Seek from the beginning of the file.
@end defvar
@defvar SEEK_CUR
Seek from the current position.
@end defvar
@defvar SEEK_END
Seek from the end of the file.
@end defvar
If @var{fd/port} is a file descriptor, the underlying system
call is @code{lseek}.  @var{port} may be a string port.

The value returned is the new position in the file.  This means
that the current position of a port can be obtained using:
@lisp
(seek port 0 SEEK_CUR)
@end lisp
@end deffn

truncate-file
@c snarfed from ports.c:1426
@deffn {Scheme Procedure} truncate-file object [length]
@deffnx {C Function} scm_truncate_file (object, length)
Truncates the object referred to by @var{object} to at most
@var{length} bytes.  @var{object} can be a string containing a
file name or an integer file descriptor or a port.
@var{length} may be omitted if @var{object} is not a file name,
in which case the truncation occurs at the current port
position.  The return value is unspecified.
@end deffn

port-line
@c snarfed from ports.c:1486
@deffn {Scheme Procedure} port-line port
@deffnx {C Function} scm_port_line (port)
Return the current line number for @var{port}.

The first line of a file is 0.  But you might want to add 1
when printing line numbers, since starting from 1 is
traditional in error messages, and likely to be more natural to
non-programmers.
@end deffn

set-port-line!
@c snarfed from ports.c:1498
@deffn {Scheme Procedure} set-port-line! port line
@deffnx {C Function} scm_set_port_line_x (port, line)
Set the current line number for @var{port} to @var{line}.  The
first line of a file is 0.
@end deffn

port-column
@c snarfed from ports.c:1517
@deffn {Scheme Procedure} port-column port
@deffnx {C Function} scm_port_column (port)
Return the current column number of @var{port}.
If the number is
unknown, the result is #f.  Otherwise, the result is a 0-origin integer
- i.e. the first character of the first line is line 0, column 0.
(However, when you display a file position, for example in an error
message, we recommend you add 1 to get 1-origin integers.  This is
because lines and column numbers traditionally start with 1, and that is
what non-programmers will find most natural.)
@end deffn

set-port-column!
@c snarfed from ports.c:1529
@deffn {Scheme Procedure} set-port-column! port column
@deffnx {C Function} scm_set_port_column_x (port, column)
Set the current column of @var{port}.  Before reading the first
character on a line the column should be 0.
@end deffn

port-filename
@c snarfed from ports.c:1543
@deffn {Scheme Procedure} port-filename port
@deffnx {C Function} scm_port_filename (port)
Return the filename associated with @var{port}.  This function returns
the strings "standard input", "standard output" and "standard error"
when called on the current input, output and error ports respectively.
@end deffn

set-port-filename!
@c snarfed from ports.c:1557
@deffn {Scheme Procedure} set-port-filename! port filename
@deffnx {C Function} scm_set_port_filename_x (port, filename)
Change the filename associated with @var{port}, using the current input
port if none is specified.  Note that this does not change the port's
source of data, but only the value that is returned by
@code{port-filename} and reported in diagnostic output.
@end deffn

%make-void-port
@c snarfed from ports.c:1651
@deffn {Scheme Procedure} %make-void-port mode
@deffnx {C Function} scm_sys_make_void_port (mode)
Create and return a new void port.  A void port acts like
@file{/dev/null}.  The @var{mode} argument
specifies the input/output modes for this port: see the
documentation for @code{open-file} in @ref{File Ports}.
@end deffn

print-options-interface
@c snarfed from print.c:87
@deffn {Scheme Procedure} print-options-interface [setting]
@deffnx {C Function} scm_print_options (setting)
Option interface for the print options. Instead of using
this procedure directly, use the procedures
@code{print-enable}, @code{print-disable}, @code{print-set!}
and @code{print-options}.
@end deffn

simple-format
@c snarfed from print.c:929
@deffn {Scheme Procedure} simple-format destination message . args
@deffnx {C Function} scm_simple_format (destination, message, args)
Write @var{message} to @var{destination}, defaulting to
the current output port.
@var{message} can contain @code{~A} (was @code{%s}) and
@code{~S} (was @code{%S}) escapes.  When printed,
the escapes are replaced with corresponding members of
@var{ARGS}:
@code{~A} formats using @code{display} and @code{~S} formats
using @code{write}.
If @var{destination} is @code{#t}, then use the current output
port, if @var{destination} is @code{#f}, then return a string
containing the formatted text. Does not add a trailing newline.
@end deffn

newline
@c snarfed from print.c:1019
@deffn {Scheme Procedure} newline [port]
@deffnx {C Function} scm_newline (port)
Send a newline to @var{port}.
If @var{port} is omitted, send to the current output port.
@end deffn

write-char
@c snarfed from print.c:1034
@deffn {Scheme Procedure} write-char chr [port]
@deffnx {C Function} scm_write_char (chr, port)
Send character @var{chr} to @var{port}.
@end deffn

port-with-print-state
@c snarfed from print.c:1088
@deffn {Scheme Procedure} port-with-print-state port [pstate]
@deffnx {C Function} scm_port_with_print_state (port, pstate)
Create a new port which behaves like @var{port}, but with an
included print state @var{pstate}.  @var{pstate} is optional.
If @var{pstate} isn't supplied and @var{port} already has
a print state, the old print state is reused.
@end deffn

get-print-state
@c snarfed from print.c:1101
@deffn {Scheme Procedure} get-print-state port
@deffnx {C Function} scm_get_print_state (port)
Return the print state of the port @var{port}. If @var{port}
has no associated print state, @code{#f} is returned.
@end deffn

procedure-properties
@c snarfed from procprop.c:160
@deffn {Scheme Procedure} procedure-properties proc
@deffnx {C Function} scm_procedure_properties (proc)
Return @var{obj}'s property list.
@end deffn

set-procedure-properties!
@c snarfed from procprop.c:173
@deffn {Scheme Procedure} set-procedure-properties! proc new_val
@deffnx {C Function} scm_set_procedure_properties_x (proc, new_val)
Set @var{obj}'s property list to @var{alist}.
@end deffn

procedure-property
@c snarfed from procprop.c:186
@deffn {Scheme Procedure} procedure-property p k
@deffnx {C Function} scm_procedure_property (p, k)
Return the property of @var{obj} with name @var{key}.
@end deffn

set-procedure-property!
@c snarfed from procprop.c:209
@deffn {Scheme Procedure} set-procedure-property! p k v
@deffnx {C Function} scm_set_procedure_property_x (p, k, v)
In @var{obj}'s property list, set the property named @var{key} to
@var{value}.
@end deffn

procedure?
@c snarfed from procs.c:162
@deffn {Scheme Procedure} procedure? obj
@deffnx {C Function} scm_procedure_p (obj)
Return @code{#t} if @var{obj} is a procedure.
@end deffn

closure?
@c snarfed from procs.c:189
@deffn {Scheme Procedure} closure? obj
@deffnx {C Function} scm_closure_p (obj)
Return @code{#t} if @var{obj} is a closure.
@end deffn

thunk?
@c snarfed from procs.c:198
@deffn {Scheme Procedure} thunk? obj
@deffnx {C Function} scm_thunk_p (obj)
Return @code{#t} if @var{obj} is a thunk.
@end deffn

procedure-documentation
@c snarfed from procs.c:248
@deffn {Scheme Procedure} procedure-documentation proc
@deffnx {C Function} scm_procedure_documentation (proc)
Return the documentation string associated with @code{proc}.  By
convention, if a procedure contains more than one expression and the
first expression is a string constant, that string is assumed to contain
documentation for that procedure.
@end deffn

procedure-with-setter?
@c snarfed from procs.c:284
@deffn {Scheme Procedure} procedure-with-setter? obj
@deffnx {C Function} scm_procedure_with_setter_p (obj)
Return @code{#t} if @var{obj} is a procedure with an
associated setter procedure.
@end deffn

make-procedure-with-setter
@c snarfed from procs.c:294
@deffn {Scheme Procedure} make-procedure-with-setter procedure setter
@deffnx {C Function} scm_make_procedure_with_setter (procedure, setter)
Create a new procedure which behaves like @var{procedure}, but
with the associated setter @var{setter}.
@end deffn

procedure
@c snarfed from procs.c:308
@deffn {Scheme Procedure} procedure proc
@deffnx {C Function} scm_procedure (proc)
Return the procedure of @var{proc}, which must be an
applicable struct.
@end deffn

primitive-make-property
@c snarfed from properties.c:40
@deffn {Scheme Procedure} primitive-make-property not_found_proc
@deffnx {C Function} scm_primitive_make_property (not_found_proc)
Create a @dfn{property token} that can be used with
@code{primitive-property-ref} and @code{primitive-property-set!}.
See @code{primitive-property-ref} for the significance of
@var{not_found_proc}.
@end deffn

primitive-property-ref
@c snarfed from properties.c:59
@deffn {Scheme Procedure} primitive-property-ref prop obj
@deffnx {C Function} scm_primitive_property_ref (prop, obj)
Return the property @var{prop} of @var{obj}.

When no value has yet been associated with @var{prop} and
@var{obj}, the @var{not-found-proc} from @var{prop} is used.  A
call @code{(@var{not-found-proc} @var{prop} @var{obj})} is made
and the result set as the property value.  If
@var{not-found-proc} is @code{#f} then @code{#f} is the
property value.
@end deffn

primitive-property-set!
@c snarfed from properties.c:90
@deffn {Scheme Procedure} primitive-property-set! prop obj val
@deffnx {C Function} scm_primitive_property_set_x (prop, obj, val)
Set the property @var{prop} of @var{obj} to @var{val}.
@end deffn

primitive-property-del!
@c snarfed from properties.c:111
@deffn {Scheme Procedure} primitive-property-del! prop obj
@deffnx {C Function} scm_primitive_property_del_x (prop, obj)
Remove any value associated with @var{prop} and @var{obj}.
@end deffn

random
@c snarfed from random.c:347
@deffn {Scheme Procedure} random n [state]
@deffnx {C Function} scm_random (n, state)
Return a number in [0, N).

Accepts a positive integer or real n and returns a
number of the same type between zero (inclusive) and
N (exclusive). The values returned have a uniform
distribution.

The optional argument @var{state} must be of the type produced
by @code{seed->random-state}. It defaults to the value of the
variable @var{*random-state*}. This object is used to maintain
the state of the pseudo-random-number generator and is altered
as a side effect of the random operation.
@end deffn

copy-random-state
@c snarfed from random.c:372
@deffn {Scheme Procedure} copy-random-state [state]
@deffnx {C Function} scm_copy_random_state (state)
Return a copy of the random state @var{state}.
@end deffn

seed->random-state
@c snarfed from random.c:384
@deffn {Scheme Procedure} seed->random-state seed
@deffnx {C Function} scm_seed_to_random_state (seed)
Return a new random state using @var{seed}.
@end deffn

random:uniform
@c snarfed from random.c:402
@deffn {Scheme Procedure} random:uniform [state]
@deffnx {C Function} scm_random_uniform (state)
Return a uniformly distributed inexact real random number in
[0,1).
@end deffn

random:normal
@c snarfed from random.c:417
@deffn {Scheme Procedure} random:normal [state]
@deffnx {C Function} scm_random_normal (state)
Return an inexact real in a normal distribution.  The
distribution used has mean 0 and standard deviation 1.  For a
normal distribution with mean m and standard deviation d use
@code{(+ m (* d (random:normal)))}.
@end deffn

random:solid-sphere!
@c snarfed from random.c:500
@deffn {Scheme Procedure} random:solid-sphere! v [state]
@deffnx {C Function} scm_random_solid_sphere_x (v, state)
Fills @var{vect} with inexact real random numbers the sum of
whose squares is less than 1.0.  Thinking of @var{vect} as
coordinates in space of dimension @var{n} @math{=}
@code{(vector-length @var{vect})}, the coordinates are
uniformly distributed within the unit @var{n}-sphere.
@end deffn

random:hollow-sphere!
@c snarfed from random.c:522
@deffn {Scheme Procedure} random:hollow-sphere! v [state]
@deffnx {C Function} scm_random_hollow_sphere_x (v, state)
Fills vect with inexact real random numbers
the sum of whose squares is equal to 1.0.
Thinking of vect as coordinates in space of
dimension n = (vector-length vect), the coordinates
are uniformly distributed over the surface of the
unit n-sphere.
@end deffn

random:normal-vector!
@c snarfed from random.c:539
@deffn {Scheme Procedure} random:normal-vector! v [state]
@deffnx {C Function} scm_random_normal_vector_x (v, state)
Fills vect with inexact real random numbers that are
independent and standard normally distributed
(i.e., with mean 0 and variance 1).
@end deffn

random:exp
@c snarfed from random.c:577
@deffn {Scheme Procedure} random:exp [state]
@deffnx {C Function} scm_random_exp (state)
Return an inexact real in an exponential distribution with mean
1.  For an exponential distribution with mean u use (* u
(random:exp)).
@end deffn

%read-delimited!
@c snarfed from rdelim.c:55
@deffn {Scheme Procedure} %read-delimited! delims str gobble [port [start [end]]]
@deffnx {C Function} scm_read_delimited_x (delims, str, gobble, port, start, end)
Read characters from @var{port} into @var{str} until one of the
characters in the @var{delims} string is encountered.  If
@var{gobble} is true, discard the delimiter character;
otherwise, leave it in the input stream for the next read.  If
@var{port} is not specified, use the value of
@code{(current-input-port)}.  If @var{start} or @var{end} are
specified, store data only into the substring of @var{str}
bounded by @var{start} and @var{end} (which default to the
beginning and end of the string, respectively).

 Return a pair consisting of the delimiter that terminated the
string and the number of characters read.  If reading stopped
at the end of file, the delimiter returned is the
@var{eof-object}; if the string was filled without encountering
a delimiter, this value is @code{#f}.
@end deffn

%read-line
@c snarfed from rdelim.c:202
@deffn {Scheme Procedure} %read-line [port]
@deffnx {C Function} scm_read_line (port)
Read a newline-terminated line from @var{port}, allocating storage as
necessary.  The newline terminator (if any) is removed from the string,
and a pair consisting of the line and its delimiter is returned.  The
delimiter may be either a newline or the @var{eof-object}; if
@code{%read-line} is called at the end of file, it returns the pair
@code{(#<eof> . #<eof>)}.
@end deffn

write-line
@c snarfed from rdelim.c:255
@deffn {Scheme Procedure} write-line obj [port]
@deffnx {C Function} scm_write_line (obj, port)
Display @var{obj} and a newline character to @var{port}.  If
@var{port} is not specified, @code{(current-output-port)} is
used.  This function is equivalent to:
@lisp
(display obj [port])
(newline [port])
@end lisp
@end deffn

read-options-interface
@c snarfed from read.c:110
@deffn {Scheme Procedure} read-options-interface [setting]
@deffnx {C Function} scm_read_options (setting)
Option interface for the read options. Instead of using
this procedure directly, use the procedures @code{read-enable},
@code{read-disable}, @code{read-set!} and @code{read-options}.
@end deffn

read
@c snarfed from read.c:130
@deffn {Scheme Procedure} read [port]
@deffnx {C Function} scm_read (port)
Read an s-expression from the input port @var{port}, or from
the current input port if @var{port} is not specified.
Any whitespace before the next token is discarded.
@end deffn

read-hash-extend
@c snarfed from read.c:898
@deffn {Scheme Procedure} read-hash-extend chr proc
@deffnx {C Function} scm_read_hash_extend (chr, proc)
Install the procedure @var{proc} for reading expressions
starting with the character sequence @code{#} and @var{chr}.
@var{proc} will be called with two arguments:  the character
@var{chr} and the port to read further data from. The object
returned will be the return value of @code{read}. 
Passing @code{#f} for @var{proc} will remove a previous setting. 

@end deffn

call-with-dynamic-root
@c snarfed from root.c:160
@deffn {Scheme Procedure} call-with-dynamic-root thunk handler
@deffnx {C Function} scm_call_with_dynamic_root (thunk, handler)
Call @var{thunk} with a new dynamic state and withina continuation barrier.  The @var{handler} catches allotherwise uncaught throws and executes within the samedynamic context as @var{thunk}.
@end deffn

dynamic-root
@c snarfed from root.c:171
@deffn {Scheme Procedure} dynamic-root
@deffnx {C Function} scm_dynamic_root ()
Return an object representing the current dynamic root.

These objects are only useful for comparison using @code{eq?}.

@end deffn

read-string!/partial
@c snarfed from rw.c:101
@deffn {Scheme Procedure} read-string!/partial str [port_or_fdes [start [end]]]
@deffnx {C Function} scm_read_string_x_partial (str, port_or_fdes, start, end)
Read characters from a port or file descriptor into a
string @var{str}.  A port must have an underlying file
descriptor --- a so-called fport.  This procedure is
scsh-compatible and can efficiently read large strings.
It will:

@itemize
@item
attempt to fill the entire string, unless the @var{start}
and/or @var{end} arguments are supplied.  i.e., @var{start}
defaults to 0 and @var{end} defaults to
@code{(string-length str)}
@item
use the current input port if @var{port_or_fdes} is not
supplied.
@item
return fewer than the requested number of characters in some
cases, e.g., on end of file, if interrupted by a signal, or if
not all the characters are immediately available.
@item
wait indefinitely for some input if no characters are
currently available,
unless the port is in non-blocking mode.
@item
read characters from the port's input buffers if available,
instead from the underlying file descriptor.
@item
return @code{#f} if end-of-file is encountered before reading
any characters, otherwise return the number of characters
read.
@item
return 0 if the port is in non-blocking mode and no characters
are immediately available.
@item
return 0 if the request is for 0 bytes, with no
end-of-file check.
@end itemize
@end deffn

write-string/partial
@c snarfed from rw.c:205
@deffn {Scheme Procedure} write-string/partial str [port_or_fdes [start [end]]]
@deffnx {C Function} scm_write_string_partial (str, port_or_fdes, start, end)
Write characters from a string @var{str} to a port or file
descriptor.  A port must have an underlying file descriptor
--- a so-called fport.  This procedure is
scsh-compatible and can efficiently write large strings.
It will:

@itemize
@item
attempt to write the entire string, unless the @var{start}
and/or @var{end} arguments are supplied.  i.e., @var{start}
defaults to 0 and @var{end} defaults to
@code{(string-length str)}
@item
use the current output port if @var{port_of_fdes} is not
supplied.
@item
in the case of a buffered port, store the characters in the
port's output buffer, if all will fit.  If they will not fit
then any existing buffered characters will be flushed
before attempting
to write the new characters directly to the underlying file
descriptor.  If the port is in non-blocking mode and
buffered characters can not be flushed immediately, then an
@code{EAGAIN} system-error exception will be raised (Note:
scsh does not support the use of non-blocking buffered ports.)
@item
write fewer than the requested number of
characters in some cases, e.g., if interrupted by a signal or
if not all of the output can be accepted immediately.
@item
wait indefinitely for at least one character
from @var{str} to be accepted by the port, unless the port is
in non-blocking mode.
@item
return the number of characters accepted by the port.
@item
return 0 if the port is in non-blocking mode and can not accept
at least one character from @var{str} immediately
@item
return 0 immediately if the request size is 0 bytes.
@end itemize
@end deffn

sigaction
@c snarfed from scmsigs.c:253
@deffn {Scheme Procedure} sigaction signum [handler [flags [thread]]]
@deffnx {C Function} scm_sigaction_for_thread (signum, handler, flags, thread)
Install or report the signal handler for a specified signal.

@var{signum} is the signal number, which can be specified using the value
of variables such as @code{SIGINT}.

If @var{handler} is omitted, @code{sigaction} returns a pair: the
CAR is the current
signal hander, which will be either an integer with the value @code{SIG_DFL}
(default action) or @code{SIG_IGN} (ignore), or the Scheme procedure which
handles the signal, or @code{#f} if a non-Scheme procedure handles the
signal.  The CDR contains the current @code{sigaction} flags for the handler.

If @var{handler} is provided, it is installed as the new handler for
@var{signum}.  @var{handler} can be a Scheme procedure taking one
argument, or the value of @code{SIG_DFL} (default action) or
@code{SIG_IGN} (ignore), or @code{#f} to restore whatever signal handler
was installed before @code{sigaction} was first used.  When
a scheme procedure has been specified, that procedure will run
in the given @var{thread}.   When no thread has been given, the
thread that made this call to @code{sigaction} is used.
Flags can optionally be specified for the new handler (@code{SA_RESTART} will
always be added if it's available and the system is using restartable
system calls.)  The return value is a pair with information about the
old handler as described above.

This interface does not provide access to the "signal blocking"
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.
@end deffn

restore-signals
@c snarfed from scmsigs.c:427
@deffn {Scheme Procedure} restore-signals
@deffnx {C Function} scm_restore_signals ()
Return all signal handlers to the values they had before any call to
@code{sigaction} was made.  The return value is unspecified.
@end deffn

alarm
@c snarfed from scmsigs.c:464
@deffn {Scheme Procedure} alarm i
@deffnx {C Function} scm_alarm (i)
Set a timer to raise a @code{SIGALRM} signal after the specified
number of seconds (an integer).  It's advisable to install a signal
handler for
@code{SIGALRM} beforehand, since the default action is to terminate
the process.

The return value indicates the time remaining for the previous alarm,
if any.  The new value replaces the previous alarm.  If there was
no previous alarm, the return value is zero.
@end deffn

setitimer
@c snarfed from scmsigs.c:491
@deffn {Scheme Procedure} setitimer which_timer interval_seconds interval_microseconds value_seconds value_microseconds
@deffnx {C Function} scm_setitimer (which_timer, interval_seconds, interval_microseconds, value_seconds, value_microseconds)
Set the timer specified by @var{which_timer} according to the given
@var{interval_seconds}, @var{interval_microseconds},
@var{value_seconds}, and @var{value_microseconds} values.

Return information about the timer's previous setting.
Errors are handled as described in the guile info pages under ``POSIX
Interface Conventions''.

The timers available are: @code{ITIMER_REAL}, @code{ITIMER_VIRTUAL},
and @code{ITIMER_PROF}.

The return value will be a list of two cons pairs representing the
current state of the given timer.  The first pair is the seconds and
microseconds of the timer @code{it_interval}, and the second pair is
the seconds and microseconds of the timer @code{it_value}.
@end deffn

getitimer
@c snarfed from scmsigs.c:532
@deffn {Scheme Procedure} getitimer which_timer
@deffnx {C Function} scm_getitimer (which_timer)
Return information about the timer specified by @var{which_timer}
Errors are handled as described in the guile info pages under ``POSIX
Interface Conventions''.

The timers available are: @code{ITIMER_REAL}, @code{ITIMER_VIRTUAL},
and @code{ITIMER_PROF}.

The return value will be a list of two cons pairs representing the
current state of the given timer.  The first pair is the seconds and
microseconds of the timer @code{it_interval}, and the second pair is
the seconds and microseconds of the timer @code{it_value}.
@end deffn

pause
@c snarfed from scmsigs.c:559
@deffn {Scheme Procedure} pause
@deffnx {C Function} scm_pause ()
Pause the current process (thread?) until a signal arrives whose
action is to either terminate the current process or invoke a
handler procedure.  The return value is unspecified.
@end deffn

sleep
@c snarfed from scmsigs.c:572
@deffn {Scheme Procedure} sleep i
@deffnx {C Function} scm_sleep (i)
Wait for the given number of seconds (an integer) or until a signal
arrives.  The return value is zero if the time elapses or the number
of seconds remaining otherwise.
@end deffn

usleep
@c snarfed from scmsigs.c:581
@deffn {Scheme Procedure} usleep i
@deffnx {C Function} scm_usleep (i)
Sleep for @var{i} microseconds.
@end deffn

raise
@c snarfed from scmsigs.c:591
@deffn {Scheme Procedure} raise sig
@deffnx {C Function} scm_raise (sig)
Sends a specified signal @var{sig} to the current process, where
@var{sig} is as described for the kill procedure.
@end deffn

system
@c snarfed from simpos.c:64
@deffn {Scheme Procedure} system [cmd]
@deffnx {C Function} scm_system (cmd)
Execute @var{cmd} using the operating system's "command
processor".  Under Unix this is usually the default shell
@code{sh}.  The value returned is @var{cmd}'s exit status as
returned by @code{waitpid}, which can be interpreted using
@code{status:exit-val} and friends.

If @code{system} is called without arguments, return a boolean
indicating whether the command processor is available.
@end deffn

system*
@c snarfed from simpos.c:114
@deffn {Scheme Procedure} system* . args
@deffnx {C Function} scm_system_star (args)
Execute the command indicated by @var{args}.  The first element must
be a string indicating the command to be executed, and the remaining
items must be strings representing each of the arguments to that
command.

This function returns the exit status of the command as provided by
@code{waitpid}.  This value can be handled with @code{status:exit-val}
and the related functions.

@code{system*} is similar to @code{system}, but accepts only one
string per-argument, and performs no shell interpretation.  The
command is executed using fork and execlp.  Accordingly this function
may be safer than @code{system} in situations where shell
interpretation is not required.

Example: (system* "echo" "foo" "bar")
@end deffn

getenv
@c snarfed from simpos.c:184
@deffn {Scheme Procedure} getenv nam
@deffnx {C Function} scm_getenv (nam)
Looks up the string @var{name} in the current environment.  The return
value is @code{#f} unless a string of the form @code{NAME=VALUE} is
found, in which case the string @code{VALUE} is returned.
@end deffn

primitive-exit
@c snarfed from simpos.c:200
@deffn {Scheme Procedure} primitive-exit [status]
@deffnx {C Function} scm_primitive_exit (status)
Terminate the current process without unwinding the Scheme stack.
This is would typically be useful after a fork.  The exit status
is @var{status} if supplied, otherwise zero.
@end deffn

restricted-vector-sort!
@c snarfed from sort.c:78
@deffn {Scheme Procedure} restricted-vector-sort! vec less startpos endpos
@deffnx {C Function} scm_restricted_vector_sort_x (vec, less, startpos, endpos)
Sort the vector @var{vec}, using @var{less} for comparing
the vector elements.  @var{startpos} (inclusively) and
@var{endpos} (exclusively) delimit
the range of the vector which gets sorted.  The return value
is not specified.
@end deffn

sorted?
@c snarfed from sort.c:111
@deffn {Scheme Procedure} sorted? items less
@deffnx {C Function} scm_sorted_p (items, less)
Return @code{#t} iff @var{items} is a list or a vector such that
for all 1 <= i <= m, the predicate @var{less} returns true when
applied to all elements i - 1 and i
@end deffn

merge
@c snarfed from sort.c:186
@deffn {Scheme Procedure} merge alist blist less
@deffnx {C Function} scm_merge (alist, blist, less)
Merge two already sorted lists into one.
Given two lists @var{alist} and @var{blist}, such that
@code{(sorted? alist less?)} and @code{(sorted? blist less?)},
return a new list in which the elements of @var{alist} and
@var{blist} have been stably interleaved so that
@code{(sorted? (merge alist blist less?) less?)}.
Note:  this does _not_ accept vectors.
@end deffn

merge!
@c snarfed from sort.c:303
@deffn {Scheme Procedure} merge! alist blist less
@deffnx {C Function} scm_merge_x (alist, blist, less)
Takes two lists @var{alist} and @var{blist} such that
@code{(sorted? alist less?)} and @code{(sorted? blist less?)} and
returns a new list in which the elements of @var{alist} and
@var{blist} have been stably interleaved so that
 @code{(sorted? (merge alist blist less?) less?)}.
This is the destructive variant of @code{merge}
Note:  this does _not_ accept vectors.
@end deffn

sort!
@c snarfed from sort.c:373
@deffn {Scheme Procedure} sort! items less
@deffnx {C Function} scm_sort_x (items, less)
Sort the sequence @var{items}, which may be a list or a
vector.  @var{less} is used for comparing the sequence
elements.  The sorting is destructive, that means that the
input sequence is modified to produce the sorted result.
This is not a stable sort.
@end deffn

sort
@c snarfed from sort.c:404
@deffn {Scheme Procedure} sort items less
@deffnx {C Function} scm_sort (items, less)
Sort the sequence @var{items}, which may be a list or a
vector.  @var{less} is used for comparing the sequence
elements.  This is not a stable sort.
@end deffn

stable-sort!
@c snarfed from sort.c:487
@deffn {Scheme Procedure} stable-sort! items less
@deffnx {C Function} scm_stable_sort_x (items, less)
Sort the sequence @var{items}, which may be a list or a
vector. @var{less} is used for comparing the sequence elements.
The sorting is destructive, that means that the input sequence
is modified to produce the sorted result.
This is a stable sort.
@end deffn

stable-sort
@c snarfed from sort.c:531
@deffn {Scheme Procedure} stable-sort items less
@deffnx {C Function} scm_stable_sort (items, less)
Sort the sequence @var{items}, which may be a list or a
vector. @var{less} is used for comparing the sequence elements.
This is a stable sort.
@end deffn

sort-list!
@c snarfed from sort.c:549
@deffn {Scheme Procedure} sort-list! items less
@deffnx {C Function} scm_sort_list_x (items, less)
Sort the list @var{items}, using @var{less} for comparing the
list elements. The sorting is destructive, that means that the
input list is modified to produce the sorted result.
This is a stable sort.
@end deffn

sort-list
@c snarfed from sort.c:564
@deffn {Scheme Procedure} sort-list items less
@deffnx {C Function} scm_sort_list (items, less)
Sort the list @var{items}, using @var{less} for comparing the
list elements. This is a stable sort.
@end deffn

source-properties
@c snarfed from srcprop.c:153
@deffn {Scheme Procedure} source-properties obj
@deffnx {C Function} scm_source_properties (obj)
Return the source property association list of @var{obj}.
@end deffn

set-source-properties!
@c snarfed from srcprop.c:176
@deffn {Scheme Procedure} set-source-properties! obj plist
@deffnx {C Function} scm_set_source_properties_x (obj, plist)
Install the association list @var{plist} as the source property
list for @var{obj}.
@end deffn

source-property
@c snarfed from srcprop.c:194
@deffn {Scheme Procedure} source-property obj key
@deffnx {C Function} scm_source_property (obj, key)
Return the source property specified by @var{key} from
@var{obj}'s source property list.
@end deffn

set-source-property!
@c snarfed from srcprop.c:225
@deffn {Scheme Procedure} set-source-property! obj key datum
@deffnx {C Function} scm_set_source_property_x (obj, key, datum)
Set the source property of object @var{obj}, which is specified by
@var{key} to @var{datum}.  Normally, the key will be a symbol.
@end deffn

stack?
@c snarfed from stacks.c:391
@deffn {Scheme Procedure} stack? obj
@deffnx {C Function} scm_stack_p (obj)
Return @code{#t} if @var{obj} is a calling stack.
@end deffn

make-stack
@c snarfed from stacks.c:422
@deffn {Scheme Procedure} make-stack obj . args
@deffnx {C Function} scm_make_stack (obj, args)
Create a new stack. If @var{obj} is @code{#t}, the current
evaluation stack is used for creating the stack frames,
otherwise the frames are taken from @var{obj} (which must be
either a debug object or a continuation).

@var{args} should be a list containing any combination of
integer, procedure and @code{#t} values.

These values specify various ways of cutting away uninteresting
stack frames from the top and bottom of the stack that
@code{make-stack} returns.  They come in pairs like this:
@code{(@var{inner_cut_1} @var{outer_cut_1} @var{inner_cut_2}
@var{outer_cut_2} @dots{})}.

Each @var{inner_cut_N} can be @code{#t}, an integer, or a
procedure.  @code{#t} means to cut away all frames up to but
excluding the first user module frame.  An integer means to cut
away exactly that number of frames.  A procedure means to cut
away all frames up to but excluding the application frame whose
procedure matches the specified one.

Each @var{outer_cut_N} can be an integer or a procedure.  An
integer means to cut away that number of frames.  A procedure
means to cut away frames down to but excluding the application
frame whose procedure matches the specified one.

If the @var{outer_cut_N} of the last pair is missing, it is
taken as 0.
@end deffn

stack-id
@c snarfed from stacks.c:511
@deffn {Scheme Procedure} stack-id stack
@deffnx {C Function} scm_stack_id (stack)
Return the identifier given to @var{stack} by @code{start-stack}.
@end deffn

stack-ref
@c snarfed from stacks.c:549
@deffn {Scheme Procedure} stack-ref stack index
@deffnx {C Function} scm_stack_ref (stack, index)
Return the @var{index}'th frame from @var{stack}.
@end deffn

stack-length
@c snarfed from stacks.c:562
@deffn {Scheme Procedure} stack-length stack
@deffnx {C Function} scm_stack_length (stack)
Return the length of @var{stack}.
@end deffn

frame?
@c snarfed from stacks.c:575
@deffn {Scheme Procedure} frame? obj
@deffnx {C Function} scm_frame_p (obj)
Return @code{#t} if @var{obj} is a stack frame.
@end deffn

last-stack-frame
@c snarfed from stacks.c:586
@deffn {Scheme Procedure} last-stack-frame obj
@deffnx {C Function} scm_last_stack_frame (obj)
Return a stack which consists of a single frame, which is the
last stack frame for @var{obj}. @var{obj} must be either a
debug object or a continuation.
@end deffn

frame-number
@c snarfed from stacks.c:625
@deffn {Scheme Procedure} frame-number frame
@deffnx {C Function} scm_frame_number (frame)
Return the frame number of @var{frame}.
@end deffn

frame-source
@c snarfed from stacks.c:635
@deffn {Scheme Procedure} frame-source frame
@deffnx {C Function} scm_frame_source (frame)
Return the source of @var{frame}.
@end deffn

frame-procedure
@c snarfed from stacks.c:646
@deffn {Scheme Procedure} frame-procedure frame
@deffnx {C Function} scm_frame_procedure (frame)
Return the procedure for @var{frame}, or @code{#f} if no
procedure is associated with @var{frame}.
@end deffn

frame-arguments
@c snarfed from stacks.c:658
@deffn {Scheme Procedure} frame-arguments frame
@deffnx {C Function} scm_frame_arguments (frame)
Return the arguments of @var{frame}.
@end deffn

frame-previous
@c snarfed from stacks.c:669
@deffn {Scheme Procedure} frame-previous frame
@deffnx {C Function} scm_frame_previous (frame)
Return the previous frame of @var{frame}, or @code{#f} if
@var{frame} is the first frame in its stack.
@end deffn

frame-next
@c snarfed from stacks.c:685
@deffn {Scheme Procedure} frame-next frame
@deffnx {C Function} scm_frame_next (frame)
Return the next frame of @var{frame}, or @code{#f} if
@var{frame} is the last frame in its stack.
@end deffn

frame-real?
@c snarfed from stacks.c:700
@deffn {Scheme Procedure} frame-real? frame
@deffnx {C Function} scm_frame_real_p (frame)
Return @code{#t} if @var{frame} is a real frame.
@end deffn

frame-procedure?
@c snarfed from stacks.c:710
@deffn {Scheme Procedure} frame-procedure? frame
@deffnx {C Function} scm_frame_procedure_p (frame)
Return @code{#t} if a procedure is associated with @var{frame}.
@end deffn

frame-evaluating-args?
@c snarfed from stacks.c:720
@deffn {Scheme Procedure} frame-evaluating-args? frame
@deffnx {C Function} scm_frame_evaluating_args_p (frame)
Return @code{#t} if @var{frame} contains evaluated arguments.
@end deffn

frame-overflow?
@c snarfed from stacks.c:730
@deffn {Scheme Procedure} frame-overflow? frame
@deffnx {C Function} scm_frame_overflow_p (frame)
Return @code{#t} if @var{frame} is an overflow frame.
@end deffn

get-internal-real-time
@c snarfed from stime.c:133
@deffn {Scheme Procedure} get-internal-real-time
@deffnx {C Function} scm_get_internal_real_time ()
Return the number of time units since the interpreter was
started.
@end deffn

times
@c snarfed from stime.c:180
@deffn {Scheme Procedure} times
@deffnx {C Function} scm_times ()
Return an object with information about real and processor
time.  The following procedures accept such an object as an
argument and return a selected component:

@table @code
@item tms:clock
The current real time, expressed as time units relative to an
arbitrary base.
@item tms:utime
The CPU time units used by the calling process.
@item tms:stime
The CPU time units used by the system on behalf of the calling
process.
@item tms:cutime
The CPU time units used by terminated child processes of the
calling process, whose status has been collected (e.g., using
@code{waitpid}).
@item tms:cstime
Similarly, the CPU times units used by the system on behalf of
terminated child processes.
@end table
@end deffn

get-internal-run-time
@c snarfed from stime.c:212
@deffn {Scheme Procedure} get-internal-run-time
@deffnx {C Function} scm_get_internal_run_time ()
Return the number of time units of processor time used by the
interpreter.  Both @emph{system} and @emph{user} time are
included but subprocesses are not.
@end deffn

current-time
@c snarfed from stime.c:229
@deffn {Scheme Procedure} current-time
@deffnx {C Function} scm_current_time ()
Return the number of seconds since 1970-01-01 00:00:00 UTC,
excluding leap seconds.
@end deffn

gettimeofday
@c snarfed from stime.c:248
@deffn {Scheme Procedure} gettimeofday
@deffnx {C Function} scm_gettimeofday ()
Return a pair containing the number of seconds and microseconds
since 1970-01-01 00:00:00 UTC, excluding leap seconds.  Note:
whether true microsecond resolution is available depends on the
operating system.
@end deffn

localtime
@c snarfed from stime.c:364
@deffn {Scheme Procedure} localtime time [zone]
@deffnx {C Function} scm_localtime (time, zone)
Return an object representing the broken down components of
@var{time}, an integer like the one returned by
@code{current-time}.  The time zone for the calculation is
optionally specified by @var{zone} (a string), otherwise the
@code{TZ} environment variable or the system default is used.
@end deffn

gmtime
@c snarfed from stime.c:449
@deffn {Scheme Procedure} gmtime time
@deffnx {C Function} scm_gmtime (time)
Return an object representing the broken down components of
@var{time}, an integer like the one returned by
@code{current-time}.  The values are calculated for UTC.
@end deffn

mktime
@c snarfed from stime.c:517
@deffn {Scheme Procedure} mktime sbd_time [zone]
@deffnx {C Function} scm_mktime (sbd_time, zone)
@var{bd-time} is an object representing broken down time and @code{zone}
is an optional time zone specifier (otherwise the TZ environment variable
or the system default is used).

Returns a pair: the car is a corresponding
integer time value like that returned
by @code{current-time}; the cdr is a broken down time object, similar to
as @var{bd-time} but with normalized values.
@end deffn

tzset
@c snarfed from stime.c:603
@deffn {Scheme Procedure} tzset
@deffnx {C Function} scm_tzset ()
Initialize the timezone from the TZ environment variable
or the system default.  It's not usually necessary to call this procedure
since it's done automatically by other procedures that depend on the
timezone.
@end deffn

strftime
@c snarfed from stime.c:620
@deffn {Scheme Procedure} strftime format stime
@deffnx {C Function} scm_strftime (format, stime)
Formats a time specification @var{time} using @var{template}.  @var{time}
is an object with time components in the form returned by @code{localtime}
or @code{gmtime}.  @var{template} is a string which can include formatting
specifications introduced by a @code{%} character.  The formatting of
month and day names is dependent on the current locale.  The value returned
is the formatted string.
@xref{Formatting Date and Time, , , libc, The GNU C Library Reference Manual}.)
@end deffn

strptime
@c snarfed from stime.c:721
@deffn {Scheme Procedure} strptime format string
@deffnx {C Function} scm_strptime (format, string)
Performs the reverse action to @code{strftime}, parsing
@var{string} according to the specification supplied in
@var{template}.  The interpretation of month and day names is
dependent on the current locale.  The value returned is a pair.
The car has an object with time components
in the form returned by @code{localtime} or @code{gmtime},
but the time zone components
are not usefully set.
The cdr reports the number of characters from @var{string}
which were used for the conversion.
@end deffn

string?
@c snarfed from strings.c:526
@deffn {Scheme Procedure} string? obj
@deffnx {C Function} scm_string_p (obj)
Return @code{#t} if @var{obj} is a string, else @code{#f}.
@end deffn

list->string
@c snarfed from strings.c:534
@deffn {Scheme Procedure} list->string
implemented by the C function "scm_string"
@end deffn

string
@c snarfed from strings.c:540
@deffn {Scheme Procedure} string . chrs
@deffnx {Scheme Procedure} list->string chrs
@deffnx {C Function} scm_string (chrs)
Return a newly allocated string composed of the arguments,
@var{chrs}.
@end deffn

make-string
@c snarfed from strings.c:578
@deffn {Scheme Procedure} make-string k [chr]
@deffnx {C Function} scm_make_string (k, chr)
Return a newly allocated string of
length @var{k}.  If @var{chr} is given, then all elements of
the string are initialized to @var{chr}, otherwise the contents
of the @var{string} are unspecified.
@end deffn

string-length
@c snarfed from strings.c:604
@deffn {Scheme Procedure} string-length string
@deffnx {C Function} scm_string_length (string)
Return the number of characters in @var{string}.
@end deffn

string-ref
@c snarfed from strings.c:623
@deffn {Scheme Procedure} string-ref str k
@deffnx {C Function} scm_string_ref (str, k)
Return character @var{k} of @var{str} using zero-origin
indexing. @var{k} must be a valid index of @var{str}.
@end deffn

string-set!
@c snarfed from strings.c:646
@deffn {Scheme Procedure} string-set! str k chr
@deffnx {C Function} scm_string_set_x (str, k, chr)
Store @var{chr} in element @var{k} of @var{str} and return
an unspecified value. @var{k} must be a valid index of
@var{str}.
@end deffn

substring
@c snarfed from strings.c:682
@deffn {Scheme Procedure} substring str start [end]
@deffnx {C Function} scm_substring (str, start, end)
Return a newly allocated string formed from the characters
of @var{str} beginning with index @var{start} (inclusive) and
ending with index @var{end} (exclusive).
@var{str} must be a string, @var{start} and @var{end} must be
exact integers satisfying:

0 <= @var{start} <= @var{end} <= (string-length @var{str}).
@end deffn

substring/read-only
@c snarfed from strings.c:708
@deffn {Scheme Procedure} substring/read-only str start [end]
@deffnx {C Function} scm_substring_read_only (str, start, end)
Return a newly allocated string formed from the characters
of @var{str} beginning with index @var{start} (inclusive) and
ending with index @var{end} (exclusive).
@var{str} must be a string, @var{start} and @var{end} must be
exact integers satisfying:

0 <= @var{start} <= @var{end} <= (string-length @var{str}).

The returned string is read-only.

@end deffn

substring/copy
@c snarfed from strings.c:731
@deffn {Scheme Procedure} substring/copy str start [end]
@deffnx {C Function} scm_substring_copy (str, start, end)
Return a newly allocated string formed from the characters
of @var{str} beginning with index @var{start} (inclusive) and
ending with index @var{end} (exclusive).
@var{str} must be a string, @var{start} and @var{end} must be
exact integers satisfying:

0 <= @var{start} <= @var{end} <= (string-length @var{str}).
@end deffn

substring/shared
@c snarfed from strings.c:755
@deffn {Scheme Procedure} substring/shared str start [end]
@deffnx {C Function} scm_substring_shared (str, start, end)
Return string that indirectly refers to the characters
of @var{str} beginning with index @var{start} (inclusive) and
ending with index @var{end} (exclusive).
@var{str} must be a string, @var{start} and @var{end} must be
exact integers satisfying:

0 <= @var{start} <= @var{end} <= (string-length @var{str}).
@end deffn

string-append
@c snarfed from strings.c:774
@deffn {Scheme Procedure} string-append . args
@deffnx {C Function} scm_string_append (args)
Return a newly allocated string whose characters form the
concatenation of the given strings, @var{args}.
@end deffn

uniform-vector?
@c snarfed from srfi-4.c:651
@deffn {Scheme Procedure} uniform-vector? obj
@deffnx {C Function} scm_uniform_vector_p (obj)
Return @code{#t} if @var{obj} is a uniform vector.
@end deffn

uniform-vector-ref
@c snarfed from srfi-4.c:677
@deffn {Scheme Procedure} uniform-vector-ref v idx
@deffnx {C Function} scm_uniform_vector_ref (v, idx)
Return the element at index @var{idx} of the
homogenous numeric vector @var{v}.
@end deffn

uniform-vector-set!
@c snarfed from srfi-4.c:714
@deffn {Scheme Procedure} uniform-vector-set! v idx val
@deffnx {C Function} scm_uniform_vector_set_x (v, idx, val)
Set the element at index @var{idx} of the
homogenous numeric vector @var{v} to @var{val}.
@end deffn

uniform-vector->list
@c snarfed from srfi-4.c:737
@deffn {Scheme Procedure} uniform-vector->list uvec
@deffnx {C Function} scm_uniform_vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

uniform-vector-length
@c snarfed from srfi-4.c:820
@deffn {Scheme Procedure} uniform-vector-length v
@deffnx {C Function} scm_uniform_vector_length (v)
Return the number of elements in the uniform vector @var{v}.
@end deffn

uniform-vector-read!
@c snarfed from srfi-4.c:845
@deffn {Scheme Procedure} uniform-array-read! ura [port_or_fd [start [end]]]
@deffnx {Scheme Procedure} uniform-vector-read! uve [port-or-fdes] [start] [end]
@deffnx {C Function} scm_uniform_array_read_x (ura, port_or_fd, start, end)
Attempt to read all elements of @var{ura}, in lexicographic order, as
binary objects from @var{port-or-fdes}.
If an end of file is encountered,
the objects up to that point are put into @var{ura}
(starting at the beginning) and the remainder of the array is
unchanged.

The optional arguments @var{start} and @var{end} allow
a specified region of a vector (or linearized array) to be read,
leaving the remainder of the vector unchanged.

@code{uniform-array-read!} returns the number of objects read.
@var{port-or-fdes} may be omitted, in which case it defaults to the value
returned by @code{(current-input-port)}.
@end deffn

uniform-vector-write
@c snarfed from srfi-4.c:958
@deffn {Scheme Procedure} uniform-vector-write uvec [port_or_fd [start [end]]]
@deffnx {C Function} scm_uniform_vector_write (uvec, port_or_fd, start, end)
Write the elements of @var{uvec} as raw bytes to
@var{port-or-fdes}, in the host byte order.

The optional arguments @var{start} (inclusive)
and @var{end} (exclusive) allow
a specified region to be written.

When @var{port-or-fdes} is a port, all specified elements
of @var{uvec} are attempted to be written, potentially blocking
while waiting for more room.
When @var{port-or-fd} is an integer, a single call to
write(2) is made.

An error is signalled when the last element has only
been partially written in the single call to write(2).

The number of objects actually written is returned.
@var{port-or-fdes} may be
omitted, in which case it defaults to the value returned by
@code{(current-output-port)}.
@end deffn

u8vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} u8vector? obj
@deffnx {C Function} scm_u8vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type u8,
@code{#f} otherwise.
@end deffn

make-u8vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-u8vector len [fill]
@deffnx {C Function} scm_make_u8vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

u8vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} u8vector . l
@deffnx {C Function} scm_u8vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

u8vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} u8vector-length uvec
@deffnx {C Function} scm_u8vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

u8vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} u8vector-ref uvec index
@deffnx {C Function} scm_u8vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

u8vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} u8vector-set! uvec index value
@deffnx {C Function} scm_u8vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

u8vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} u8vector->list uvec
@deffnx {C Function} scm_u8vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->u8vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->u8vector l
@deffnx {C Function} scm_list_to_u8vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->u8vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->u8vector obj
@deffnx {C Function} scm_any_to_u8vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type u8.
@end deffn

s8vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} s8vector? obj
@deffnx {C Function} scm_s8vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type s8,
@code{#f} otherwise.
@end deffn

make-s8vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-s8vector len [fill]
@deffnx {C Function} scm_make_s8vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

s8vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} s8vector . l
@deffnx {C Function} scm_s8vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

s8vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} s8vector-length uvec
@deffnx {C Function} scm_s8vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

s8vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} s8vector-ref uvec index
@deffnx {C Function} scm_s8vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

s8vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} s8vector-set! uvec index value
@deffnx {C Function} scm_s8vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

s8vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} s8vector->list uvec
@deffnx {C Function} scm_s8vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->s8vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->s8vector l
@deffnx {C Function} scm_list_to_s8vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->s8vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->s8vector obj
@deffnx {C Function} scm_any_to_s8vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type s8.
@end deffn

u16vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} u16vector? obj
@deffnx {C Function} scm_u16vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type u16,
@code{#f} otherwise.
@end deffn

make-u16vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-u16vector len [fill]
@deffnx {C Function} scm_make_u16vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

u16vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} u16vector . l
@deffnx {C Function} scm_u16vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

u16vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} u16vector-length uvec
@deffnx {C Function} scm_u16vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

u16vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} u16vector-ref uvec index
@deffnx {C Function} scm_u16vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

u16vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} u16vector-set! uvec index value
@deffnx {C Function} scm_u16vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

u16vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} u16vector->list uvec
@deffnx {C Function} scm_u16vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->u16vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->u16vector l
@deffnx {C Function} scm_list_to_u16vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->u16vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->u16vector obj
@deffnx {C Function} scm_any_to_u16vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type u16.
@end deffn

s16vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} s16vector? obj
@deffnx {C Function} scm_s16vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type s16,
@code{#f} otherwise.
@end deffn

make-s16vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-s16vector len [fill]
@deffnx {C Function} scm_make_s16vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

s16vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} s16vector . l
@deffnx {C Function} scm_s16vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

s16vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} s16vector-length uvec
@deffnx {C Function} scm_s16vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

s16vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} s16vector-ref uvec index
@deffnx {C Function} scm_s16vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

s16vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} s16vector-set! uvec index value
@deffnx {C Function} scm_s16vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

s16vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} s16vector->list uvec
@deffnx {C Function} scm_s16vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->s16vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->s16vector l
@deffnx {C Function} scm_list_to_s16vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->s16vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->s16vector obj
@deffnx {C Function} scm_any_to_s16vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type s16.
@end deffn

u32vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} u32vector? obj
@deffnx {C Function} scm_u32vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type u32,
@code{#f} otherwise.
@end deffn

make-u32vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-u32vector len [fill]
@deffnx {C Function} scm_make_u32vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

u32vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} u32vector . l
@deffnx {C Function} scm_u32vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

u32vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} u32vector-length uvec
@deffnx {C Function} scm_u32vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

u32vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} u32vector-ref uvec index
@deffnx {C Function} scm_u32vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

u32vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} u32vector-set! uvec index value
@deffnx {C Function} scm_u32vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

u32vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} u32vector->list uvec
@deffnx {C Function} scm_u32vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->u32vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->u32vector l
@deffnx {C Function} scm_list_to_u32vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->u32vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->u32vector obj
@deffnx {C Function} scm_any_to_u32vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type u32.
@end deffn

s32vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} s32vector? obj
@deffnx {C Function} scm_s32vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type s32,
@code{#f} otherwise.
@end deffn

make-s32vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-s32vector len [fill]
@deffnx {C Function} scm_make_s32vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

s32vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} s32vector . l
@deffnx {C Function} scm_s32vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

s32vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} s32vector-length uvec
@deffnx {C Function} scm_s32vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

s32vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} s32vector-ref uvec index
@deffnx {C Function} scm_s32vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

s32vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} s32vector-set! uvec index value
@deffnx {C Function} scm_s32vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

s32vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} s32vector->list uvec
@deffnx {C Function} scm_s32vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->s32vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->s32vector l
@deffnx {C Function} scm_list_to_s32vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->s32vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->s32vector obj
@deffnx {C Function} scm_any_to_s32vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type s32.
@end deffn

u64vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} u64vector? obj
@deffnx {C Function} scm_u64vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type u64,
@code{#f} otherwise.
@end deffn

make-u64vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-u64vector len [fill]
@deffnx {C Function} scm_make_u64vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

u64vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} u64vector . l
@deffnx {C Function} scm_u64vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

u64vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} u64vector-length uvec
@deffnx {C Function} scm_u64vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

u64vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} u64vector-ref uvec index
@deffnx {C Function} scm_u64vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

u64vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} u64vector-set! uvec index value
@deffnx {C Function} scm_u64vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

u64vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} u64vector->list uvec
@deffnx {C Function} scm_u64vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->u64vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->u64vector l
@deffnx {C Function} scm_list_to_u64vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->u64vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->u64vector obj
@deffnx {C Function} scm_any_to_u64vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type u64.
@end deffn

s64vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} s64vector? obj
@deffnx {C Function} scm_s64vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type s64,
@code{#f} otherwise.
@end deffn

make-s64vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-s64vector len [fill]
@deffnx {C Function} scm_make_s64vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

s64vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} s64vector . l
@deffnx {C Function} scm_s64vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

s64vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} s64vector-length uvec
@deffnx {C Function} scm_s64vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

s64vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} s64vector-ref uvec index
@deffnx {C Function} scm_s64vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

s64vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} s64vector-set! uvec index value
@deffnx {C Function} scm_s64vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

s64vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} s64vector->list uvec
@deffnx {C Function} scm_s64vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->s64vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->s64vector l
@deffnx {C Function} scm_list_to_s64vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->s64vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->s64vector obj
@deffnx {C Function} scm_any_to_s64vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type s64.
@end deffn

f32vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} f32vector? obj
@deffnx {C Function} scm_f32vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type f32,
@code{#f} otherwise.
@end deffn

make-f32vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-f32vector len [fill]
@deffnx {C Function} scm_make_f32vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

f32vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} f32vector . l
@deffnx {C Function} scm_f32vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

f32vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} f32vector-length uvec
@deffnx {C Function} scm_f32vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

f32vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} f32vector-ref uvec index
@deffnx {C Function} scm_f32vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

f32vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} f32vector-set! uvec index value
@deffnx {C Function} scm_f32vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

f32vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} f32vector->list uvec
@deffnx {C Function} scm_f32vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->f32vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->f32vector l
@deffnx {C Function} scm_list_to_f32vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->f32vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->f32vector obj
@deffnx {C Function} scm_any_to_f32vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type f32.
@end deffn

f64vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} f64vector? obj
@deffnx {C Function} scm_f64vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type f64,
@code{#f} otherwise.
@end deffn

make-f64vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-f64vector len [fill]
@deffnx {C Function} scm_make_f64vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

f64vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} f64vector . l
@deffnx {C Function} scm_f64vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

f64vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} f64vector-length uvec
@deffnx {C Function} scm_f64vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

f64vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} f64vector-ref uvec index
@deffnx {C Function} scm_f64vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

f64vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} f64vector-set! uvec index value
@deffnx {C Function} scm_f64vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

f64vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} f64vector->list uvec
@deffnx {C Function} scm_f64vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->f64vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->f64vector l
@deffnx {C Function} scm_list_to_f64vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->f64vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->f64vector obj
@deffnx {C Function} scm_any_to_f64vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type f64.
@end deffn

c32vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} c32vector? obj
@deffnx {C Function} scm_c32vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type c32,
@code{#f} otherwise.
@end deffn

make-c32vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-c32vector len [fill]
@deffnx {C Function} scm_make_c32vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

c32vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} c32vector . l
@deffnx {C Function} scm_c32vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

c32vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} c32vector-length uvec
@deffnx {C Function} scm_c32vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

c32vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} c32vector-ref uvec index
@deffnx {C Function} scm_c32vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

c32vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} c32vector-set! uvec index value
@deffnx {C Function} scm_c32vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

c32vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} c32vector->list uvec
@deffnx {C Function} scm_c32vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->c32vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->c32vector l
@deffnx {C Function} scm_list_to_c32vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->c32vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->c32vector obj
@deffnx {C Function} scm_any_to_c32vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type c32.
@end deffn

c64vector?
@c snarfed from ../libguile/srfi-4.i.c:41
@deffn {Scheme Procedure} c64vector? obj
@deffnx {C Function} scm_c64vector_p (obj)
Return @code{#t} if @var{obj} is a vector of type c64,
@code{#f} otherwise.
@end deffn

make-c64vector
@c snarfed from ../libguile/srfi-4.i.c:53
@deffn {Scheme Procedure} make-c64vector len [fill]
@deffnx {C Function} scm_make_c64vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

c64vector
@c snarfed from ../libguile/srfi-4.i.c:63
@deffn {Scheme Procedure} c64vector . l
@deffnx {C Function} scm_c64vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

c64vector-length
@c snarfed from ../libguile/srfi-4.i.c:74
@deffn {Scheme Procedure} c64vector-length uvec
@deffnx {C Function} scm_c64vector_length (uvec)
Return the number of elements in the uniform numeric vector
@var{uvec}.
@end deffn

c64vector-ref
@c snarfed from ../libguile/srfi-4.i.c:85
@deffn {Scheme Procedure} c64vector-ref uvec index
@deffnx {C Function} scm_c64vector_ref (uvec, index)
Return the element at @var{index} in the uniform numeric
vector @var{uvec}.
@end deffn

c64vector-set!
@c snarfed from ../libguile/srfi-4.i.c:97
@deffn {Scheme Procedure} c64vector-set! uvec index value
@deffnx {C Function} scm_c64vector_set_x (uvec, index, value)
Set the element at @var{index} in the uniform numeric
vector @var{uvec} to @var{value}.  The return value is not
specified.
@end deffn

c64vector->list
@c snarfed from ../libguile/srfi-4.i.c:107
@deffn {Scheme Procedure} c64vector->list uvec
@deffnx {C Function} scm_c64vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

list->c64vector
@c snarfed from ../libguile/srfi-4.i.c:117
@deffn {Scheme Procedure} list->c64vector l
@deffnx {C Function} scm_list_to_c64vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

any->c64vector
@c snarfed from ../libguile/srfi-4.i.c:128
@deffn {Scheme Procedure} any->c64vector obj
@deffnx {C Function} scm_any_to_c64vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type c64.
@end deffn

string-null?
@c snarfed from srfi-13.c:62
@deffn {Scheme Procedure} string-null? str
@deffnx {C Function} scm_string_null_p (str)
Return @code{#t} if @var{str}'s length is zero, and
@code{#f} otherwise.
@lisp
(string-null? "")  @result{} #t
y                    @result{} "foo"
(string-null? y)     @result{} #f
@end lisp
@end deffn

string-any-c-code
@c snarfed from srfi-13.c:94
@deffn {Scheme Procedure} string-any-c-code char_pred s [start [end]]
@deffnx {C Function} scm_string_any (char_pred, s, start, end)
Check if @var{char_pred} is true for any character in string @var{s}.

@var{char_pred} can be a character to check for any equal to that, or
a character set (@pxref{Character Sets}) to check for any in that set,
or a predicate procedure to call.

For a procedure, calls @code{(@var{char_pred} c)} are made
successively on the characters from @var{start} to @var{end}.  If
@var{char_pred} returns true (ie.@: non-@code{#f}), @code{string-any}
stops and that return value is the return from @code{string-any}.  The
call on the last character (ie.@: at @math{@var{end}-1}), if that
point is reached, is a tail call.

If there are no characters in @var{s} (ie.@: @var{start} equals
@var{end}) then the return is @code{#f}.

@end deffn

string-every-c-code
@c snarfed from srfi-13.c:158
@deffn {Scheme Procedure} string-every-c-code char_pred s [start [end]]
@deffnx {C Function} scm_string_every (char_pred, s, start, end)
Check if @var{char_pred} is true for every character in string
@var{s}.

@var{char_pred} can be a character to check for every character equal
to that, or a character set (@pxref{Character Sets}) to check for
every character being in that set, or a predicate procedure to call.

For a procedure, calls @code{(@var{char_pred} c)} are made
successively on the characters from @var{start} to @var{end}.  If
@var{char_pred} returns @code{#f}, @code{string-every} stops and
returns @code{#f}.  The call on the last character (ie.@: at
@math{@var{end}-1}), if that point is reached, is a tail call and the
return from that call is the return from @code{string-every}.

If there are no characters in @var{s} (ie.@: @var{start} equals
@var{end}) then the return is @code{#t}.

@end deffn

string-tabulate
@c snarfed from srfi-13.c:214
@deffn {Scheme Procedure} string-tabulate proc len
@deffnx {C Function} scm_string_tabulate (proc, len)
@var{proc} is an integer->char procedure.  Construct a string
of size @var{len} by applying @var{proc} to each index to
produce the corresponding string element.  The order in which
@var{proc} is applied to the indices is not specified.
@end deffn

string->list
@c snarfed from srfi-13.c:246
@deffn {Scheme Procedure} string->list str [start [end]]
@deffnx {C Function} scm_substring_to_list (str, start, end)
Convert the string @var{str} into a list of characters.
@end deffn

reverse-list->string
@c snarfed from srfi-13.c:285
@deffn {Scheme Procedure} reverse-list->string chrs
@deffnx {C Function} scm_reverse_list_to_string (chrs)
An efficient implementation of @code{(compose string->list
reverse)}:

@smalllisp
(reverse-list->string '(#\a #\B #\c)) @result{} "cBa"
@end smalllisp
@end deffn

string-join
@c snarfed from srfi-13.c:352
@deffn {Scheme Procedure} string-join ls [delimiter [grammar]]
@deffnx {C Function} scm_string_join (ls, delimiter, grammar)
Append the string in the string list @var{ls}, using the string
@var{delim} as a delimiter between the elements of @var{ls}.
@var{grammar} is a symbol which specifies how the delimiter is
placed between the strings, and defaults to the symbol
@code{infix}.

@table @code
@item infix
Insert the separator between list elements.  An empty string
will produce an empty list.
@item string-infix
Like @code{infix}, but will raise an error if given the empty
list.
@item suffix
Insert the separator after every list element.
@item prefix
Insert the separator before each list element.
@end table
@end deffn

string-copy
@c snarfed from srfi-13.c:486
@deffn {Scheme Procedure} string-copy str [start [end]]
@deffnx {C Function} scm_srfi13_substring_copy (str, start, end)
Return a freshly allocated copy of the string @var{str}.  If
given, @var{start} and @var{end} delimit the portion of
@var{str} which is copied.
@end deffn

string-copy!
@c snarfed from srfi-13.c:513
@deffn {Scheme Procedure} string-copy! target tstart s [start [end]]
@deffnx {C Function} scm_string_copy_x (target, tstart, s, start, end)
Copy the sequence of characters from index range [@var{start},
@var{end}) in string @var{s} to string @var{target}, beginning
at index @var{tstart}.  The characters are copied left-to-right
or right-to-left as needed -- the copy is guaranteed to work,
even if @var{target} and @var{s} are the same string.  It is an
error if the copy operation runs off the end of the target
string.
@end deffn

substring-move!
@c snarfed from srfi-13.c:543
@deffn {Scheme Procedure} substring-move! str1 start1 end1 str2 start2
@deffnx {C Function} scm_substring_move_x (str1, start1, end1, str2, start2)
Copy the substring of @var{str1} bounded by @var{start1} and @var{end1}
into @var{str2} beginning at position @var{start2}.
@var{str1} and @var{str2} can be the same string.
@end deffn

string-take
@c snarfed from srfi-13.c:552
@deffn {Scheme Procedure} string-take s n
@deffnx {C Function} scm_string_take (s, n)
Return the @var{n} first characters of @var{s}.
@end deffn

string-drop
@c snarfed from srfi-13.c:562
@deffn {Scheme Procedure} string-drop s n
@deffnx {C Function} scm_string_drop (s, n)
Return all but the first @var{n} characters of @var{s}.
@end deffn

string-take-right
@c snarfed from srfi-13.c:572
@deffn {Scheme Procedure} string-take-right s n
@deffnx {C Function} scm_string_take_right (s, n)
Return the @var{n} last characters of @var{s}.
@end deffn

string-drop-right
@c snarfed from srfi-13.c:584
@deffn {Scheme Procedure} string-drop-right s n
@deffnx {C Function} scm_string_drop_right (s, n)
Return all but the last @var{n} characters of @var{s}.
@end deffn

string-pad
@c snarfed from srfi-13.c:599
@deffn {Scheme Procedure} string-pad s len [chr [start [end]]]
@deffnx {C Function} scm_string_pad (s, len, chr, start, end)
Take that characters from @var{start} to @var{end} from the
string @var{s} and return a new string, right-padded by the
character @var{chr} to length @var{len}.  If the resulting
string is longer than @var{len}, it is truncated on the right.
@end deffn

string-pad-right
@c snarfed from srfi-13.c:639
@deffn {Scheme Procedure} string-pad-right s len [chr [start [end]]]
@deffnx {C Function} scm_string_pad_right (s, len, chr, start, end)
Take that characters from @var{start} to @var{end} from the
string @var{s} and return a new string, left-padded by the
character @var{chr} to length @var{len}.  If the resulting
string is longer than @var{len}, it is truncated on the left.
@end deffn

string-trim
@c snarfed from srfi-13.c:692
@deffn {Scheme Procedure} string-trim s [char_pred [start [end]]]
@deffnx {C Function} scm_string_trim (s, char_pred, start, end)
Trim @var{s} by skipping over all characters on the left
that satisfy the parameter @var{char_pred}:

@itemize @bullet
@item
if it is the character @var{ch}, characters equal to
@var{ch} are trimmed,

@item
if it is a procedure @var{pred} characters that
satisfy @var{pred} are trimmed,

@item
if it is a character set, characters in that set are trimmed.
@end itemize

If called without a @var{char_pred} argument, all whitespace is
trimmed.
@end deffn

string-trim-right
@c snarfed from srfi-13.c:768
@deffn {Scheme Procedure} string-trim-right s [char_pred [start [end]]]
@deffnx {C Function} scm_string_trim_right (s, char_pred, start, end)
Trim @var{s} by skipping over all characters on the rightt
that satisfy the parameter @var{char_pred}:

@itemize @bullet
@item
if it is the character @var{ch}, characters equal to @var{ch}
are trimmed,

@item
if it is a procedure @var{pred} characters that satisfy
@var{pred} are trimmed,

@item
if it is a character sets, all characters in that set are
trimmed.
@end itemize

If called without a @var{char_pred} argument, all whitespace is
trimmed.
@end deffn

string-trim-both
@c snarfed from srfi-13.c:844
@deffn {Scheme Procedure} string-trim-both s [char_pred [start [end]]]
@deffnx {C Function} scm_string_trim_both (s, char_pred, start, end)
Trim @var{s} by skipping over all characters on both sides of
the string that satisfy the parameter @var{char_pred}:

@itemize @bullet
@item
if it is the character @var{ch}, characters equal to @var{ch}
are trimmed,

@item
if it is a procedure @var{pred} characters that satisfy
@var{pred} are trimmed,

@item
if it is a character set, the characters in the set are
trimmed.
@end itemize

If called without a @var{char_pred} argument, all whitespace is
trimmed.
@end deffn

string-fill!
@c snarfed from srfi-13.c:931
@deffn {Scheme Procedure} string-fill! str chr [start [end]]
@deffnx {C Function} scm_substring_fill_x (str, chr, start, end)
Stores @var{chr} in every element of the given @var{str} and
returns an unspecified value.
@end deffn

string-compare
@c snarfed from srfi-13.c:983
@deffn {Scheme Procedure} string-compare s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_compare (s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)
Apply @var{proc_lt}, @var{proc_eq}, @var{proc_gt} to the
mismatch index, depending upon whether @var{s1} is less than,
equal to, or greater than @var{s2}.  The mismatch index is the
largest index @var{i} such that for every 0 <= @var{j} <
@var{i}, @var{s1}[@var{j}] = @var{s2}[@var{j}] -- that is,
@var{i} is the first position that does not match.
@end deffn

string-compare-ci
@c snarfed from srfi-13.c:1037
@deffn {Scheme Procedure} string-compare-ci s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_compare_ci (s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)
Apply @var{proc_lt}, @var{proc_eq}, @var{proc_gt} to the
mismatch index, depending upon whether @var{s1} is less than,
equal to, or greater than @var{s2}.  The mismatch index is the
largest index @var{i} such that for every 0 <= @var{j} <
@var{i}, @var{s1}[@var{j}] = @var{s2}[@var{j}] -- that is,
@var{i} is the first position where the lowercased letters 
do not match.

@end deffn

string=
@c snarfed from srfi-13.c:1088
@deffn {Scheme Procedure} string= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_eq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are not equal, a true
value otherwise.
@end deffn

string<>
@c snarfed from srfi-13.c:1127
@deffn {Scheme Procedure} string<> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_neq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are equal, a true
value otherwise.
@end deffn

string<
@c snarfed from srfi-13.c:1170
@deffn {Scheme Procedure} string< s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_lt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater or equal to @var{s2}, a
true value otherwise.
@end deffn

string>
@c snarfed from srfi-13.c:1213
@deffn {Scheme Procedure} string> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_gt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less or equal to @var{s2}, a
true value otherwise.
@end deffn

string<=
@c snarfed from srfi-13.c:1256
@deffn {Scheme Procedure} string<= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_le (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater to @var{s2}, a true
value otherwise.
@end deffn

string>=
@c snarfed from srfi-13.c:1299
@deffn {Scheme Procedure} string>= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ge (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less to @var{s2}, a true value
otherwise.
@end deffn

string-ci=
@c snarfed from srfi-13.c:1343
@deffn {Scheme Procedure} string-ci= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_eq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are not equal, a true
value otherwise.  The character comparison is done
case-insensitively.
@end deffn

string-ci<>
@c snarfed from srfi-13.c:1387
@deffn {Scheme Procedure} string-ci<> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_neq (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} and @var{s2} are equal, a true
value otherwise.  The character comparison is done
case-insensitively.
@end deffn

string-ci<
@c snarfed from srfi-13.c:1431
@deffn {Scheme Procedure} string-ci< s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_lt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater or equal to @var{s2}, a
true value otherwise.  The character comparison is done
case-insensitively.
@end deffn

string-ci>
@c snarfed from srfi-13.c:1475
@deffn {Scheme Procedure} string-ci> s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_gt (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less or equal to @var{s2}, a
true value otherwise.  The character comparison is done
case-insensitively.
@end deffn

string-ci<=
@c snarfed from srfi-13.c:1519
@deffn {Scheme Procedure} string-ci<= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_le (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is greater to @var{s2}, a true
value otherwise.  The character comparison is done
case-insensitively.
@end deffn

string-ci>=
@c snarfed from srfi-13.c:1563
@deffn {Scheme Procedure} string-ci>= s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_ci_ge (s1, s2, start1, end1, start2, end2)
Return @code{#f} if @var{s1} is less to @var{s2}, a true value
otherwise.  The character comparison is done
case-insensitively.
@end deffn

string-hash
@c snarfed from srfi-13.c:1608
@deffn {Scheme Procedure} string-hash s [bound [start [end]]]
@deffnx {C Function} scm_substring_hash (s, bound, start, end)
Compute a hash value for @var{S}.  the optional argument @var{bound} is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
@end deffn

string-hash-ci
@c snarfed from srfi-13.c:1625
@deffn {Scheme Procedure} string-hash-ci s [bound [start [end]]]
@deffnx {C Function} scm_substring_hash_ci (s, bound, start, end)
Compute a hash value for @var{S}.  the optional argument @var{bound} is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
@end deffn

string-prefix-length
@c snarfed from srfi-13.c:1637
@deffn {Scheme Procedure} string-prefix-length s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_length (s1, s2, start1, end1, start2, end2)
Return the length of the longest common prefix of the two
strings.
@end deffn

string-prefix-length-ci
@c snarfed from srfi-13.c:1669
@deffn {Scheme Procedure} string-prefix-length-ci s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_length_ci (s1, s2, start1, end1, start2, end2)
Return the length of the longest common prefix of the two
strings, ignoring character case.
@end deffn

string-suffix-length
@c snarfed from srfi-13.c:1701
@deffn {Scheme Procedure} string-suffix-length s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_length (s1, s2, start1, end1, start2, end2)
Return the length of the longest common suffix of the two
strings.
@end deffn

string-suffix-length-ci
@c snarfed from srfi-13.c:1733
@deffn {Scheme Procedure} string-suffix-length-ci s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_length_ci (s1, s2, start1, end1, start2, end2)
Return the length of the longest common suffix of the two
strings, ignoring character case.
@end deffn

string-prefix?
@c snarfed from srfi-13.c:1764
@deffn {Scheme Procedure} string-prefix? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a prefix of @var{s2}?
@end deffn

string-prefix-ci?
@c snarfed from srfi-13.c:1796
@deffn {Scheme Procedure} string-prefix-ci? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_prefix_ci_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a prefix of @var{s2}, ignoring character case?
@end deffn

string-suffix?
@c snarfed from srfi-13.c:1828
@deffn {Scheme Procedure} string-suffix? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a suffix of @var{s2}?
@end deffn

string-suffix-ci?
@c snarfed from srfi-13.c:1860
@deffn {Scheme Procedure} string-suffix-ci? s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_suffix_ci_p (s1, s2, start1, end1, start2, end2)
Is @var{s1} a suffix of @var{s2}, ignoring character case?
@end deffn

string-index
@c snarfed from srfi-13.c:1904
@deffn {Scheme Procedure} string-index s char_pred [start [end]]
@deffnx {C Function} scm_string_index (s, char_pred, start, end)
Search through the string @var{s} from left to right, returning
the index of the first occurence of a character which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisifies the predicate @var{char_pred}, if it is a procedure,

@item
is in the set @var{char_pred}, if it is a character set.
@end itemize
@end deffn

string-index-right
@c snarfed from srfi-13.c:1969
@deffn {Scheme Procedure} string-index-right s char_pred [start [end]]
@deffnx {C Function} scm_string_index_right (s, char_pred, start, end)
Search through the string @var{s} from right to left, returning
the index of the last occurence of a character which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisifies the predicate @var{char_pred}, if it is a procedure,

@item
is in the set if @var{char_pred} is a character set.
@end itemize
@end deffn

string-rindex
@c snarfed from srfi-13.c:2034
@deffn {Scheme Procedure} string-rindex s char_pred [start [end]]
@deffnx {C Function} scm_string_rindex (s, char_pred, start, end)
Search through the string @var{s} from right to left, returning
the index of the last occurence of a character which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisifies the predicate @var{char_pred}, if it is a procedure,

@item
is in the set if @var{char_pred} is a character set.
@end itemize
@end deffn

string-skip
@c snarfed from srfi-13.c:2056
@deffn {Scheme Procedure} string-skip s char_pred [start [end]]
@deffnx {C Function} scm_string_skip (s, char_pred, start, end)
Search through the string @var{s} from left to right, returning
the index of the first occurence of a character which

@itemize @bullet
@item
does not equal @var{char_pred}, if it is character,

@item
does not satisify the predicate @var{char_pred}, if it is a
procedure,

@item
is not in the set if @var{char_pred} is a character set.
@end itemize
@end deffn

string-skip-right
@c snarfed from srfi-13.c:2123
@deffn {Scheme Procedure} string-skip-right s char_pred [start [end]]
@deffnx {C Function} scm_string_skip_right (s, char_pred, start, end)
Search through the string @var{s} from right to left, returning
the index of the last occurence of a character which

@itemize @bullet
@item
does not equal @var{char_pred}, if it is character,

@item
does not satisfy the predicate @var{char_pred}, if it is a
procedure,

@item
is not in the set if @var{char_pred} is a character set.
@end itemize
@end deffn

string-count
@c snarfed from srfi-13.c:2190
@deffn {Scheme Procedure} string-count s char_pred [start [end]]
@deffnx {C Function} scm_string_count (s, char_pred, start, end)
Return the count of the number of characters in the string
@var{s} which

@itemize @bullet
@item
equals @var{char_pred}, if it is character,

@item
satisifies the predicate @var{char_pred}, if it is a procedure.

@item
is in the set @var{char_pred}, if it is a character set.
@end itemize
@end deffn

string-contains
@c snarfed from srfi-13.c:2247
@deffn {Scheme Procedure} string-contains s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_contains (s1, s2, start1, end1, start2, end2)
Does string @var{s1} contain string @var{s2}?  Return the index
in @var{s1} where @var{s2} occurs as a substring, or false.
The optional start/end indices restrict the operation to the
indicated substrings.
@end deffn

string-contains-ci
@c snarfed from srfi-13.c:2294
@deffn {Scheme Procedure} string-contains-ci s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_contains_ci (s1, s2, start1, end1, start2, end2)
Does string @var{s1} contain string @var{s2}?  Return the index
in @var{s1} where @var{s2} occurs as a substring, or false.
The optional start/end indices restrict the operation to the
indicated substrings.  Character comparison is done
case-insensitively.
@end deffn

string-upcase!
@c snarfed from srfi-13.c:2359
@deffn {Scheme Procedure} string-upcase! str [start [end]]
@deffnx {C Function} scm_substring_upcase_x (str, start, end)
Destructively upcase every character in @code{str}.

@lisp
(string-upcase! y)
@result{} "ARRDEFG"
y
@result{} "ARRDEFG"
@end lisp
@end deffn

string-upcase
@c snarfed from srfi-13.c:2380
@deffn {Scheme Procedure} string-upcase str [start [end]]
@deffnx {C Function} scm_substring_upcase (str, start, end)
Upcase every character in @code{str}.
@end deffn

string-downcase!
@c snarfed from srfi-13.c:2427
@deffn {Scheme Procedure} string-downcase! str [start [end]]
@deffnx {C Function} scm_substring_downcase_x (str, start, end)
Destructively downcase every character in @var{str}.

@lisp
y
@result{} "ARRDEFG"
(string-downcase! y)
@result{} "arrdefg"
y
@result{} "arrdefg"
@end lisp
@end deffn

string-downcase
@c snarfed from srfi-13.c:2448
@deffn {Scheme Procedure} string-downcase str [start [end]]
@deffnx {C Function} scm_substring_downcase (str, start, end)
Downcase every character in @var{str}.
@end deffn

string-titlecase!
@c snarfed from srfi-13.c:2504
@deffn {Scheme Procedure} string-titlecase! str [start [end]]
@deffnx {C Function} scm_string_titlecase_x (str, start, end)
Destructively titlecase every first character in a word in
@var{str}.
@end deffn

string-titlecase
@c snarfed from srfi-13.c:2520
@deffn {Scheme Procedure} string-titlecase str [start [end]]
@deffnx {C Function} scm_string_titlecase (str, start, end)
Titlecase every first character in a word in @var{str}.
@end deffn

string-capitalize!
@c snarfed from srfi-13.c:2542
@deffn {Scheme Procedure} string-capitalize! str
@deffnx {C Function} scm_string_capitalize_x (str)
Upcase the first character of every word in @var{str}
destructively and return @var{str}.

@lisp
y                      @result{} "hello world"
(string-capitalize! y) @result{} "Hello World"
y                      @result{} "Hello World"
@end lisp
@end deffn

string-capitalize
@c snarfed from srfi-13.c:2554
@deffn {Scheme Procedure} string-capitalize str
@deffnx {C Function} scm_string_capitalize (str)
Return a freshly allocated string with the characters in
@var{str}, where the first character of every word is
capitalized.
@end deffn

string-reverse
@c snarfed from srfi-13.c:2588
@deffn {Scheme Procedure} string-reverse str [start [end]]
@deffnx {C Function} scm_string_reverse (str, start, end)
Reverse the string @var{str}.  The optional arguments
@var{start} and @var{end} delimit the region of @var{str} to
operate on.
@end deffn

string-reverse!
@c snarfed from srfi-13.c:2613
@deffn {Scheme Procedure} string-reverse! str [start [end]]
@deffnx {C Function} scm_string_reverse_x (str, start, end)
Reverse the string @var{str} in-place.  The optional arguments
@var{start} and @var{end} delimit the region of @var{str} to
operate on.  The return value is unspecified.
@end deffn

string-append/shared
@c snarfed from srfi-13.c:2635
@deffn {Scheme Procedure} string-append/shared . rest
@deffnx {C Function} scm_string_append_shared (rest)
Like @code{string-append}, but the result may share memory
with the argument strings.
@end deffn

string-concatenate
@c snarfed from srfi-13.c:2656
@deffn {Scheme Procedure} string-concatenate ls
@deffnx {C Function} scm_string_concatenate (ls)
Append the elements of @var{ls} (which must be strings)
together into a single string.  Guaranteed to return a freshly
allocated string.
@end deffn

string-concatenate-reverse
@c snarfed from srfi-13.c:2678
@deffn {Scheme Procedure} string-concatenate-reverse ls [final_string [end]]
@deffnx {C Function} scm_string_concatenate_reverse (ls, final_string, end)
Without optional arguments, this procedure is equivalent to

@smalllisp
(string-concatenate (reverse ls))
@end smalllisp

If the optional argument @var{final_string} is specified, it is
consed onto the beginning to @var{ls} before performing the
list-reverse and string-concatenate operations.  If @var{end}
is given, only the characters of @var{final_string} up to index
@var{end} are used.

Guaranteed to return a freshly allocated string.
@end deffn

string-concatenate/shared
@c snarfed from srfi-13.c:2695
@deffn {Scheme Procedure} string-concatenate/shared ls
@deffnx {C Function} scm_string_concatenate_shared (ls)
Like @code{string-concatenate}, but the result may share memory
with the strings in the list @var{ls}.
@end deffn

string-concatenate-reverse/shared
@c snarfed from srfi-13.c:2706
@deffn {Scheme Procedure} string-concatenate-reverse/shared ls [final_string [end]]
@deffnx {C Function} scm_string_concatenate_reverse_shared (ls, final_string, end)
Like @code{string-concatenate-reverse}, but the result may
share memory with the strings in the @var{ls} arguments.
@end deffn

string-map
@c snarfed from srfi-13.c:2719
@deffn {Scheme Procedure} string-map proc s [start [end]]
@deffnx {C Function} scm_string_map (proc, s, start, end)
@var{proc} is a char->char procedure, it is mapped over
@var{s}.  The order in which the procedure is applied to the
string elements is not specified.
@end deffn

string-map!
@c snarfed from srfi-13.c:2749
@deffn {Scheme Procedure} string-map! proc s [start [end]]
@deffnx {C Function} scm_string_map_x (proc, s, start, end)
@var{proc} is a char->char procedure, it is mapped over
@var{s}.  The order in which the procedure is applied to the
string elements is not specified.  The string @var{s} is
modified in-place, the return value is not specified.
@end deffn

string-fold
@c snarfed from srfi-13.c:2776
@deffn {Scheme Procedure} string-fold kons knil s [start [end]]
@deffnx {C Function} scm_string_fold (kons, knil, s, start, end)
Fold @var{kons} over the characters of @var{s}, with @var{knil}
as the terminating element, from left to right.  @var{kons}
must expect two arguments: The actual character and the last
result of @var{kons}' application.
@end deffn

string-fold-right
@c snarfed from srfi-13.c:2807
@deffn {Scheme Procedure} string-fold-right kons knil s [start [end]]
@deffnx {C Function} scm_string_fold_right (kons, knil, s, start, end)
Fold @var{kons} over the characters of @var{s}, with @var{knil}
as the terminating element, from right to left.  @var{kons}
must expect two arguments: The actual character and the last
result of @var{kons}' application.
@end deffn

string-unfold
@c snarfed from srfi-13.c:2852
@deffn {Scheme Procedure} string-unfold p f g seed [base [make_final]]
@deffnx {C Function} scm_string_unfold (p, f, g, seed, base, make_final)
@itemize @bullet
@item @var{g} is used to generate a series of @emph{seed}
values from the initial @var{seed}: @var{seed}, (@var{g}
@var{seed}), (@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}),
@dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of these seed values.
@item @var{f} maps each seed value to the corresponding
character in the result string.  These chars are assembled
into the string in a left-to-right order.
@item @var{base} is the optional initial/leftmost portion
of the constructed string; it default to the empty
string.
@item @var{make_final} is applied to the terminal seed
value (on which @var{p} returns true) to produce
the final/rightmost portion of the constructed string.
It defaults to @code{(lambda (x) )}.
@end itemize
@end deffn

string-unfold-right
@c snarfed from srfi-13.c:2915
@deffn {Scheme Procedure} string-unfold-right p f g seed [base [make_final]]
@deffnx {C Function} scm_string_unfold_right (p, f, g, seed, base, make_final)
@itemize @bullet
@item @var{g} is used to generate a series of @emph{seed}
values from the initial @var{seed}: @var{seed}, (@var{g}
@var{seed}), (@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}),
@dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of these seed values.
@item @var{f} maps each seed value to the corresponding
character in the result string.  These chars are assembled
into the string in a right-to-left order.
@item @var{base} is the optional initial/rightmost portion
of the constructed string; it default to the empty
string.
@item @var{make_final} is applied to the terminal seed
value (on which @var{p} returns true) to produce
the final/leftmost portion of the constructed string.
It defaults to @code{(lambda (x) )}.
@end itemize
@end deffn

string-for-each
@c snarfed from srfi-13.c:2962
@deffn {Scheme Procedure} string-for-each proc s [start [end]]
@deffnx {C Function} scm_string_for_each (proc, s, start, end)
@var{proc} is mapped over @var{s} in left-to-right order.  The
return value is not specified.
@end deffn

string-for-each-index
@c snarfed from srfi-13.c:2988
@deffn {Scheme Procedure} string-for-each-index proc s [start [end]]
@deffnx {C Function} scm_string_for_each_index (proc, s, start, end)
@var{proc} is mapped over @var{s} in left-to-right order.  The
return value is not specified.
@end deffn

xsubstring
@c snarfed from srfi-13.c:3020
@deffn {Scheme Procedure} xsubstring s from [to [start [end]]]
@deffnx {C Function} scm_xsubstring (s, from, to, start, end)
This is the @emph{extended substring} procedure that implements
replicated copying of a substring of some string.

@var{s} is a string, @var{start} and @var{end} are optional
arguments that demarcate a substring of @var{s}, defaulting to
0 and the length of @var{s}.  Replicate this substring up and
down index space, in both the positive and negative directions.
@code{xsubstring} returns the substring of this string
beginning at index @var{from}, and ending at @var{to}, which
defaults to @var{from} + (@var{end} - @var{start}).
@end deffn

string-xcopy!
@c snarfed from srfi-13.c:3067
@deffn {Scheme Procedure} string-xcopy! target tstart s sfrom [sto [start [end]]]
@deffnx {C Function} scm_string_xcopy_x (target, tstart, s, sfrom, sto, start, end)
Exactly the same as @code{xsubstring}, but the extracted text
is written into the string @var{target} starting at index
@var{tstart}.  The operation is not defined if @code{(eq?
@var{target} @var{s})} or these arguments share storage -- you
cannot copy a string on top of itself.
@end deffn

string-replace
@c snarfed from srfi-13.c:3117
@deffn {Scheme Procedure} string-replace s1 s2 [start1 [end1 [start2 [end2]]]]
@deffnx {C Function} scm_string_replace (s1, s2, start1, end1, start2, end2)
Return the string @var{s1}, but with the characters
@var{start1} @dots{} @var{end1} replaced by the characters
@var{start2} @dots{} @var{end2} from @var{s2}.
@end deffn

string-tokenize
@c snarfed from srfi-13.c:3154
@deffn {Scheme Procedure} string-tokenize s [token_set [start [end]]]
@deffnx {C Function} scm_string_tokenize (s, token_set, start, end)
Split the string @var{s} into a list of substrings, where each
substring is a maximal non-empty contiguous sequence of
characters from the character set @var{token_set}, which
defaults to @code{char-set:graphic}.
If @var{start} or @var{end} indices are provided, they restrict
@code{string-tokenize} to operating on the indicated substring
of @var{s}.
@end deffn

string-split
@c snarfed from srfi-13.c:3220
@deffn {Scheme Procedure} string-split str chr
@deffnx {C Function} scm_string_split (str, chr)
Split the string @var{str} into the a list of the substrings delimited
by appearances of the character @var{chr}.  Note that an empty substring
between separator characters will result in an empty string in the
result list.

@lisp
(string-split "root:x:0:0:root:/root:/bin/bash" #\:)
@result{}
("root" "x" "0" "0" "root" "/root" "/bin/bash")

(string-split "::" #\:)
@result{}
("" "" "")

(string-split "" #\:)
@result{}
("")
@end lisp
@end deffn

string-filter
@c snarfed from srfi-13.c:3258
@deffn {Scheme Procedure} string-filter s char_pred [start [end]]
@deffnx {C Function} scm_string_filter (s, char_pred, start, end)
Filter the string @var{s}, retaining only those characters that
satisfy the @var{char_pred} argument.  If the argument is a
procedure, it is applied to each character as a predicate, if
it is a character, it is tested for equality and if it is a
character set, it is tested for membership.
@end deffn

string-delete
@c snarfed from srfi-13.c:3330
@deffn {Scheme Procedure} string-delete s char_pred [start [end]]
@deffnx {C Function} scm_string_delete (s, char_pred, start, end)
Filter the string @var{s}, retaining only those characters that
do not satisfy the @var{char_pred} argument.  If the argument
is a procedure, it is applied to each character as a predicate,
if it is a character, it is tested for equality and if it is a
character set, it is tested for membership.
@end deffn

char-set?
@c snarfed from srfi-14.c:85
@deffn {Scheme Procedure} char-set? obj
@deffnx {C Function} scm_char_set_p (obj)
Return @code{#t} if @var{obj} is a character set, @code{#f}
otherwise.
@end deffn

char-set=
@c snarfed from srfi-14.c:95
@deffn {Scheme Procedure} char-set= . char_sets
@deffnx {C Function} scm_char_set_eq (char_sets)
Return @code{#t} if all given character sets are equal.
@end deffn

char-set<=
@c snarfed from srfi-14.c:125
@deffn {Scheme Procedure} char-set<= . char_sets
@deffnx {C Function} scm_char_set_leq (char_sets)
Return @code{#t} if every character set @var{cs}i is a subset
of character set @var{cs}i+1.
@end deffn

char-set-hash
@c snarfed from srfi-14.c:163
@deffn {Scheme Procedure} char-set-hash cs [bound]
@deffnx {C Function} scm_char_set_hash (cs, bound)
Compute a hash value for the character set @var{cs}.  If
@var{bound} is given and non-zero, it restricts the
returned value to the range 0 @dots{} @var{bound - 1}.
@end deffn

char-set-cursor
@c snarfed from srfi-14.c:196
@deffn {Scheme Procedure} char-set-cursor cs
@deffnx {C Function} scm_char_set_cursor (cs)
Return a cursor into the character set @var{cs}.
@end deffn

char-set-ref
@c snarfed from srfi-14.c:216
@deffn {Scheme Procedure} char-set-ref cs cursor
@deffnx {C Function} scm_char_set_ref (cs, cursor)
Return the character at the current cursor position
@var{cursor} in the character set @var{cs}.  It is an error to
pass a cursor for which @code{end-of-char-set?} returns true.
@end deffn

char-set-cursor-next
@c snarfed from srfi-14.c:233
@deffn {Scheme Procedure} char-set-cursor-next cs cursor
@deffnx {C Function} scm_char_set_cursor_next (cs, cursor)
Advance the character set cursor @var{cursor} to the next
character in the character set @var{cs}.  It is an error if the
cursor given satisfies @code{end-of-char-set?}.
@end deffn

end-of-char-set?
@c snarfed from srfi-14.c:254
@deffn {Scheme Procedure} end-of-char-set? cursor
@deffnx {C Function} scm_end_of_char_set_p (cursor)
Return @code{#t} if @var{cursor} has reached the end of a
character set, @code{#f} otherwise.
@end deffn

char-set-fold
@c snarfed from srfi-14.c:266
@deffn {Scheme Procedure} char-set-fold kons knil cs
@deffnx {C Function} scm_char_set_fold (kons, knil, cs)
Fold the procedure @var{kons} over the character set @var{cs},
initializing it with @var{knil}.
@end deffn

char-set-unfold
@c snarfed from srfi-14.c:296
@deffn {Scheme Procedure} char-set-unfold p f g seed [base_cs]
@deffnx {C Function} scm_char_set_unfold (p, f, g, seed, base_cs)
This is a fundamental constructor for character sets.
@itemize @bullet
@item @var{g} is used to generate a series of ``seed'' values
from the initial seed: @var{seed}, (@var{g} @var{seed}),
(@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}), @dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of the seed values.
@item @var{f} maps each seed value to a character. These
characters are added to the base character set @var{base_cs} to
form the result; @var{base_cs} defaults to the empty set.
@end itemize
@end deffn

char-set-unfold!
@c snarfed from srfi-14.c:340
@deffn {Scheme Procedure} char-set-unfold! p f g seed base_cs
@deffnx {C Function} scm_char_set_unfold_x (p, f, g, seed, base_cs)
This is a fundamental constructor for character sets.
@itemize @bullet
@item @var{g} is used to generate a series of ``seed'' values
from the initial seed: @var{seed}, (@var{g} @var{seed}),
(@var{g}^2 @var{seed}), (@var{g}^3 @var{seed}), @dots{}
@item @var{p} tells us when to stop -- when it returns true
when applied to one of the seed values.
@item @var{f} maps each seed value to a character. These
characters are added to the base character set @var{base_cs} to
form the result; @var{base_cs} defaults to the empty set.
@end itemize
@end deffn

char-set-for-each
@c snarfed from srfi-14.c:369
@deffn {Scheme Procedure} char-set-for-each proc cs
@deffnx {C Function} scm_char_set_for_each (proc, cs)
Apply @var{proc} to every character in the character set
@var{cs}.  The return value is not specified.
@end deffn

char-set-map
@c snarfed from srfi-14.c:388
@deffn {Scheme Procedure} char-set-map proc cs
@deffnx {C Function} scm_char_set_map (proc, cs)
Map the procedure @var{proc} over every character in @var{cs}.
@var{proc} must be a character -> character procedure.
@end deffn

char-set-copy
@c snarfed from srfi-14.c:414
@deffn {Scheme Procedure} char-set-copy cs
@deffnx {C Function} scm_char_set_copy (cs)
Return a newly allocated character set containing all
characters in @var{cs}.
@end deffn

char-set
@c snarfed from srfi-14.c:434
@deffn {Scheme Procedure} char-set . rest
@deffnx {C Function} scm_char_set (rest)
Return a character set containing all given characters.
@end deffn

list->char-set
@c snarfed from srfi-14.c:462
@deffn {Scheme Procedure} list->char-set list [base_cs]
@deffnx {C Function} scm_list_to_char_set (list, base_cs)
Convert the character list @var{list} to a character set.  If
the character set @var{base_cs} is given, the character in this
set are also included in the result.
@end deffn

list->char-set!
@c snarfed from srfi-14.c:496
@deffn {Scheme Procedure} list->char-set! list base_cs
@deffnx {C Function} scm_list_to_char_set_x (list, base_cs)
Convert the character list @var{list} to a character set.  The
characters are added to @var{base_cs} and @var{base_cs} is
returned.
@end deffn

string->char-set
@c snarfed from srfi-14.c:523
@deffn {Scheme Procedure} string->char-set str [base_cs]
@deffnx {C Function} scm_string_to_char_set (str, base_cs)
Convert the string @var{str} to a character set.  If the
character set @var{base_cs} is given, the characters in this
set are also included in the result.
@end deffn

string->char-set!
@c snarfed from srfi-14.c:557
@deffn {Scheme Procedure} string->char-set! str base_cs
@deffnx {C Function} scm_string_to_char_set_x (str, base_cs)
Convert the string @var{str} to a character set.  The
characters from the string are added to @var{base_cs}, and
@var{base_cs} is returned.
@end deffn

char-set-filter
@c snarfed from srfi-14.c:584
@deffn {Scheme Procedure} char-set-filter pred cs [base_cs]
@deffnx {C Function} scm_char_set_filter (pred, cs, base_cs)
Return a character set containing every character from @var{cs}
so that it satisfies @var{pred}.  If provided, the characters
from @var{base_cs} are added to the result.
@end deffn

char-set-filter!
@c snarfed from srfi-14.c:620
@deffn {Scheme Procedure} char-set-filter! pred cs base_cs
@deffnx {C Function} scm_char_set_filter_x (pred, cs, base_cs)
Return a character set containing every character from @var{cs}
so that it satisfies @var{pred}.  The characters are added to
@var{base_cs} and @var{base_cs} is returned.
@end deffn

ucs-range->char-set
@c snarfed from srfi-14.c:658
@deffn {Scheme Procedure} ucs-range->char-set lower upper [error [base_cs]]
@deffnx {C Function} scm_ucs_range_to_char_set (lower, upper, error, base_cs)
Return a character set containing all characters whose
character codes lie in the half-open range
[@var{lower},@var{upper}).

If @var{error} is a true value, an error is signalled if the
specified range contains characters which are not contained in
the implemented character range.  If @var{error} is @code{#f},
these characters are silently left out of the resultung
character set.

The characters in @var{base_cs} are added to the result, if
given.
@end deffn

ucs-range->char-set!
@c snarfed from srfi-14.c:711
@deffn {Scheme Procedure} ucs-range->char-set! lower upper error base_cs
@deffnx {C Function} scm_ucs_range_to_char_set_x (lower, upper, error, base_cs)
Return a character set containing all characters whose
character codes lie in the half-open range
[@var{lower},@var{upper}).

If @var{error} is a true value, an error is signalled if the
specified range contains characters which are not contained in
the implemented character range.  If @var{error} is @code{#f},
these characters are silently left out of the resultung
character set.

The characters are added to @var{base_cs} and @var{base_cs} is
returned.
@end deffn

->char-set
@c snarfed from srfi-14.c:741
@deffn {Scheme Procedure} ->char-set x
@deffnx {C Function} scm_to_char_set (x)
Coerces x into a char-set. @var{x} may be a string, character or char-set. A string is converted to the set of its constituent characters; a character is converted to a singleton set; a char-set is returned as-is.
@end deffn

char-set-size
@c snarfed from srfi-14.c:757
@deffn {Scheme Procedure} char-set-size cs
@deffnx {C Function} scm_char_set_size (cs)
Return the number of elements in character set @var{cs}.
@end deffn

char-set-count
@c snarfed from srfi-14.c:774
@deffn {Scheme Procedure} char-set-count pred cs
@deffnx {C Function} scm_char_set_count (pred, cs)
Return the number of the elements int the character set
@var{cs} which satisfy the predicate @var{pred}.
@end deffn

char-set->list
@c snarfed from srfi-14.c:797
@deffn {Scheme Procedure} char-set->list cs
@deffnx {C Function} scm_char_set_to_list (cs)
Return a list containing the elements of the character set
@var{cs}.
@end deffn

char-set->string
@c snarfed from srfi-14.c:816
@deffn {Scheme Procedure} char-set->string cs
@deffnx {C Function} scm_char_set_to_string (cs)
Return a string containing the elements of the character set
@var{cs}.  The order in which the characters are placed in the
string is not defined.
@end deffn

char-set-contains?
@c snarfed from srfi-14.c:841
@deffn {Scheme Procedure} char-set-contains? cs ch
@deffnx {C Function} scm_char_set_contains_p (cs, ch)
Return @code{#t} iff the character @var{ch} is contained in the
character set @var{cs}.
@end deffn

char-set-every
@c snarfed from srfi-14.c:854
@deffn {Scheme Procedure} char-set-every pred cs
@deffnx {C Function} scm_char_set_every (pred, cs)
Return a true value if every character in the character set
@var{cs} satisfies the predicate @var{pred}.
@end deffn

char-set-any
@c snarfed from srfi-14.c:878
@deffn {Scheme Procedure} char-set-any pred cs
@deffnx {C Function} scm_char_set_any (pred, cs)
Return a true value if any character in the character set
@var{cs} satisfies the predicate @var{pred}.
@end deffn

char-set-adjoin
@c snarfed from srfi-14.c:901
@deffn {Scheme Procedure} char-set-adjoin cs . rest
@deffnx {C Function} scm_char_set_adjoin (cs, rest)
Add all character arguments to the first argument, which must
be a character set.
@end deffn

char-set-delete
@c snarfed from srfi-14.c:929
@deffn {Scheme Procedure} char-set-delete cs . rest
@deffnx {C Function} scm_char_set_delete (cs, rest)
Delete all character arguments from the first argument, which
must be a character set.
@end deffn

char-set-adjoin!
@c snarfed from srfi-14.c:957
@deffn {Scheme Procedure} char-set-adjoin! cs . rest
@deffnx {C Function} scm_char_set_adjoin_x (cs, rest)
Add all character arguments to the first argument, which must
be a character set.
@end deffn

char-set-delete!
@c snarfed from srfi-14.c:984
@deffn {Scheme Procedure} char-set-delete! cs . rest
@deffnx {C Function} scm_char_set_delete_x (cs, rest)
Delete all character arguments from the first argument, which
must be a character set.
@end deffn

char-set-complement
@c snarfed from srfi-14.c:1010
@deffn {Scheme Procedure} char-set-complement cs
@deffnx {C Function} scm_char_set_complement (cs)
Return the complement of the character set @var{cs}.
@end deffn

char-set-union
@c snarfed from srfi-14.c:1031
@deffn {Scheme Procedure} char-set-union . rest
@deffnx {C Function} scm_char_set_union (rest)
Return the union of all argument character sets.
@end deffn

char-set-intersection
@c snarfed from srfi-14.c:1060
@deffn {Scheme Procedure} char-set-intersection . rest
@deffnx {C Function} scm_char_set_intersection (rest)
Return the intersection of all argument character sets.
@end deffn

char-set-difference
@c snarfed from srfi-14.c:1100
@deffn {Scheme Procedure} char-set-difference cs1 . rest
@deffnx {C Function} scm_char_set_difference (cs1, rest)
Return the difference of all argument character sets.
@end deffn

char-set-xor
@c snarfed from srfi-14.c:1130
@deffn {Scheme Procedure} char-set-xor . rest
@deffnx {C Function} scm_char_set_xor (rest)
Return the exclusive-or of all argument character sets.
@end deffn

char-set-diff+intersection
@c snarfed from srfi-14.c:1171
@deffn {Scheme Procedure} char-set-diff+intersection cs1 . rest
@deffnx {C Function} scm_char_set_diff_plus_intersection (cs1, rest)
Return the difference and the intersection of all argument
character sets.
@end deffn

char-set-complement!
@c snarfed from srfi-14.c:1209
@deffn {Scheme Procedure} char-set-complement! cs
@deffnx {C Function} scm_char_set_complement_x (cs)
Return the complement of the character set @var{cs}.
@end deffn

char-set-union!
@c snarfed from srfi-14.c:1226
@deffn {Scheme Procedure} char-set-union! cs1 . rest
@deffnx {C Function} scm_char_set_union_x (cs1, rest)
Return the union of all argument character sets.
@end deffn

char-set-intersection!
@c snarfed from srfi-14.c:1254
@deffn {Scheme Procedure} char-set-intersection! cs1 . rest
@deffnx {C Function} scm_char_set_intersection_x (cs1, rest)
Return the intersection of all argument character sets.
@end deffn

char-set-difference!
@c snarfed from srfi-14.c:1282
@deffn {Scheme Procedure} char-set-difference! cs1 . rest
@deffnx {C Function} scm_char_set_difference_x (cs1, rest)
Return the difference of all argument character sets.
@end deffn

char-set-xor!
@c snarfed from srfi-14.c:1310
@deffn {Scheme Procedure} char-set-xor! cs1 . rest
@deffnx {C Function} scm_char_set_xor_x (cs1, rest)
Return the exclusive-or of all argument character sets.
@end deffn

char-set-diff+intersection!
@c snarfed from srfi-14.c:1349
@deffn {Scheme Procedure} char-set-diff+intersection! cs1 cs2 . rest
@deffnx {C Function} scm_char_set_diff_plus_intersection_x (cs1, cs2, rest)
Return the difference and the intersection of all argument
character sets.
@end deffn

string=?
@c snarfed from strorder.c:50
@deffn {Scheme Procedure} string=? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_equal_p (s1, s2, rest)
Lexicographic equality predicate; return @code{#t} if the two
strings are the same length and contain the same characters in
the same positions, otherwise return @code{#f}.

The procedure @code{string-ci=?} treats upper and lower case
letters as though they were the same character, but
@code{string=?} treats upper and lower case as distinct
characters.
@end deffn

string-ci=?
@c snarfed from strorder.c:62
@deffn {Scheme Procedure} string-ci=? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_ci_equal_p (s1, s2, rest)
Case-insensitive string equality predicate; return @code{#t} if
the two strings are the same length and their component
characters match (ignoring case) at each position; otherwise
return @code{#f}.
@end deffn

string<?
@c snarfed from strorder.c:72
@deffn {Scheme Procedure} string<? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_less_p (s1, s2, rest)
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically less than @var{s2}.
@end deffn

string<=?
@c snarfed from strorder.c:82
@deffn {Scheme Procedure} string<=? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_leq_p (s1, s2, rest)
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically less than or equal to @var{s2}.
@end deffn

string>?
@c snarfed from strorder.c:92
@deffn {Scheme Procedure} string>? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_gr_p (s1, s2, rest)
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically greater than @var{s2}.
@end deffn

string>=?
@c snarfed from strorder.c:102
@deffn {Scheme Procedure} string>=? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_geq_p (s1, s2, rest)
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically greater than or equal to @var{s2}.
@end deffn

string-ci<?
@c snarfed from strorder.c:113
@deffn {Scheme Procedure} string-ci<? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_ci_less_p (s1, s2, rest)
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically less than @var{s2}
regardless of case.
@end deffn

string-ci<=?
@c snarfed from strorder.c:124
@deffn {Scheme Procedure} string-ci<=? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_ci_leq_p (s1, s2, rest)
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically less than or equal
to @var{s2} regardless of case.
@end deffn

string-ci>?
@c snarfed from strorder.c:135
@deffn {Scheme Procedure} string-ci>? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_ci_gr_p (s1, s2, rest)
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically greater than
@var{s2} regardless of case.
@end deffn

string-ci>=?
@c snarfed from strorder.c:146
@deffn {Scheme Procedure} string-ci>=? [s1 [s2 . rest]]
@deffnx {C Function} scm_i_string_ci_geq_p (s1, s2, rest)
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically greater than or
equal to @var{s2} regardless of case.
@end deffn

object->string
@c snarfed from strports.c:332
@deffn {Scheme Procedure} object->string obj [printer]
@deffnx {C Function} scm_object_to_string (obj, printer)
Return a Scheme string obtained by printing @var{obj}.
Printing function can be specified by the optional second
argument @var{printer} (default: @code{write}).
@end deffn

call-with-output-string
@c snarfed from strports.c:356
@deffn {Scheme Procedure} call-with-output-string proc
@deffnx {C Function} scm_call_with_output_string (proc)
Calls the one-argument procedure @var{proc} with a newly created output
port.  When the function returns, the string composed of the characters
written into the port is returned.
@end deffn

call-with-input-string
@c snarfed from strports.c:375
@deffn {Scheme Procedure} call-with-input-string string proc
@deffnx {C Function} scm_call_with_input_string (string, proc)
Calls the one-argument procedure @var{proc} with a newly
created input port from which @var{string}'s contents may be
read.  The value yielded by the @var{proc} is returned.
@end deffn

open-input-string
@c snarfed from strports.c:388
@deffn {Scheme Procedure} open-input-string str
@deffnx {C Function} scm_open_input_string (str)
Take a string and return an input port that delivers characters
from the string. The port can be closed by
@code{close-input-port}, though its storage will be reclaimed
by the garbage collector if it becomes inaccessible.
@end deffn

open-output-string
@c snarfed from strports.c:402
@deffn {Scheme Procedure} open-output-string
@deffnx {C Function} scm_open_output_string ()
Return an output port that will accumulate characters for
retrieval by @code{get-output-string}. The port can be closed
by the procedure @code{close-output-port}, though its storage
will be reclaimed by the garbage collector if it becomes
inaccessible.
@end deffn

get-output-string
@c snarfed from strports.c:419
@deffn {Scheme Procedure} get-output-string port
@deffnx {C Function} scm_get_output_string (port)
Given an output port created by @code{open-output-string},
return a string consisting of the characters that have been
output to the port so far.
@end deffn

eval-string
@c snarfed from strports.c:488
@deffn {Scheme Procedure} eval-string string [module]
@deffnx {C Function} scm_eval_string_in_module (string, module)
Evaluate @var{string} as the text representation of a Scheme
form or forms, and return whatever value they produce.
Evaluation takes place in the given module, or the current
module when no module is given.
While the code is evaluated, the given module is made the
current one.  The current module is restored when this
procedure returns.
@end deffn

make-struct-layout
@c snarfed from struct.c:56
@deffn {Scheme Procedure} make-struct-layout fields
@deffnx {C Function} scm_make_struct_layout (fields)
Return a new structure layout object.

@var{fields} must be a string made up of pairs of characters
strung together.  The first character of each pair describes a field
type, the second a field protection.  Allowed types are 'p' for
GC-protected Scheme data, 'u' for unprotected binary data, and 's' for
a field that points to the structure itself.    Allowed protections
are 'w' for mutable fields, 'r' for read-only fields, and 'o' for opaque
fields.  The last field protection specification may be capitalized to
indicate that the field is a tail-array.
@end deffn

struct?
@c snarfed from struct.c:223
@deffn {Scheme Procedure} struct? x
@deffnx {C Function} scm_struct_p (x)
Return @code{#t} iff @var{x} is a structure object, else
@code{#f}.
@end deffn

struct-vtable?
@c snarfed from struct.c:232
@deffn {Scheme Procedure} struct-vtable? x
@deffnx {C Function} scm_struct_vtable_p (x)
Return @code{#t} iff @var{x} is a vtable structure.
@end deffn

make-struct
@c snarfed from struct.c:418
@deffn {Scheme Procedure} make-struct vtable tail_array_size . init
@deffnx {C Function} scm_make_struct (vtable, tail_array_size, init)
Create a new structure.

@var{type} must be a vtable structure (@pxref{Vtables}).

@var{tail-elts} must be a non-negative integer.  If the layout
specification indicated by @var{type} includes a tail-array,
this is the number of elements allocated to that array.

The @var{init1}, @dots{} are optional arguments describing how
successive fields of the structure should be initialized.  Only fields
with protection 'r' or 'w' can be initialized, except for fields of
type 's', which are automatically initialized to point to the new
structure itself; fields with protection 'o' can not be initialized by
Scheme programs.

If fewer optional arguments than initializable fields are supplied,
fields of type 'p' get default value #f while fields of type 'u' are
initialized to 0.

Structs are currently the basic representation for record-like data
structures in Guile.  The plan is to eventually replace them with a
new representation which will at the same time be easier to use and
more powerful.

For more information, see the documentation for @code{make-vtable-vtable}.
@end deffn

make-vtable-vtable
@c snarfed from struct.c:502
@deffn {Scheme Procedure} make-vtable-vtable user_fields tail_array_size . init
@deffnx {C Function} scm_make_vtable_vtable (user_fields, tail_array_size, init)
Return a new, self-describing vtable structure.

@var{user-fields} is a string describing user defined fields of the
vtable beginning at index @code{vtable-offset-user}
(see @code{make-struct-layout}).

@var{tail-size} specifies the size of the tail-array (if any) of
this vtable.

@var{init1}, @dots{} are the optional initializers for the fields of
the vtable.

Vtables have one initializable system field---the struct printer.
This field comes before the user fields in the initializers passed
to @code{make-vtable-vtable} and @code{make-struct}, and thus works as
a third optional argument to @code{make-vtable-vtable} and a fourth to
@code{make-struct} when creating vtables:

If the value is a procedure, it will be called instead of the standard
printer whenever a struct described by this vtable is printed.
The procedure will be called with arguments STRUCT and PORT.

The structure of a struct is described by a vtable, so the vtable is
in essence the type of the struct.  The vtable is itself a struct with
a vtable.  This could go on forever if it weren't for the
vtable-vtables which are self-describing vtables, and thus terminate
the chain.

There are several potential ways of using structs, but the standard
one is to use three kinds of structs, together building up a type
sub-system: one vtable-vtable working as the root and one or several
"types", each with a set of "instances".  (The vtable-vtable should be
compared to the class <class> which is the class of itself.)

@lisp
(define ball-root (make-vtable-vtable "pr" 0))

(define (make-ball-type ball-color)
  (make-struct ball-root 0
	       (make-struct-layout "pw")
               (lambda (ball port)
                 (format port "#<a ~A ball owned by ~A>"
                         (color ball)
                         (owner ball)))
               ball-color))
(define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
(define (owner ball) (struct-ref ball 0))

(define red (make-ball-type 'red))
(define green (make-ball-type 'green))

(define (make-ball type owner) (make-struct type 0 owner))

(define ball (make-ball green 'Nisse))
ball @result{} #<a green ball owned by Nisse>
@end lisp
@end deffn

struct-ref
@c snarfed from struct.c:542
@deffn {Scheme Procedure} struct-ref handle pos
@deffnx {Scheme Procedure} struct-set! struct n value
@deffnx {C Function} scm_struct_ref (handle, pos)
Access (or modify) the @var{n}th field of @var{struct}.

If the field is of type 'p', then it can be set to an arbitrary value.

If the field is of type 'u', then it can only be set to a non-negative
integer value small enough to fit in one machine word.
@end deffn

struct-set!
@c snarfed from struct.c:621
@deffn {Scheme Procedure} struct-set! handle pos val
@deffnx {C Function} scm_struct_set_x (handle, pos, val)
Set the slot of the structure @var{handle} with index @var{pos}
to @var{val}.  Signal an error if the slot can not be written
to.
@end deffn

struct-vtable
@c snarfed from struct.c:692
@deffn {Scheme Procedure} struct-vtable handle
@deffnx {C Function} scm_struct_vtable (handle)
Return the vtable structure that describes the type of @var{struct}.
@end deffn

struct-vtable-tag
@c snarfed from struct.c:703
@deffn {Scheme Procedure} struct-vtable-tag handle
@deffnx {C Function} scm_struct_vtable_tag (handle)
Return the vtable tag of the structure @var{handle}.
@end deffn

struct-vtable-name
@c snarfed from struct.c:742
@deffn {Scheme Procedure} struct-vtable-name vtable
@deffnx {C Function} scm_struct_vtable_name (vtable)
Return the name of the vtable @var{vtable}.
@end deffn

set-struct-vtable-name!
@c snarfed from struct.c:752
@deffn {Scheme Procedure} set-struct-vtable-name! vtable name
@deffnx {C Function} scm_set_struct_vtable_name_x (vtable, name)
Set the name of the vtable @var{vtable} to @var{name}.
@end deffn

symbol?
@c snarfed from symbols.c:156
@deffn {Scheme Procedure} symbol? obj
@deffnx {C Function} scm_symbol_p (obj)
Return @code{#t} if @var{obj} is a symbol, otherwise return
@code{#f}.
@end deffn

symbol-interned?
@c snarfed from symbols.c:166
@deffn {Scheme Procedure} symbol-interned? symbol
@deffnx {C Function} scm_symbol_interned_p (symbol)
Return @code{#t} if @var{symbol} is interned, otherwise return
@code{#f}.
@end deffn

make-symbol
@c snarfed from symbols.c:178
@deffn {Scheme Procedure} make-symbol name
@deffnx {C Function} scm_make_symbol (name)
Return a new uninterned symbol with the name @var{name}.  The returned symbol is guaranteed to be unique and future calls to @code{string->symbol} will not return it.
@end deffn

symbol->string
@c snarfed from symbols.c:210
@deffn {Scheme Procedure} symbol->string s
@deffnx {C Function} scm_symbol_to_string (s)
Return the name of @var{symbol} as a string.  If the symbol was
part of an object returned as the value of a literal expression
(section @pxref{Literal expressions,,,r5rs, The Revised^5
Report on Scheme}) or by a call to the @code{read} procedure,
and its name contains alphabetic characters, then the string
returned will contain characters in the implementation's
preferred standard case---some implementations will prefer
upper case, others lower case.  If the symbol was returned by
@code{string->symbol}, the case of characters in the string
returned will be the same as the case in the string that was
passed to @code{string->symbol}.  It is an error to apply
mutation procedures like @code{string-set!} to strings returned
by this procedure.

The following examples assume that the implementation's
standard case is lower case:

@lisp
(symbol->string 'flying-fish)    @result{} "flying-fish"
(symbol->string 'Martin)         @result{}  "martin"
(symbol->string
   (string->symbol "Malvina")) @result{} "Malvina"
@end lisp
@end deffn

string->symbol
@c snarfed from symbols.c:240
@deffn {Scheme Procedure} string->symbol string
@deffnx {C Function} scm_string_to_symbol (string)
Return the symbol whose name is @var{string}. This procedure
can create symbols with names containing special characters or
letters in the non-standard case, but it is usually a bad idea
to create such symbols because in some implementations of
Scheme they cannot be read as themselves.  See
@code{symbol->string}.

The following examples assume that the implementation's
standard case is lower case:

@lisp
(eq? 'mISSISSIppi 'mississippi) @result{} #t
(string->symbol "mISSISSIppi") @result{} @r{the symbol with name "mISSISSIppi"}
(eq? 'bitBlt (string->symbol "bitBlt")) @result{} #f
(eq? 'JollyWog
  (string->symbol (symbol->string 'JollyWog))) @result{} #t
(string=? "K. Harper, M.D."
  (symbol->string
    (string->symbol "K. Harper, M.D."))) @result{}#t
@end lisp
@end deffn

string-ci->symbol
@c snarfed from symbols.c:252
@deffn {Scheme Procedure} string-ci->symbol str
@deffnx {C Function} scm_string_ci_to_symbol (str)
Return the symbol whose name is @var{str}.  @var{str} is
converted to lowercase before the conversion is done, if Guile
is currently reading symbols case-insensitively.
@end deffn

gensym
@c snarfed from symbols.c:269
@deffn {Scheme Procedure} gensym [prefix]
@deffnx {C Function} scm_gensym (prefix)
Create a new symbol with a name constructed from a prefix and
a counter value. The string @var{prefix} can be specified as
an optional argument. Default prefix is @code{ g}.  The counter
is increased by 1 at each call. There is no provision for
resetting the counter.
@end deffn

symbol-hash
@c snarfed from symbols.c:295
@deffn {Scheme Procedure} symbol-hash symbol
@deffnx {C Function} scm_symbol_hash (symbol)
Return a hash value for @var{symbol}.
@end deffn

symbol-fref
@c snarfed from symbols.c:305
@deffn {Scheme Procedure} symbol-fref s
@deffnx {C Function} scm_symbol_fref (s)
Return the contents of @var{symbol}'s @dfn{function slot}.
@end deffn

symbol-pref
@c snarfed from symbols.c:316
@deffn {Scheme Procedure} symbol-pref s
@deffnx {C Function} scm_symbol_pref (s)
Return the @dfn{property list} currently associated with @var{symbol}.
@end deffn

symbol-fset!
@c snarfed from symbols.c:327
@deffn {Scheme Procedure} symbol-fset! s val
@deffnx {C Function} scm_symbol_fset_x (s, val)
Change the binding of @var{symbol}'s function slot.
@end deffn

symbol-pset!
@c snarfed from symbols.c:339
@deffn {Scheme Procedure} symbol-pset! s val
@deffnx {C Function} scm_symbol_pset_x (s, val)
Change the binding of @var{symbol}'s property slot.
@end deffn

call-with-new-thread
@c snarfed from threads.c:611
@deffn {Scheme Procedure} call-with-new-thread thunk [handler]
@deffnx {C Function} scm_call_with_new_thread (thunk, handler)
Call @code{thunk} in a new thread and with a new dynamic state,
returning a new thread object representing the thread.  The procedure
@var{thunk} is called via @code{with-continuation-barrier}.

When @var{handler} is specified, then @var{thunk} is called from
within a @code{catch} with tag @code{#t} that has @var{handler} as its
handler.  This catch is established inside the continuation barrier.

Once @var{thunk} or @var{handler} returns, the return value is made
the @emph{exit value} of the thread and the thread is terminated.
@end deffn

yield
@c snarfed from threads.c:722
@deffn {Scheme Procedure} yield
@deffnx {C Function} scm_yield ()
Move the calling thread to the end of the scheduling queue.
@end deffn

join-thread
@c snarfed from threads.c:732
@deffn {Scheme Procedure} join-thread thread
@deffnx {C Function} scm_join_thread (thread)
Suspend execution of the calling thread until the target @var{thread} terminates, unless the target @var{thread} has already terminated. 
@end deffn

make-mutex
@c snarfed from threads.c:828
@deffn {Scheme Procedure} make-mutex
@deffnx {C Function} scm_make_mutex ()
Create a new mutex. 
@end deffn

make-recursive-mutex
@c snarfed from threads.c:837
@deffn {Scheme Procedure} make-recursive-mutex
@deffnx {C Function} scm_make_recursive_mutex ()
Create a new recursive mutex. 
@end deffn

lock-mutex
@c snarfed from threads.c:883
@deffn {Scheme Procedure} lock-mutex mx
@deffnx {C Function} scm_lock_mutex (mx)
Lock @var{mutex}. If the mutex is already locked, the calling thread blocks until the mutex becomes available. The function returns when the calling thread owns the lock on @var{mutex}.  Locking a mutex that a thread already owns will succeed right away and will not block the thread.  That is, Guile's mutexes are @emph{recursive}. 
@end deffn

try-mutex
@c snarfed from threads.c:931
@deffn {Scheme Procedure} try-mutex mutex
@deffnx {C Function} scm_try_mutex (mutex)
Try to lock @var{mutex}. If the mutex is already locked by someone else, return @code{#f}.  Else lock the mutex and return @code{#t}. 
@end deffn

unlock-mutex
@c snarfed from threads.c:976
@deffn {Scheme Procedure} unlock-mutex mx
@deffnx {C Function} scm_unlock_mutex (mx)
Unlocks @var{mutex} if the calling thread owns the lock on @var{mutex}.  Calling unlock-mutex on a mutex not owned by the current thread results in undefined behaviour. Once a mutex has been unlocked, one thread blocked on @var{mutex} is awakened and grabs the mutex lock.  Every call to @code{lock-mutex} by this thread must be matched with a call to @code{unlock-mutex}.  Only the last call to @code{unlock-mutex} will actually unlock the mutex. 
@end deffn

make-condition-variable
@c snarfed from threads.c:1052
@deffn {Scheme Procedure} make-condition-variable
@deffnx {C Function} scm_make_condition_variable ()
Make a new condition variable.
@end deffn

wait-condition-variable
@c snarfed from threads.c:1120
@deffn {Scheme Procedure} wait-condition-variable cv mx [t]
@deffnx {C Function} scm_timed_wait_condition_variable (cv, mx, t)
Wait until @var{cond-var} has been signalled.  While waiting, @var{mutex} is atomically unlocked (as with @code{unlock-mutex}) and is locked again when this function returns.  When @var{time} is given, it specifies a point in time where the waiting should be aborted.  It can be either a integer as returned by @code{current-time} or a pair as returned by @code{gettimeofday}.  When the waiting is aborted the mutex is locked and @code{#f} is returned.  When the condition variable is in fact signalled, the mutex is also locked and @code{#t} is returned. 
@end deffn

signal-condition-variable
@c snarfed from threads.c:1157
@deffn {Scheme Procedure} signal-condition-variable cv
@deffnx {C Function} scm_signal_condition_variable (cv)
Wake up one thread that is waiting for @var{cv}
@end deffn

broadcast-condition-variable
@c snarfed from threads.c:1177
@deffn {Scheme Procedure} broadcast-condition-variable cv
@deffnx {C Function} scm_broadcast_condition_variable (cv)
Wake up all threads that are waiting for @var{cv}. 
@end deffn

current-thread
@c snarfed from threads.c:1354
@deffn {Scheme Procedure} current-thread
@deffnx {C Function} scm_current_thread ()
Return the thread that called this function.
@end deffn

all-threads
@c snarfed from threads.c:1372
@deffn {Scheme Procedure} all-threads
@deffnx {C Function} scm_all_threads ()
Return a list of all threads.
@end deffn

thread-exited?
@c snarfed from threads.c:1398
@deffn {Scheme Procedure} thread-exited? thread
@deffnx {C Function} scm_thread_exited_p (thread)
Return @code{#t} iff @var{thread} has exited.

@end deffn

catch
@c snarfed from throw.c:512
@deffn {Scheme Procedure} catch key thunk handler
@deffnx {C Function} scm_catch (key, thunk, handler)
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol
@var{key}, then @var{handler} is invoked this way:
@lisp
(handler key args ...)
@end lisp

@var{key} is a symbol or @code{#t}.

@var{thunk} takes no arguments.  If @var{thunk} returns
normally, that is the return value of @code{catch}.

Handler is invoked outside the scope of its own @code{catch}.
If @var{handler} again throws to the same key, a new handler
from further up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will
match this call to @code{catch}.
@end deffn

lazy-catch
@c snarfed from throw.c:540
@deffn {Scheme Procedure} lazy-catch key thunk handler
@deffnx {C Function} scm_lazy_catch (key, thunk, handler)
This behaves exactly like @code{catch}, except that it does
not unwind the stack before invoking @var{handler}.
The @var{handler} procedure is not allowed to return:
it must throw to another catch, or otherwise exit non-locally.
@end deffn

throw
@c snarfed from throw.c:573
@deffn {Scheme Procedure} throw key . args
@deffnx {C Function} scm_throw (key, args)
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

@var{key} is a symbol.  It will match catches of the same symbol or of
@code{#t}.

If there is no handler at all, Guile prints an error and then exits.
@end deffn

values
@c snarfed from values.c:53
@deffn {Scheme Procedure} values . args
@deffnx {C Function} scm_values (args)
Delivers all of its arguments to its continuation.  Except for
continuations created by the @code{call-with-values} procedure,
all continuations take exactly one value.  The effect of
passing no value or more than one value to continuations that
were not created by @code{call-with-values} is unspecified.
@end deffn

make-variable
@c snarfed from variable.c:52
@deffn {Scheme Procedure} make-variable init
@deffnx {C Function} scm_make_variable (init)
Return a variable initialized to value @var{init}.
@end deffn

make-undefined-variable
@c snarfed from variable.c:62
@deffn {Scheme Procedure} make-undefined-variable
@deffnx {C Function} scm_make_undefined_variable ()
Return a variable that is initially unbound.
@end deffn

variable?
@c snarfed from variable.c:73
@deffn {Scheme Procedure} variable? obj
@deffnx {C Function} scm_variable_p (obj)
Return @code{#t} iff @var{obj} is a variable object, else
return @code{#f}.
@end deffn

variable-ref
@c snarfed from variable.c:85
@deffn {Scheme Procedure} variable-ref var
@deffnx {C Function} scm_variable_ref (var)
Dereference @var{var} and return its value.
@var{var} must be a variable object; see @code{make-variable}
and @code{make-undefined-variable}.
@end deffn

variable-set!
@c snarfed from variable.c:101
@deffn {Scheme Procedure} variable-set! var val
@deffnx {C Function} scm_variable_set_x (var, val)
Set the value of the variable @var{var} to @var{val}.
@var{var} must be a variable object, @var{val} can be any
value. Return an unspecified value.
@end deffn

variable-bound?
@c snarfed from variable.c:113
@deffn {Scheme Procedure} variable-bound? var
@deffnx {C Function} scm_variable_bound_p (var)
Return @code{#t} iff @var{var} is bound to a value.
Throws an error if @var{var} is not a variable object.
@end deffn

vector?
@c snarfed from vectors.c:91
@deffn {Scheme Procedure} vector? obj
@deffnx {C Function} scm_vector_p (obj)
Return @code{#t} if @var{obj} is a vector, otherwise return
@code{#f}.
@end deffn

list->vector
@c snarfed from vectors.c:123
@deffn {Scheme Procedure} list->vector
implemented by the C function "scm_vector"
@end deffn

vector
@c snarfed from vectors.c:140
@deffn {Scheme Procedure} vector . l
@deffnx {Scheme Procedure} list->vector l
@deffnx {C Function} scm_vector (l)
Return a newly allocated vector composed of the
given arguments.  Analogous to @code{list}.

@lisp
(vector 'a 'b 'c) @result{} #(a b c)
@end lisp
@end deffn

make-vector
@c snarfed from vectors.c:276
@deffn {Scheme Procedure} make-vector k [fill]
@deffnx {C Function} scm_make_vector (k, fill)
Return a newly allocated vector of @var{k} elements.  If a
second argument is given, then each position is initialized to
@var{fill}.  Otherwise the initial contents of each position is
unspecified.
@end deffn

vector-copy
@c snarfed from vectors.c:318
@deffn {Scheme Procedure} vector-copy vec
@deffnx {C Function} scm_vector_copy (vec)
Return a copy of @var{vec}.
@end deffn

vector->list
@c snarfed from vectors.c:389
@deffn {Scheme Procedure} vector->list v
@deffnx {C Function} scm_vector_to_list (v)
Return a newly allocated list composed of the elements of @var{v}.

@lisp
(vector->list '#(dah dah didah)) @result{}  (dah dah didah)
(list->vector '(dididit dah)) @result{}  #(dididit dah)
@end lisp
@end deffn

vector-fill!
@c snarfed from vectors.c:413
@deffn {Scheme Procedure} vector-fill! v fill
@deffnx {C Function} scm_vector_fill_x (v, fill)
Store @var{fill} in every position of @var{vector}.  The value
returned by @code{vector-fill!} is unspecified.
@end deffn

vector-move-left!
@c snarfed from vectors.c:450
@deffn {Scheme Procedure} vector-move-left! vec1 start1 end1 vec2 start2
@deffnx {C Function} scm_vector_move_left_x (vec1, start1, end1, vec2, start2)
Copy elements from @var{vec1}, positions @var{start1} to @var{end1},
to @var{vec2} starting at position @var{start2}.  @var{start1} and
@var{start2} are inclusive indices; @var{end1} is exclusive.

@code{vector-move-left!} copies elements in leftmost order.
Therefore, in the case where @var{vec1} and @var{vec2} refer to the
same vector, @code{vector-move-left!} is usually appropriate when
@var{start1} is greater than @var{start2}.
@end deffn

vector-move-right!
@c snarfed from vectors.c:488
@deffn {Scheme Procedure} vector-move-right! vec1 start1 end1 vec2 start2
@deffnx {C Function} scm_vector_move_right_x (vec1, start1, end1, vec2, start2)
Copy elements from @var{vec1}, positions @var{start1} to @var{end1},
to @var{vec2} starting at position @var{start2}.  @var{start1} and
@var{start2} are inclusive indices; @var{end1} is exclusive.

@code{vector-move-right!} copies elements in rightmost order.
Therefore, in the case where @var{vec1} and @var{vec2} refer to the
same vector, @code{vector-move-right!} is usually appropriate when
@var{start1} is less than @var{start2}.
@end deffn

generalized-vector?
@c snarfed from vectors.c:537
@deffn {Scheme Procedure} generalized-vector? obj
@deffnx {C Function} scm_generalized_vector_p (obj)
Return @code{#t} if @var{obj} is a vector, string,
bitvector, or uniform numeric vector.
@end deffn

generalized-vector-length
@c snarfed from vectors.c:569
@deffn {Scheme Procedure} generalized-vector-length v
@deffnx {C Function} scm_generalized_vector_length (v)
Return the length of the generalized vector @var{v}.
@end deffn

generalized-vector-ref
@c snarfed from vectors.c:594
@deffn {Scheme Procedure} generalized-vector-ref v idx
@deffnx {C Function} scm_generalized_vector_ref (v, idx)
Return the element at index @var{idx} of the
generalized vector @var{v}.
@end deffn

generalized-vector-set!
@c snarfed from vectors.c:619
@deffn {Scheme Procedure} generalized-vector-set! v idx val
@deffnx {C Function} scm_generalized_vector_set_x (v, idx, val)
Set the element at index @var{idx} of the
generalized vector @var{v} to @var{val}.
@end deffn

generalized-vector->list
@c snarfed from vectors.c:630
@deffn {Scheme Procedure} generalized-vector->list v
@deffnx {C Function} scm_generalized_vector_to_list (v)
Return a new list whose elements are the elements of the
generalized vector @var{v}.
@end deffn

major-version
@c snarfed from version.c:35
@deffn {Scheme Procedure} major-version
@deffnx {C Function} scm_major_version ()
Return a string containing Guile's major version number.
E.g., the 1 in "1.6.5".
@end deffn

minor-version
@c snarfed from version.c:48
@deffn {Scheme Procedure} minor-version
@deffnx {C Function} scm_minor_version ()
Return a string containing Guile's minor version number.
E.g., the 6 in "1.6.5".
@end deffn

micro-version
@c snarfed from version.c:61
@deffn {Scheme Procedure} micro-version
@deffnx {C Function} scm_micro_version ()
Return a string containing Guile's micro version number.
E.g., the 5 in "1.6.5".
@end deffn

version
@c snarfed from version.c:83
@deffn {Scheme Procedure} version
@deffnx {Scheme Procedure} major-version
@deffnx {Scheme Procedure} minor-version
@deffnx {Scheme Procedure} micro-version
@deffnx {C Function} scm_version ()
Return a string describing Guile's version number, or its major, minor
or micro version number, respectively.

@lisp
(version) @result{} "1.6.0"
(major-version) @result{} "1"
(minor-version) @result{} "6"
(micro-version) @result{} "0"
@end lisp
@end deffn

effective-version
@c snarfed from version.c:113
@deffn {Scheme Procedure} effective-version
@deffnx {C Function} scm_effective_version ()
Return a string describing Guile's effective version number.
@lisp
(version) @result{} "1.6.0"
(effective-version) @result{} "1.6"
(major-version) @result{} "1"
(minor-version) @result{} "6"
(micro-version) @result{} "0"
@end lisp
@end deffn

make-soft-port
@c snarfed from vports.c:185
@deffn {Scheme Procedure} make-soft-port pv modes
@deffnx {C Function} scm_make_soft_port (pv, modes)
Return a port capable of receiving or delivering characters as
specified by the @var{modes} string (@pxref{File Ports,
open-file}).  @var{pv} must be a vector of length 5 or 6.  Its
components are as follows:

@enumerate 0
@item
procedure accepting one character for output
@item
procedure accepting a string for output
@item
thunk for flushing output
@item
thunk for getting one character
@item
thunk for closing port (not by garbage collection)
@item
(if present and not @code{#f}) thunk for computing the number of
characters that can be read from the port without blocking.
@end enumerate

For an output-only port only elements 0, 1, 2, and 4 need be
procedures.  For an input-only port only elements 3 and 4 need
be procedures.  Thunks 2 and 4 can instead be @code{#f} if
there is no useful operation for them to perform.

If thunk 3 returns @code{#f} or an @code{eof-object}
(@pxref{Input, eof-object?, ,r5rs, The Revised^5 Report on
Scheme}) it indicates that the port has reached end-of-file.
For example:

@lisp
(define stdout (current-output-port))
(define p (make-soft-port
           (vector
            (lambda (c) (write c stdout))
            (lambda (s) (display s stdout))
            (lambda () (display "." stdout))
            (lambda () (char-upcase (read-char)))
            (lambda () (display "@@" stdout)))
           "rw"))

(write p p) @result{} #<input-output: soft 8081e20>
@end lisp
@end deffn

make-weak-vector
@c snarfed from weaks.c:74
@deffn {Scheme Procedure} make-weak-vector size [fill]
@deffnx {C Function} scm_make_weak_vector (size, fill)
Return a weak vector with @var{size} elements. If the optional
argument @var{fill} is given, all entries in the vector will be
set to @var{fill}. The default value for @var{fill} is the
empty list.
@end deffn

list->weak-vector
@c snarfed from weaks.c:82
@deffn {Scheme Procedure} list->weak-vector
implemented by the C function "scm_weak_vector"
@end deffn

weak-vector
@c snarfed from weaks.c:90
@deffn {Scheme Procedure} weak-vector . l
@deffnx {Scheme Procedure} list->weak-vector l
@deffnx {C Function} scm_weak_vector (l)
Construct a weak vector from a list: @code{weak-vector} uses
the list of its arguments while @code{list->weak-vector} uses
its only argument @var{l} (a list) to construct a weak vector
the same way @code{list->vector} would.
@end deffn

weak-vector?
@c snarfed from weaks.c:120
@deffn {Scheme Procedure} weak-vector? obj
@deffnx {C Function} scm_weak_vector_p (obj)
Return @code{#t} if @var{obj} is a weak vector. Note that all
weak hashes are also weak vectors.
@end deffn

make-weak-key-alist-vector
@c snarfed from weaks.c:138
@deffn {Scheme Procedure} make-weak-key-alist-vector [size]
@deffnx {Scheme Procedure} make-weak-value-alist-vector size
@deffnx {Scheme Procedure} make-doubly-weak-alist-vector size
@deffnx {C Function} scm_make_weak_key_alist_vector (size)
Return a weak hash table with @var{size} buckets. As with any
hash table, choosing a good size for the table requires some
caution.

You can modify weak hash tables in exactly the same way you
would modify regular hash tables. (@pxref{Hash Tables})
@end deffn

make-weak-value-alist-vector
@c snarfed from weaks.c:150
@deffn {Scheme Procedure} make-weak-value-alist-vector [size]
@deffnx {C Function} scm_make_weak_value_alist_vector (size)
Return a hash table with weak values with @var{size} buckets.
(@pxref{Hash Tables})
@end deffn

make-doubly-weak-alist-vector
@c snarfed from weaks.c:162
@deffn {Scheme Procedure} make-doubly-weak-alist-vector size
@deffnx {C Function} scm_make_doubly_weak_alist_vector (size)
Return a hash table with weak keys and values with @var{size}
buckets.  (@pxref{Hash Tables})
@end deffn

weak-key-alist-vector?
@c snarfed from weaks.c:177
@deffn {Scheme Procedure} weak-key-alist-vector? obj
@deffnx {Scheme Procedure} weak-value-alist-vector? obj
@deffnx {Scheme Procedure} doubly-weak-alist-vector? obj
@deffnx {C Function} scm_weak_key_alist_vector_p (obj)
Return @code{#t} if @var{obj} is the specified weak hash
table. Note that a doubly weak hash table is neither a weak key
nor a weak value hash table.
@end deffn

weak-value-alist-vector?
@c snarfed from weaks.c:187
@deffn {Scheme Procedure} weak-value-alist-vector? obj
@deffnx {C Function} scm_weak_value_alist_vector_p (obj)
Return @code{#t} if @var{obj} is a weak value hash table.
@end deffn

doubly-weak-alist-vector?
@c snarfed from weaks.c:197
@deffn {Scheme Procedure} doubly-weak-alist-vector? obj
@deffnx {C Function} scm_doubly_weak_alist_vector_p (obj)
Return @code{#t} if @var{obj} is a doubly weak hash table.
@end deffn

array-fill!
@c snarfed from ramap.c:352
@deffn {Scheme Procedure} array-fill! ra fill
@deffnx {C Function} scm_array_fill_x (ra, fill)
Store @var{fill} in every element of @var{array}.  The value returned
is unspecified.
@end deffn

array-copy-in-order!
@c snarfed from ramap.c:399
@deffn {Scheme Procedure} array-copy-in-order!
implemented by the C function "scm_array_copy_x"
@end deffn

array-copy!
@c snarfed from ramap.c:408
@deffn {Scheme Procedure} array-copy! src dst
@deffnx {Scheme Procedure} array-copy-in-order! src dst
@deffnx {C Function} scm_array_copy_x (src, dst)
Copy every element from vector or array @var{source} to the
corresponding element of @var{destination}.  @var{destination} must have
the same rank as @var{source}, and be at least as large in each
dimension.  The order is unspecified.
@end deffn

array-map-in-order!
@c snarfed from ramap.c:798
@deffn {Scheme Procedure} array-map-in-order!
implemented by the C function "scm_array_map_x"
@end deffn

array-map!
@c snarfed from ramap.c:809
@deffn {Scheme Procedure} array-map! ra0 proc . lra
@deffnx {Scheme Procedure} array-map-in-order! ra0 proc . lra
@deffnx {C Function} scm_array_map_x (ra0, proc, lra)
@var{array1}, @dots{} must have the same number of dimensions as
@var{array0} and have a range for each index which includes the range
for the corresponding index in @var{array0}.  @var{proc} is applied to
each tuple of elements of @var{array1} @dots{} and the result is stored
as the corresponding element in @var{array0}.  The value returned is
unspecified.  The order of application is unspecified.
@end deffn

array-for-each
@c snarfed from ramap.c:950
@deffn {Scheme Procedure} array-for-each proc ra0 . lra
@deffnx {C Function} scm_array_for_each (proc, ra0, lra)
Apply @var{proc} to each tuple of elements of @var{array0} @dots{}
in row-major order.  The value returned is unspecified.
@end deffn

array-index-map!
@c snarfed from ramap.c:978
@deffn {Scheme Procedure} array-index-map! ra proc
@deffnx {C Function} scm_array_index_map_x (ra, proc)
Apply @var{proc} to the indices of each element of @var{array} in
turn, storing the result in the corresponding element.  The value
returned and the order of application are unspecified.

One can implement @var{array-indexes} as
@lisp
(define (array-indexes array)
    (let ((ra (apply make-array #f (array-shape array))))
      (array-index-map! ra (lambda x x))
      ra))
@end lisp
Another example:
@lisp
(define (apl:index-generator n)
    (let ((v (make-uniform-vector n 1)))
      (array-index-map! v (lambda (i) i))
      v))
@end lisp
@end deffn

array?
@c snarfed from unif.c:501
@deffn {Scheme Procedure} array? obj [prot]
@deffnx {C Function} scm_array_p (obj, prot)
Return @code{#t} if the @var{obj} is an array, and @code{#f} if
not.
@end deffn

typed-array?
@c snarfed from unif.c:548
@deffn {Scheme Procedure} typed-array? obj type
@deffnx {C Function} scm_typed_array_p (obj, type)
Return @code{#t} if the @var{obj} is an array of type
@var{type}, and @code{#f} if not.
@end deffn

array-rank
@c snarfed from unif.c:569
@deffn {Scheme Procedure} array-rank array
@deffnx {C Function} scm_array_rank (array)
Return the number of dimensions of the array @var{array.}

@end deffn

array-dimensions
@c snarfed from unif.c:583
@deffn {Scheme Procedure} array-dimensions ra
@deffnx {C Function} scm_array_dimensions (ra)
@code{array-dimensions} is similar to @code{array-shape} but replaces
elements with a @code{0} minimum with one greater than the maximum. So:
@lisp
(array-dimensions (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) 5)
@end lisp
@end deffn

shared-array-root
@c snarfed from unif.c:611
@deffn {Scheme Procedure} shared-array-root ra
@deffnx {C Function} scm_shared_array_root (ra)
Return the root vector of a shared array.
@end deffn

shared-array-offset
@c snarfed from unif.c:625
@deffn {Scheme Procedure} shared-array-offset ra
@deffnx {C Function} scm_shared_array_offset (ra)
Return the root vector index of the first element in the array.
@end deffn

shared-array-increments
@c snarfed from unif.c:641
@deffn {Scheme Procedure} shared-array-increments ra
@deffnx {C Function} scm_shared_array_increments (ra)
For each dimension, return the distance between elements in the root vector.
@end deffn

make-typed-array
@c snarfed from unif.c:740
@deffn {Scheme Procedure} make-typed-array type fill . bounds
@deffnx {C Function} scm_make_typed_array (type, fill, bounds)
Create and return an array of type @var{type}.
@end deffn

make-array
@c snarfed from unif.c:775
@deffn {Scheme Procedure} make-array fill . bounds
@deffnx {C Function} scm_make_array (fill, bounds)
Create and return an array.
@end deffn

dimensions->uniform-array
@c snarfed from unif.c:790
@deffn {Scheme Procedure} dimensions->uniform-array dims prot [fill]
@deffnx {Scheme Procedure} make-uniform-vector length prototype [fill]
@deffnx {C Function} scm_dimensions_to_uniform_array (dims, prot, fill)
Create and return a uniform array or vector of type
corresponding to @var{prototype} with dimensions @var{dims} or
length @var{length}.  If @var{fill} is supplied, it's used to
fill the array, otherwise @var{prototype} is used.
@end deffn

make-shared-array
@c snarfed from unif.c:843
@deffn {Scheme Procedure} make-shared-array oldra mapfunc . dims
@deffnx {C Function} scm_make_shared_array (oldra, mapfunc, dims)
@code{make-shared-array} can be used to create shared subarrays of other
arrays.  The @var{mapper} is a function that translates coordinates in
the new array into coordinates in the old array.  A @var{mapper} must be
linear, and its range must stay within the bounds of the old array, but
it can be otherwise arbitrary.  A simple example:
@lisp
(define fred (make-array #f 8 8))
(define freds-diagonal
  (make-shared-array fred (lambda (i) (list i i)) 8))
(array-set! freds-diagonal 'foo 3)
(array-ref fred 3 3) @result{} foo
(define freds-center
  (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
(array-ref freds-center 0 0) @result{} foo
@end lisp
@end deffn

transpose-array
@c snarfed from unif.c:961
@deffn {Scheme Procedure} transpose-array ra . args
@deffnx {C Function} scm_transpose_array (ra, args)
Return an array sharing contents with @var{array}, but with
dimensions arranged in a different order.  There must be one
@var{dim} argument for each dimension of @var{array}.
@var{dim0}, @var{dim1}, @dots{} should be integers between 0
and the rank of the array to be returned.  Each integer in that
range must appear at least once in the argument list.

The values of @var{dim0}, @var{dim1}, @dots{} correspond to
dimensions in the array to be returned, their positions in the
argument list to dimensions of @var{array}.  Several @var{dim}s
may have the same value, in which case the returned array will
have smaller rank than @var{array}.

@lisp
(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}
                #2((a 4) (b 5) (c 6))
@end lisp
@end deffn

enclose-array
@c snarfed from unif.c:1059
@deffn {Scheme Procedure} enclose-array ra . axes
@deffnx {C Function} scm_enclose_array (ra, axes)
@var{dim0}, @var{dim1} @dots{} should be nonnegative integers less than
the rank of @var{array}.  @var{enclose-array} returns an array
resembling an array of shared arrays.  The dimensions of each shared
array are the same as the @var{dim}th dimensions of the original array,
the dimensions of the outer array are the same as those of the original
array that did not match a @var{dim}.

An enclosed array is not a general Scheme array.  Its elements may not
be set using @code{array-set!}.  Two references to the same element of
an enclosed array will be @code{equal?} but will not in general be
@code{eq?}.  The value returned by @var{array-prototype} when given an
enclosed array is unspecified.

examples:
@lisp
(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) @result{}
   #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) @result{}
   #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>
@end lisp
@end deffn

array-in-bounds?
@c snarfed from unif.c:1132
@deffn {Scheme Procedure} array-in-bounds? v . args
@deffnx {C Function} scm_array_in_bounds_p (v, args)
Return @code{#t} if its arguments would be acceptable to
@code{array-ref}.
@end deffn

array-ref
@c snarfed from unif.c:1209
@deffn {Scheme Procedure} array-ref v . args
@deffnx {C Function} scm_array_ref (v, args)
Return the element at the @code{(index1, index2)} element in
@var{array}.
@end deffn

array-set!
@c snarfed from unif.c:1226
@deffn {Scheme Procedure} array-set! v obj . args
@deffnx {C Function} scm_array_set_x (v, obj, args)
Set the element at the @code{(index1, index2)} element in @var{array} to
@var{new-value}.  The value returned by array-set! is unspecified.
@end deffn

array-contents
@c snarfed from unif.c:1252
@deffn {Scheme Procedure} array-contents ra [strict]
@deffnx {C Function} scm_array_contents (ra, strict)
If @var{array} may be @dfn{unrolled} into a one dimensional shared array
without changing their order (last subscript changing fastest), then
@code{array-contents} returns that shared array, otherwise it returns
@code{#f}.  All arrays made by @var{make-array} and
@var{make-uniform-array} may be unrolled, some arrays made by
@var{make-shared-array} may not be.

If the optional argument @var{strict} is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
@end deffn

uniform-array-read!
@c snarfed from unif.c:1352
@deffn {Scheme Procedure} uniform-array-read! ura [port_or_fd [start [end]]]
@deffnx {Scheme Procedure} uniform-vector-read! uve [port-or-fdes] [start] [end]
@deffnx {C Function} scm_uniform_array_read_x (ura, port_or_fd, start, end)
Attempt to read all elements of @var{ura}, in lexicographic order, as
binary objects from @var{port-or-fdes}.
If an end of file is encountered,
the objects up to that point are put into @var{ura}
(starting at the beginning) and the remainder of the array is
unchanged.

The optional arguments @var{start} and @var{end} allow
a specified region of a vector (or linearized array) to be read,
leaving the remainder of the vector unchanged.

@code{uniform-array-read!} returns the number of objects read.
@var{port-or-fdes} may be omitted, in which case it defaults to the value
returned by @code{(current-input-port)}.
@end deffn

uniform-array-write
@c snarfed from unif.c:1406
@deffn {Scheme Procedure} uniform-array-write ura [port_or_fd [start [end]]]
@deffnx {C Function} scm_uniform_array_write (ura, port_or_fd, start, end)
Writes all elements of @var{ura} as binary objects to
@var{port-or-fdes}.

The optional arguments @var{start}
and @var{end} allow
a specified region of a vector (or linearized array) to be written.

The number of objects actually written is returned.
@var{port-or-fdes} may be
omitted, in which case it defaults to the value returned by
@code{(current-output-port)}.
@end deffn

bitvector?
@c snarfed from unif.c:1518
@deffn {Scheme Procedure} bitvector? obj
@deffnx {C Function} scm_bitvector_p (obj)
Return @code{#t} when @var{obj} is a bitvector, else
return @code{#f}.
@end deffn

make-bitvector
@c snarfed from unif.c:1545
@deffn {Scheme Procedure} make-bitvector len [fill]
@deffnx {C Function} scm_make_bitvector (len, fill)
Create a new bitvector of length @var{len} and
optionally initialize all elements to @var{fill}.
@end deffn

bitvector
@c snarfed from unif.c:1554
@deffn {Scheme Procedure} bitvector . bits
@deffnx {C Function} scm_bitvector (bits)
Create a new bitvector with the arguments as elements.
@end deffn

bitvector-length
@c snarfed from unif.c:1570
@deffn {Scheme Procedure} bitvector-length vec
@deffnx {C Function} scm_bitvector_length (vec)
Return the length of the bitvector @var{vec}.
@end deffn

bitvector-ref
@c snarfed from unif.c:1661
@deffn {Scheme Procedure} bitvector-ref vec idx
@deffnx {C Function} scm_bitvector_ref (vec, idx)
Return the element at index @var{idx} of the bitvector
@var{vec}.
@end deffn

bitvector-set!
@c snarfed from unif.c:1704
@deffn {Scheme Procedure} bitvector-set! vec idx val
@deffnx {C Function} scm_bitvector_set_x (vec, idx, val)
Set the element at index @var{idx} of the bitvector
@var{vec} when @var{val} is true, else clear it.
@end deffn

bitvector-fill!
@c snarfed from unif.c:1715
@deffn {Scheme Procedure} bitvector-fill! vec val
@deffnx {C Function} scm_bitvector_fill_x (vec, val)
Set all elements of the bitvector
@var{vec} when @var{val} is true, else clear them.
@end deffn

list->bitvector
@c snarfed from unif.c:1760
@deffn {Scheme Procedure} list->bitvector list
@deffnx {C Function} scm_list_to_bitvector (list)
Return a new bitvector initialized with the elements
of @var{list}.
@end deffn

bitvector->list
@c snarfed from unif.c:1790
@deffn {Scheme Procedure} bitvector->list vec
@deffnx {C Function} scm_bitvector_to_list (vec)
Return a new list initialized with the elements
of the bitvector @var{vec}.
@end deffn

bit-count
@c snarfed from unif.c:1854
@deffn {Scheme Procedure} bit-count b bitvector
@deffnx {C Function} scm_bit_count (b, bitvector)
Return the number of occurrences of the boolean @var{b} in
@var{bitvector}.
@end deffn

bit-position
@c snarfed from unif.c:1923
@deffn {Scheme Procedure} bit-position item v k
@deffnx {C Function} scm_bit_position (item, v, k)
Return the index of the first occurrance of @var{item} in bit
vector @var{v}, starting from @var{k}.  If there is no
@var{item} entry between @var{k} and the end of
@var{bitvector}, then return @code{#f}.  For example,

@example
(bit-position #t #*000101 0)  @result{} 3
(bit-position #f #*0001111 3) @result{} #f
@end example
@end deffn

bit-set*!
@c snarfed from unif.c:2006
@deffn {Scheme Procedure} bit-set*! v kv obj
@deffnx {C Function} scm_bit_set_star_x (v, kv, obj)
Set entries of bit vector @var{v} to @var{obj}, with @var{kv}
selecting the entries to change.  The return value is
unspecified.

If @var{kv} is a bit vector, then those entries where it has
@code{#t} are the ones in @var{v} which are set to @var{obj}.
@var{kv} and @var{v} must be the same length.  When @var{obj}
is @code{#t} it's like @var{kv} is OR'ed into @var{v}.  Or when
@var{obj} is @code{#f} it can be seen as an ANDNOT.

@example
(define bv #*01000010)
(bit-set*! bv #*10010001 #t)
bv
@result{} #*11010011
@end example

If @var{kv} is a u32vector, then its elements are
indices into @var{v} which are set to @var{obj}.

@example
(define bv #*01000010)
(bit-set*! bv #u32(5 2 7) #t)
bv
@result{} #*01100111
@end example
@end deffn

bit-count*
@c snarfed from unif.c:2109
@deffn {Scheme Procedure} bit-count* v kv obj
@deffnx {C Function} scm_bit_count_star (v, kv, obj)
Return a count of how many entries in bit vector @var{v} are
equal to @var{obj}, with @var{kv} selecting the entries to
consider.

If @var{kv} is a bit vector, then those entries where it has
@code{#t} are the ones in @var{v} which are considered.
@var{kv} and @var{v} must be the same length.

If @var{kv} is a u32vector, then it contains
the indexes in @var{v} to consider.

For example,

@example
(bit-count* #*01110111 #*11001101 #t) @result{} 3
(bit-count* #*01110111 #u32(7 0 4) #f)  @result{} 2
@end example
@end deffn

bit-invert!
@c snarfed from unif.c:2196
@deffn {Scheme Procedure} bit-invert! v
@deffnx {C Function} scm_bit_invert_x (v)
Modify the bit vector @var{v} by replacing each element with
its negation.
@end deffn

array->list
@c snarfed from unif.c:2303
@deffn {Scheme Procedure} array->list v
@deffnx {C Function} scm_array_to_list (v)
Return a list consisting of all the elements, in order, of
@var{array}.
@end deffn

list->typed-array
@c snarfed from unif.c:2332
@deffn {Scheme Procedure} list->typed-array type shape lst
@deffnx {C Function} scm_list_to_typed_array (type, shape, lst)
Return an array of the type @var{type}
with elements the same as those of @var{lst}.

The argument @var{shape} determines the number of dimensions
of the array and their shape.  It is either an exact integer,
giving the
number of dimensions directly, or a list whose length
specifies the number of dimensions and each element specified
the lower and optionally the upper bound of the corresponding
dimension.
When the element is list of two elements, these elements
give the lower and upper bounds.  When it is an exact
integer, it gives only the lower bound.
@end deffn

list->array
@c snarfed from unif.c:2390
@deffn {Scheme Procedure} list->array ndim lst
@deffnx {C Function} scm_list_to_array (ndim, lst)
Return an array with elements the same as those of @var{lst}.
@end deffn

list->uniform-array
@c snarfed from unif.c:2440
@deffn {Scheme Procedure} list->uniform-array ndim prot lst
@deffnx {C Function} scm_list_to_uniform_array (ndim, prot, lst)
Return a uniform array of the type indicated by prototype
@var{prot} with elements the same as those of @var{lst}.
Elements must be of the appropriate type, no coercions are
done.

The argument @var{ndim} determines the number of dimensions
of the array.  It is either an exact integer, giving the
number directly, or a list of exact integers, whose length
specifies the number of dimensions and each element is the
lower index bound of its dimension.
@end deffn

array-type
@c snarfed from unif.c:2789
@deffn {Scheme Procedure} array-type ra
@deffnx {C Function} scm_array_type (ra)

@end deffn

array-prototype
@c snarfed from unif.c:2809
@deffn {Scheme Procedure} array-prototype ra
@deffnx {C Function} scm_array_prototype (ra)
Return an object that would produce an array of the same type
as @var{array}, if used as the @var{prototype} for
@code{make-uniform-array}.
@end deffn

dynamic-link
@c snarfed from dynl.c:149
@deffn {Scheme Procedure} dynamic-link filename
@deffnx {C Function} scm_dynamic_link (filename)
Find the shared object (shared library) denoted by
@var{filename} and link it into the running Guile
application.  The returned
scheme object is a ``handle'' for the library which can
be passed to @code{dynamic-func}, @code{dynamic-call} etc.

Searching for object files is system dependent.  Normally,
if @var{filename} does have an explicit directory it will
be searched for in locations
such as @file{/usr/lib} and @file{/usr/local/lib}.
@end deffn

dynamic-object?
@c snarfed from dynl.c:168
@deffn {Scheme Procedure} dynamic-object? obj
@deffnx {C Function} scm_dynamic_object_p (obj)
Return @code{#t} if @var{obj} is a dynamic object handle,
or @code{#f} otherwise.
@end deffn

dynamic-unlink
@c snarfed from dynl.c:182
@deffn {Scheme Procedure} dynamic-unlink dobj
@deffnx {C Function} scm_dynamic_unlink (dobj)
Unlink a dynamic object from the application, if possible.  The
object must have been linked by @code{dynamic-link}, with 
@var{dobj} the corresponding handle.  After this procedure
is called, the handle can no longer be used to access the
object.
@end deffn

dynamic-func
@c snarfed from dynl.c:207
@deffn {Scheme Procedure} dynamic-func name dobj
@deffnx {C Function} scm_dynamic_func (name, dobj)
Return a ``handle'' for the function @var{name} in the
shared object referred to by @var{dobj}.  The handle
can be passed to @code{dynamic-call} to actually
call the function.

Regardless whether your C compiler prepends an underscore
@samp{_} to the global names in a program, you should
@strong{not} include this underscore in @var{name}
since it will be added automatically when necessary.
@end deffn

dynamic-call
@c snarfed from dynl.c:253
@deffn {Scheme Procedure} dynamic-call func dobj
@deffnx {C Function} scm_dynamic_call (func, dobj)
Call a C function in a dynamic object.  Two styles of
invocation are supported:

@itemize @bullet
@item @var{func} can be a function handle returned by
@code{dynamic-func}.  In this case @var{dobj} is
ignored
@item @var{func} can be a string with the name of the
function to call, with @var{dobj} the handle of the
dynamic object in which to find the function.
This is equivalent to
@smallexample

(dynamic-call (dynamic-func @var{func} @var{dobj}) #f)
@end smallexample
@end itemize

In either case, the function is passed no arguments
and its return value is ignored.
@end deffn

dynamic-args-call
@c snarfed from dynl.c:285
@deffn {Scheme Procedure} dynamic-args-call func dobj args
@deffnx {C Function} scm_dynamic_args_call (func, dobj, args)
Call the C function indicated by @var{func} and @var{dobj},
just like @code{dynamic-call}, but pass it some arguments and
return its return value.  The C function is expected to take
two arguments and return an @code{int}, just like @code{main}:
@smallexample
int c_func (int argc, char **argv);
@end smallexample

The parameter @var{args} must be a list of strings and is
converted into an array of @code{char *}.  The array is passed
in @var{argv} and its size in @var{argc}.  The return value is
converted to a Scheme number and returned from the call to
@code{dynamic-args-call}.
@end deffn

chown
@c snarfed from filesys.c:224
@deffn {Scheme Procedure} chown object owner group
@deffnx {C Function} scm_chown (object, owner, group)
Change the ownership and group of the file referred to by @var{object} to
the integer values @var{owner} and @var{group}.  @var{object} can be
a string containing a file name or, if the platform
supports fchown, a port or integer file descriptor
which is open on the file.  The return value
is unspecified.

If @var{object} is a symbolic link, either the
ownership of the link or the ownership of the referenced file will be
changed depending on the operating system (lchown is
unsupported at present).  If @var{owner} or @var{group} is specified
as @code{-1}, then that ID is not changed.
@end deffn

chmod
@c snarfed from filesys.c:262
@deffn {Scheme Procedure} chmod object mode
@deffnx {C Function} scm_chmod (object, mode)
Changes the permissions of the file referred to by @var{obj}.
@var{obj} can be a string containing a file name or a port or integer file
descriptor which is open on a file (in which case @code{fchmod} is used
as the underlying system call).
@var{mode} specifies
the new permissions as a decimal number, e.g., @code{(chmod "foo" #o755)}.
The return value is unspecified.
@end deffn

umask
@c snarfed from filesys.c:294
@deffn {Scheme Procedure} umask [mode]
@deffnx {C Function} scm_umask (mode)
If @var{mode} is omitted, returns a decimal number representing the current
file creation mask.  Otherwise the file creation mask is set to
@var{mode} and the previous value is returned.

E.g., @code{(umask #o022)} sets the mask to octal 22, decimal 18.
@end deffn

open-fdes
@c snarfed from filesys.c:316
@deffn {Scheme Procedure} open-fdes path flags [mode]
@deffnx {C Function} scm_open_fdes (path, flags, mode)
Similar to @code{open} but return a file descriptor instead of
a port.
@end deffn

open
@c snarfed from filesys.c:357
@deffn {Scheme Procedure} open path flags [mode]
@deffnx {C Function} scm_open (path, flags, mode)
Open the file named by @var{path} for reading and/or writing.
@var{flags} is an integer specifying how the file should be opened.
@var{mode} is an integer specifying the permission bits of the file, if
it needs to be created, before the umask is applied.  The default is 666
(Unix itself has no default).

@var{flags} can be constructed by combining variables using @code{logior}.
Basic flags are:

@defvar O_RDONLY
Open the file read-only.
@end defvar
@defvar O_WRONLY
Open the file write-only.
@end defvar
@defvar O_RDWR
Open the file read/write.
@end defvar
@defvar O_APPEND
Append to the file instead of truncating.
@end defvar
@defvar O_CREAT
Create the file if it does not already exist.
@end defvar

See the Unix documentation of the @code{open} system call
for additional flags.
@end deffn

close
@c snarfed from filesys.c:395
@deffn {Scheme Procedure} close fd_or_port
@deffnx {C Function} scm_close (fd_or_port)
Similar to close-port (@pxref{Closing, close-port}),
but also works on file descriptors.  A side
effect of closing a file descriptor is that any ports using that file
descriptor are moved to a different file descriptor and have
their revealed counts set to zero.
@end deffn

close-fdes
@c snarfed from filesys.c:422
@deffn {Scheme Procedure} close-fdes fd
@deffnx {C Function} scm_close_fdes (fd)
A simple wrapper for the @code{close} system call.
Close file descriptor @var{fd}, which must be an integer.
Unlike close (@pxref{Ports and File Descriptors, close}),
the file descriptor will be closed even if a port is using it.
The return value is unspecified.
@end deffn

stat
@c snarfed from filesys.c:624
@deffn {Scheme Procedure} stat object
@deffnx {C Function} scm_stat (object)
Return an object containing various information about the file
determined by @var{obj}.  @var{obj} can be a string containing
a file name or a port or integer file descriptor which is open
on a file (in which case @code{fstat} is used as the underlying
system call).

The object returned by @code{stat} can be passed as a single
parameter to the following procedures, all of which return
integers:

@table @code
@item stat:dev
The device containing the file.
@item stat:ino
The file serial number, which distinguishes this file from all
other files on the same device.
@item stat:mode
The mode of the file.  This includes file type information and
the file permission bits.  See @code{stat:type} and
@code{stat:perms} below.
@item stat:nlink
The number of hard links to the file.
@item stat:uid
The user ID of the file's owner.
@item stat:gid
The group ID of the file.
@item stat:rdev
Device ID; this entry is defined only for character or block
special files.
@item stat:size
The size of a regular file in bytes.
@item stat:atime
The last access time for the file.
@item stat:mtime
The last modification time for the file.
@item stat:ctime
The last modification time for the attributes of the file.
@item stat:blksize
The optimal block size for reading or writing the file, in
bytes.
@item stat:blocks
The amount of disk space that the file occupies measured in
units of 512 byte blocks.
@end table

In addition, the following procedures return the information
from stat:mode in a more convenient form:

@table @code
@item stat:type
A symbol representing the type of file.  Possible values are
regular, directory, symlink, block-special, char-special, fifo,
socket and unknown
@item stat:perms
An integer representing the access permission bits.
@end table
@end deffn

link
@c snarfed from filesys.c:686
@deffn {Scheme Procedure} link oldpath newpath
@deffnx {C Function} scm_link (oldpath, newpath)
Creates a new name @var{newpath} in the file system for the
file named by @var{oldpath}.  If @var{oldpath} is a symbolic
link, the link may or may not be followed depending on the
system.
@end deffn

rename-file
@c snarfed from filesys.c:724
@deffn {Scheme Procedure} rename-file oldname newname
@deffnx {C Function} scm_rename (oldname, newname)
Renames the file specified by @var{oldname} to @var{newname}.
The return value is unspecified.
@end deffn

delete-file
@c snarfed from filesys.c:741
@deffn {Scheme Procedure} delete-file str
@deffnx {C Function} scm_delete_file (str)
Deletes (or "unlinks") the file specified by @var{path}.
@end deffn

mkdir
@c snarfed from filesys.c:758
@deffn {Scheme Procedure} mkdir path [mode]
@deffnx {C Function} scm_mkdir (path, mode)
Create a new directory named by @var{path}.  If @var{mode} is omitted
then the permissions of the directory file are set using the current
umask.  Otherwise they are set to the decimal value specified with
@var{mode}.  The return value is unspecified.
@end deffn

rmdir
@c snarfed from filesys.c:785
@deffn {Scheme Procedure} rmdir path
@deffnx {C Function} scm_rmdir (path)
Remove the existing directory named by @var{path}.  The directory must
be empty for this to succeed.  The return value is unspecified.
@end deffn

directory-stream?
@c snarfed from filesys.c:809
@deffn {Scheme Procedure} directory-stream? obj
@deffnx {C Function} scm_directory_stream_p (obj)
Return a boolean indicating whether @var{object} is a directory
stream as returned by @code{opendir}.
@end deffn

opendir
@c snarfed from filesys.c:820
@deffn {Scheme Procedure} opendir dirname
@deffnx {C Function} scm_opendir (dirname)
Open the directory specified by @var{path} and return a directory
stream.
@end deffn

readdir
@c snarfed from filesys.c:841
@deffn {Scheme Procedure} readdir port
@deffnx {C Function} scm_readdir (port)
Return (as a string) the next directory entry from the directory stream
@var{stream}.  If there is no remaining entry to be read then the
end of file object is returned.
@end deffn

rewinddir
@c snarfed from filesys.c:880
@deffn {Scheme Procedure} rewinddir port
@deffnx {C Function} scm_rewinddir (port)
Reset the directory port @var{stream} so that the next call to
@code{readdir} will return the first directory entry.
@end deffn

closedir
@c snarfed from filesys.c:897
@deffn {Scheme Procedure} closedir port
@deffnx {C Function} scm_closedir (port)
Close the directory stream @var{stream}.
The return value is unspecified.
@end deffn

chdir
@c snarfed from filesys.c:947
@deffn {Scheme Procedure} chdir str
@deffnx {C Function} scm_chdir (str)
Change the current working directory to @var{path}.
The return value is unspecified.
@end deffn

getcwd
@c snarfed from filesys.c:962
@deffn {Scheme Procedure} getcwd
@deffnx {C Function} scm_getcwd ()
Return the name of the current working directory.
@end deffn

select
@c snarfed from filesys.c:1164
@deffn {Scheme Procedure} select reads writes excepts [secs [usecs]]
@deffnx {C Function} scm_select (reads, writes, excepts, secs, usecs)
This procedure has a variety of uses: waiting for the ability
to provide input, accept output, or the existence of
exceptional conditions on a collection of ports or file
descriptors, or waiting for a timeout to occur.
It also returns if interrupted by a signal.

@var{reads}, @var{writes} and @var{excepts} can be lists or
vectors, with each member a port or a file descriptor.
The value returned is a list of three corresponding
lists or vectors containing only the members which meet the
specified requirement.  The ability of port buffers to
provide input or accept output is taken into account.
Ordering of the input lists or vectors is not preserved.

The optional arguments @var{secs} and @var{usecs} specify the
timeout.  Either @var{secs} can be specified alone, as
either an integer or a real number, or both @var{secs} and
@var{usecs} can be specified as integers, in which case
@var{usecs} is an additional timeout expressed in
microseconds.  If @var{secs} is omitted or is @code{#f} then
select will wait for as long as it takes for one of the other
conditions to be satisfied.

The scsh version of @code{select} differs as follows:
Only vectors are accepted for the first three arguments.
The @var{usecs} argument is not supported.
Multiple values are returned instead of a list.
Duplicates in the input vectors appear only once in output.
An additional @code{select!} interface is provided.
@end deffn

fcntl
@c snarfed from filesys.c:1302
@deffn {Scheme Procedure} fcntl object cmd [value]
@deffnx {C Function} scm_fcntl (object, cmd, value)
Apply @var{command} to the specified file descriptor or the underlying
file descriptor of the specified port.  @var{value} is an optional
integer argument.

Values for @var{command} are:

@table @code
@item F_DUPFD
Duplicate a file descriptor
@item F_GETFD
Get flags associated with the file descriptor.
@item F_SETFD
Set flags associated with the file descriptor to @var{value}.
@item F_GETFL
Get flags associated with the open file.
@item F_SETFL
Set flags associated with the open file to @var{value}
@item F_GETOWN
Get the process ID of a socket's owner, for @code{SIGIO} signals.
@item F_SETOWN
Set the process that owns a socket to @var{value}, for @code{SIGIO} signals.
@item FD_CLOEXEC
The value used to indicate the "close on exec" flag with @code{F_GETFL} or
@code{F_SETFL}.
@end table
@end deffn

fsync
@c snarfed from filesys.c:1334
@deffn {Scheme Procedure} fsync object
@deffnx {C Function} scm_fsync (object)
Copies any unwritten data for the specified output file descriptor to disk.
If @var{port/fd} is a port, its buffer is flushed before the underlying
file descriptor is fsync'd.
The return value is unspecified.
@end deffn

symlink
@c snarfed from filesys.c:1359
@deffn {Scheme Procedure} symlink oldpath newpath
@deffnx {C Function} scm_symlink (oldpath, newpath)
Create a symbolic link named @var{path-to} with the value (i.e., pointing to)
@var{path-from}.  The return value is unspecified.
@end deffn

readlink
@c snarfed from filesys.c:1378
@deffn {Scheme Procedure} readlink path
@deffnx {C Function} scm_readlink (path)
Return the value of the symbolic link named by @var{path} (a
string), i.e., the file that the link points to.
@end deffn

lstat
@c snarfed from filesys.c:1420
@deffn {Scheme Procedure} lstat str
@deffnx {C Function} scm_lstat (str)
Similar to @code{stat}, but does not follow symbolic links, i.e.,
it will return information about a symbolic link itself, not the
file it points to.  @var{path} must be a string.
@end deffn

copy-file
@c snarfed from filesys.c:1443
@deffn {Scheme Procedure} copy-file oldfile newfile
@deffnx {C Function} scm_copy_file (oldfile, newfile)
Copy the file specified by @var{path-from} to @var{path-to}.
The return value is unspecified.
@end deffn

dirname
@c snarfed from filesys.c:1506
@deffn {Scheme Procedure} dirname filename
@deffnx {C Function} scm_dirname (filename)
Return the directory name component of the file name
@var{filename}. If @var{filename} does not contain a directory
component, @code{.} is returned.
@end deffn

basename
@c snarfed from filesys.c:1549
@deffn {Scheme Procedure} basename filename [suffix]
@deffnx {C Function} scm_basename (filename, suffix)
Return the base name of the file name @var{filename}. The
base name is the file name without any directory components.
If @var{suffix} is provided, and is equal to the end of
@var{basename}, it is removed also.
@end deffn

pipe
@c snarfed from posix.c:233
@deffn {Scheme Procedure} pipe
@deffnx {C Function} scm_pipe ()
Return a newly created pipe: a pair of ports which are linked
together on the local machine.  The @emph{car} is the input
port and the @emph{cdr} is the output port.  Data written (and
flushed) to the output port can be read from the input port.
Pipes are commonly used for communication with a newly forked
child process.  The need to flush the output port can be
avoided by making it unbuffered using @code{setvbuf}.

Writes occur atomically provided the size of the data in bytes
is not greater than the value of @code{PIPE_BUF}.  Note that
the output port is likely to block if too much data (typically
equal to @code{PIPE_BUF}) has been written but not yet read
from the input port.
@end deffn

getgroups
@c snarfed from posix.c:254
@deffn {Scheme Procedure} getgroups
@deffnx {C Function} scm_getgroups ()
Return a vector of integers representing the current
supplementary group IDs.
@end deffn

setgroups
@c snarfed from posix.c:287
@deffn {Scheme Procedure} setgroups group_vec
@deffnx {C Function} scm_setgroups (group_vec)
Set the current set of supplementary group IDs to the integers
in the given vector @var{vec}.  The return value is
unspecified.

Generally only the superuser can set the process group IDs.
@end deffn

getpw
@c snarfed from posix.c:336
@deffn {Scheme Procedure} getpw [user]
@deffnx {C Function} scm_getpwuid (user)
Look up an entry in the user database.  @var{obj} can be an integer,
a string, or omitted, giving the behaviour of getpwuid, getpwnam
or getpwent respectively.
@end deffn

setpw
@c snarfed from posix.c:386
@deffn {Scheme Procedure} setpw [arg]
@deffnx {C Function} scm_setpwent (arg)
If called with a true argument, initialize or reset the password data
stream.  Otherwise, close the stream.  The @code{setpwent} and
@code{endpwent} procedures are implemented on top of this.
@end deffn

getgr
@c snarfed from posix.c:405
@deffn {Scheme Procedure} getgr [name]
@deffnx {C Function} scm_getgrgid (name)
Look up an entry in the group database.  @var{obj} can be an integer,
a string, or omitted, giving the behaviour of getgrgid, getgrnam
or getgrent respectively.
@end deffn

setgr
@c snarfed from posix.c:441
@deffn {Scheme Procedure} setgr [arg]
@deffnx {C Function} scm_setgrent (arg)
If called with a true argument, initialize or reset the group data
stream.  Otherwise, close the stream.  The @code{setgrent} and
@code{endgrent} procedures are implemented on top of this.
@end deffn

kill
@c snarfed from posix.c:477
@deffn {Scheme Procedure} kill pid sig
@deffnx {C Function} scm_kill (pid, sig)
Sends a signal to the specified process or group of processes.

@var{pid} specifies the processes to which the signal is sent:

@table @r
@item @var{pid} greater than 0
The process whose identifier is @var{pid}.
@item @var{pid} equal to 0
All processes in the current process group.
@item @var{pid} less than -1
The process group whose identifier is -@var{pid}
@item @var{pid} equal to -1
If the process is privileged, all processes except for some special
system processes.  Otherwise, all processes with the current effective
user ID.
@end table

@var{sig} should be specified using a variable corresponding to
the Unix symbolic name, e.g.,

@defvar SIGHUP
Hang-up signal.
@end defvar

@defvar SIGINT
Interrupt signal.
@end defvar
@end deffn

waitpid
@c snarfed from posix.c:528
@deffn {Scheme Procedure} waitpid pid [options]
@deffnx {C Function} scm_waitpid (pid, options)
This procedure collects status information from a child process which
has terminated or (optionally) stopped.  Normally it will
suspend the calling process until this can be done.  If more than one
child process is eligible then one will be chosen by the operating system.

The value of @var{pid} determines the behaviour:

@table @r
@item @var{pid} greater than 0
Request status information from the specified child process.
@item @var{pid} equal to -1 or WAIT_ANY
Request status information for any child process.
@item @var{pid} equal to 0 or WAIT_MYPGRP
Request status information for any child process in the current process
group.
@item @var{pid} less than -1
Request status information for any child process whose process group ID
is -@var{PID}.
@end table

The @var{options} argument, if supplied, should be the bitwise OR of the
values of zero or more of the following variables:

@defvar WNOHANG
Return immediately even if there are no child processes to be collected.
@end defvar

@defvar WUNTRACED
Report status information for stopped processes as well as terminated
processes.
@end defvar

The return value is a pair containing:

@enumerate
@item
The process ID of the child process, or 0 if @code{WNOHANG} was
specified and no process was collected.
@item
The integer status value.
@end enumerate
@end deffn

status:exit-val
@c snarfed from posix.c:554
@deffn {Scheme Procedure} status:exit-val status
@deffnx {C Function} scm_status_exit_val (status)
Return the exit status value, as would be set if a process
ended normally through a call to @code{exit} or @code{_exit},
if any, otherwise @code{#f}.
@end deffn

status:term-sig
@c snarfed from posix.c:572
@deffn {Scheme Procedure} status:term-sig status
@deffnx {C Function} scm_status_term_sig (status)
Return the signal number which terminated the process, if any,
otherwise @code{#f}.
@end deffn

status:stop-sig
@c snarfed from posix.c:588
@deffn {Scheme Procedure} status:stop-sig status
@deffnx {C Function} scm_status_stop_sig (status)
Return the signal number which stopped the process, if any,
otherwise @code{#f}.
@end deffn

getppid
@c snarfed from posix.c:606
@deffn {Scheme Procedure} getppid
@deffnx {C Function} scm_getppid ()
Return an integer representing the process ID of the parent
process.
@end deffn

getuid
@c snarfed from posix.c:618
@deffn {Scheme Procedure} getuid
@deffnx {C Function} scm_getuid ()
Return an integer representing the current real user ID.
@end deffn

getgid
@c snarfed from posix.c:629
@deffn {Scheme Procedure} getgid
@deffnx {C Function} scm_getgid ()
Return an integer representing the current real group ID.
@end deffn

geteuid
@c snarfed from posix.c:643
@deffn {Scheme Procedure} geteuid
@deffnx {C Function} scm_geteuid ()
Return an integer representing the current effective user ID.
If the system does not support effective IDs, then the real ID
is returned.  @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
@end deffn

getegid
@c snarfed from posix.c:660
@deffn {Scheme Procedure} getegid
@deffnx {C Function} scm_getegid ()
Return an integer representing the current effective group ID.
If the system does not support effective IDs, then the real ID
is returned.  @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
@end deffn

setuid
@c snarfed from posix.c:676
@deffn {Scheme Procedure} setuid id
@deffnx {C Function} scm_setuid (id)
Sets both the real and effective user IDs to the integer @var{id}, provided
the process has appropriate privileges.
The return value is unspecified.
@end deffn

setgid
@c snarfed from posix.c:689
@deffn {Scheme Procedure} setgid id
@deffnx {C Function} scm_setgid (id)
Sets both the real and effective group IDs to the integer @var{id}, provided
the process has appropriate privileges.
The return value is unspecified.
@end deffn

seteuid
@c snarfed from posix.c:704
@deffn {Scheme Procedure} seteuid id
@deffnx {C Function} scm_seteuid (id)
Sets the effective user ID to the integer @var{id}, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead -- @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
The return value is unspecified.
@end deffn

setegid
@c snarfed from posix.c:729
@deffn {Scheme Procedure} setegid id
@deffnx {C Function} scm_setegid (id)
Sets the effective group ID to the integer @var{id}, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead -- @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
The return value is unspecified.
@end deffn

getpgrp
@c snarfed from posix.c:752
@deffn {Scheme Procedure} getpgrp
@deffnx {C Function} scm_getpgrp ()
Return an integer representing the current process group ID.
This is the POSIX definition, not BSD.
@end deffn

setpgid
@c snarfed from posix.c:770
@deffn {Scheme Procedure} setpgid pid pgid
@deffnx {C Function} scm_setpgid (pid, pgid)
Move the process @var{pid} into the process group @var{pgid}.  @var{pid} or
@var{pgid} must be integers: they can be zero to indicate the ID of the
current process.
Fails on systems that do not support job control.
The return value is unspecified.
@end deffn

setsid
@c snarfed from posix.c:787
@deffn {Scheme Procedure} setsid
@deffnx {C Function} scm_setsid ()
Creates a new session.  The current process becomes the session leader
and is put in a new process group.  The process will be detached
from its controlling terminal if it has one.
The return value is an integer representing the new process group ID.
@end deffn

ttyname
@c snarfed from posix.c:811
@deffn {Scheme Procedure} ttyname port
@deffnx {C Function} scm_ttyname (port)
Return a string with the name of the serial terminal device
underlying @var{port}.
@end deffn

ctermid
@c snarfed from posix.c:850
@deffn {Scheme Procedure} ctermid
@deffnx {C Function} scm_ctermid ()
Return a string containing the file name of the controlling
terminal for the current process.
@end deffn

tcgetpgrp
@c snarfed from posix.c:874
@deffn {Scheme Procedure} tcgetpgrp port
@deffnx {C Function} scm_tcgetpgrp (port)
Return the process group ID of the foreground process group
associated with the terminal open on the file descriptor
underlying @var{port}.

If there is no foreground process group, the return value is a
number greater than 1 that does not match the process group ID
of any existing process group.  This can happen if all of the
processes in the job that was formerly the foreground job have
terminated, and no other job has yet been moved into the
foreground.
@end deffn

tcsetpgrp
@c snarfed from posix.c:898
@deffn {Scheme Procedure} tcsetpgrp port pgid
@deffnx {C Function} scm_tcsetpgrp (port, pgid)
Set the foreground process group ID for the terminal used by the file
descriptor underlying @var{port} to the integer @var{pgid}.
The calling process
must be a member of the same session as @var{pgid} and must have the same
controlling terminal.  The return value is unspecified.
@end deffn

execl
@c snarfed from posix.c:930
@deffn {Scheme Procedure} execl filename . args
@deffnx {C Function} scm_execl (filename, args)
Executes the file named by @var{path} as a new process image.
The remaining arguments are supplied to the process; from a C program
they are accessible as the @code{argv} argument to @code{main}.
Conventionally the first @var{arg} is the same as @var{path}.
All arguments must be strings.

If @var{arg} is missing, @var{path} is executed with a null
argument list, which may have system-dependent side-effects.

This procedure is currently implemented using the @code{execv} system
call, but we call it @code{execl} because of its Scheme calling interface.
@end deffn

execlp
@c snarfed from posix.c:961
@deffn {Scheme Procedure} execlp filename . args
@deffnx {C Function} scm_execlp (filename, args)
Similar to @code{execl}, however if
@var{filename} does not contain a slash
then the file to execute will be located by searching the
directories listed in the @code{PATH} environment variable.

This procedure is currently implemented using the @code{execvp} system
call, but we call it @code{execlp} because of its Scheme calling interface.
@end deffn

execle
@c snarfed from posix.c:995
@deffn {Scheme Procedure} execle filename env . args
@deffnx {C Function} scm_execle (filename, env, args)
Similar to @code{execl}, but the environment of the new process is
specified by @var{env}, which must be a list of strings as returned by the
@code{environ} procedure.

This procedure is currently implemented using the @code{execve} system
call, but we call it @code{execle} because of its Scheme calling interface.
@end deffn

primitive-fork
@c snarfed from posix.c:1031
@deffn {Scheme Procedure} primitive-fork
@deffnx {C Function} scm_fork ()
Creates a new "child" process by duplicating the current "parent" process.
In the child the return value is 0.  In the parent the return value is
the integer process ID of the child.

This procedure has been renamed from @code{fork} to avoid a naming conflict
with the scsh fork.
@end deffn

uname
@c snarfed from posix.c:1051
@deffn {Scheme Procedure} uname
@deffnx {C Function} scm_uname ()
Return an object with some information about the computer
system the program is running on.
@end deffn

environ
@c snarfed from posix.c:1080
@deffn {Scheme Procedure} environ [env]
@deffnx {C Function} scm_environ (env)
If @var{env} is omitted, return the current environment (in the
Unix sense) as a list of strings.  Otherwise set the current
environment, which is also the default environment for child
processes, to the supplied list of strings.  Each member of
@var{env} should be of the form @code{NAME=VALUE} and values of
@code{NAME} should not be duplicated.  If @var{env} is supplied
then the return value is unspecified.
@end deffn

tmpnam
@c snarfed from posix.c:1113
@deffn {Scheme Procedure} tmpnam
@deffnx {C Function} scm_tmpnam ()
Return a name in the file system that does not match any
existing file.  However there is no guarantee that another
process will not create the file after @code{tmpnam} is called.
Care should be taken if opening the file, e.g., use the
@code{O_EXCL} open flag or use @code{mkstemp!} instead.
@end deffn

mkstemp!
@c snarfed from posix.c:1144
@deffn {Scheme Procedure} mkstemp! tmpl
@deffnx {C Function} scm_mkstemp (tmpl)
Create a new unique file in the file system and returns a new
buffered port open for reading and writing to the file.

@var{tmpl} is a string specifying where the file should be
created: it must end with @samp{XXXXXX} and will be changed in
place to return the name of the temporary file.

The file is created with mode @code{0600}, which means read and
write for the owner only.  @code{chmod} can be used to change
this.
@end deffn

utime
@c snarfed from posix.c:1179
@deffn {Scheme Procedure} utime pathname [actime [modtime]]
@deffnx {C Function} scm_utime (pathname, actime, modtime)
@code{utime} sets the access and modification times for the
file named by @var{path}.  If @var{actime} or @var{modtime} is
not supplied, then the current time is used.  @var{actime} and
@var{modtime} must be integer time values as returned by the
@code{current-time} procedure.
@lisp
(utime "foo" (- (current-time) 3600))
@end lisp
will set the access time to one hour in the past and the
modification time to the current time.
@end deffn

access?
@c snarfed from posix.c:1244
@deffn {Scheme Procedure} access? path how
@deffnx {C Function} scm_access (path, how)
Test accessibility of a file under the real UID and GID of the
calling process.  The return is @code{#t} if @var{path} exists
and the permissions requested by @var{how} are all allowed, or
@code{#f} if not.

@var{how} is an integer which is one of the following values,
or a bitwise-OR (@code{logior}) of multiple values.

@defvar R_OK
Test for read permission.
@end defvar
@defvar W_OK
Test for write permission.
@end defvar
@defvar X_OK
Test for execute permission.
@end defvar
@defvar F_OK
Test for existence of the file.  This is implied by each of the
other tests, so there's no need to combine it with them.
@end defvar

It's important to note that @code{access?} does not simply
indicate what will happen on attempting to read or write a
file.  In normal circumstances it does, but in a set-UID or
set-GID program it doesn't because @code{access?} tests the
real ID, whereas an open or execute attempt uses the effective
ID.

A program which will never run set-UID/GID can ignore the
difference between real and effective IDs, but for maximum
generality, especially in library functions, it's best not to
use @code{access?} to predict the result of an open or execute,
instead simply attempt that and catch any exception.

The main use for @code{access?} is to let a set-UID/GID program
determine what the invoking user would have been allowed to do,
without the greater (or perhaps lesser) privileges afforded by
the effective ID.  For more on this, see ``Testing File
Access'' in The GNU C Library Reference Manual.
@end deffn

getpid
@c snarfed from posix.c:1257
@deffn {Scheme Procedure} getpid
@deffnx {C Function} scm_getpid ()
Return an integer representing the current process ID.
@end deffn

putenv
@c snarfed from posix.c:1274
@deffn {Scheme Procedure} putenv str
@deffnx {C Function} scm_putenv (str)
Modifies the environment of the current process, which is
also the default environment inherited by child processes.

If @var{string} is of the form @code{NAME=VALUE} then it will be written
directly into the environment, replacing any existing environment string
with
name matching @code{NAME}.  If @var{string} does not contain an equal
sign, then any existing string with name matching @var{string} will
be removed.

The return value is unspecified.
@end deffn

setlocale
@c snarfed from posix.c:1358
@deffn {Scheme Procedure} setlocale category [locale]
@deffnx {C Function} scm_setlocale (category, locale)
If @var{locale} is omitted, return the current value of the
specified locale category as a system-dependent string.
@var{category} should be specified using the values
@code{LC_COLLATE}, @code{LC_ALL} etc.

Otherwise the specified locale category is set to the string
@var{locale} and the new value is returned as a
system-dependent string.  If @var{locale} is an empty string,
the locale will be set using environment variables.
@end deffn

mknod
@c snarfed from posix.c:1407
@deffn {Scheme Procedure} mknod path type perms dev
@deffnx {C Function} scm_mknod (path, type, perms, dev)
Creates a new special file, such as a file corresponding to a device.
@var{path} specifies the name of the file.  @var{type} should
be one of the following symbols:
regular, directory, symlink, block-special, char-special,
fifo, or socket.  @var{perms} (an integer) specifies the file permissions.
@var{dev} (an integer) specifies which device the special file refers
to.  Its exact interpretation depends on the kind of special file
being created.

E.g.,
@lisp
(mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))
@end lisp

The return value is unspecified.
@end deffn

nice
@c snarfed from posix.c:1453
@deffn {Scheme Procedure} nice incr
@deffnx {C Function} scm_nice (incr)
Increment the priority of the current process by @var{incr}.  A higher
priority value means that the process runs less often.
The return value is unspecified.
@end deffn

sync
@c snarfed from posix.c:1471
@deffn {Scheme Procedure} sync
@deffnx {C Function} scm_sync ()
Flush the operating system disk buffers.
The return value is unspecified.
@end deffn

crypt
@c snarfed from posix.c:1502
@deffn {Scheme Procedure} crypt key salt
@deffnx {C Function} scm_crypt (key, salt)
Encrypt @var{key} using @var{salt} as the salt value to the
crypt(3) library call.
@end deffn

chroot
@c snarfed from posix.c:1531
@deffn {Scheme Procedure} chroot path
@deffnx {C Function} scm_chroot (path)
Change the root directory to that specified in @var{path}.
This directory will be used for path names beginning with
@file{/}.  The root directory is inherited by all children
of the current process.  Only the superuser may change the
root directory.
@end deffn

getlogin
@c snarfed from posix.c:1565
@deffn {Scheme Procedure} getlogin
@deffnx {C Function} scm_getlogin ()
Return a string containing the name of the user logged in on
the controlling terminal of the process, or @code{#f} if this
information cannot be obtained.
@end deffn

cuserid
@c snarfed from posix.c:1583
@deffn {Scheme Procedure} cuserid
@deffnx {C Function} scm_cuserid ()
Return a string containing a user name associated with the
effective user id of the process.  Return @code{#f} if this
information cannot be obtained.
@end deffn

getpriority
@c snarfed from posix.c:1609
@deffn {Scheme Procedure} getpriority which who
@deffnx {C Function} scm_getpriority (which, who)
Return the scheduling priority of the process, process group
or user, as indicated by @var{which} and @var{who}. @var{which}
is one of the variables @code{PRIO_PROCESS}, @code{PRIO_PGRP}
or @code{PRIO_USER}, and @var{who} is interpreted relative to
@var{which} (a process identifier for @code{PRIO_PROCESS},
process group identifier for @code{PRIO_PGRP}, and a user
identifier for @code{PRIO_USER}.  A zero value of @var{who}
denotes the current process, process group, or user.  Return
the highest priority (lowest numerical value) of any of the
specified processes.
@end deffn

setpriority
@c snarfed from posix.c:1643
@deffn {Scheme Procedure} setpriority which who prio
@deffnx {C Function} scm_setpriority (which, who, prio)
Set the scheduling priority of the process, process group
or user, as indicated by @var{which} and @var{who}. @var{which}
is one of the variables @code{PRIO_PROCESS}, @code{PRIO_PGRP}
or @code{PRIO_USER}, and @var{who} is interpreted relative to
@var{which} (a process identifier for @code{PRIO_PROCESS},
process group identifier for @code{PRIO_PGRP}, and a user
identifier for @code{PRIO_USER}.  A zero value of @var{who}
denotes the current process, process group, or user.
@var{prio} is a value in the range -20 and 20, the default
priority is 0; lower priorities cause more favorable
scheduling.  Sets the priority of all of the specified
processes.  Only the super-user may lower priorities.
The return value is not specified.
@end deffn

getpass
@c snarfed from posix.c:1668
@deffn {Scheme Procedure} getpass prompt
@deffnx {C Function} scm_getpass (prompt)
Display @var{prompt} to the standard error output and read
a password from @file{/dev/tty}.  If this file is not
accessible, it reads from standard input.  The password may be
up to 127 characters in length.  Additional characters and the
terminating newline character are discarded.  While reading
the password, echoing and the generation of signals by special
characters is disabled.
@end deffn

flock
@c snarfed from posix.c:1780
@deffn {Scheme Procedure} flock file operation
@deffnx {C Function} scm_flock (file, operation)
Apply or remove an advisory lock on an open file.
@var{operation} specifies the action to be done:

@defvar LOCK_SH
Shared lock.  More than one process may hold a shared lock
for a given file at a given time.
@end defvar
@defvar LOCK_EX
Exclusive lock.  Only one process may hold an exclusive lock
for a given file at a given time.
@end defvar
@defvar LOCK_UN
Unlock the file.
@end defvar
@defvar LOCK_NB
Don't block when locking.  This is combined with one of the
other operations using @code{logior}.  If @code{flock} would
block an @code{EWOULDBLOCK} error is thrown.
@end defvar

The return value is not specified. @var{file} may be an open
file descriptor or an open file descriptor port.

Note that @code{flock} does not lock files across NFS.
@end deffn

sethostname
@c snarfed from posix.c:1805
@deffn {Scheme Procedure} sethostname name
@deffnx {C Function} scm_sethostname (name)
Set the host name of the current processor to @var{name}. May
only be used by the superuser.  The return value is not
specified.
@end deffn

gethostname
@c snarfed from posix.c:1823
@deffn {Scheme Procedure} gethostname
@deffnx {C Function} scm_gethostname ()
Return the host name of the current processor.
@end deffn

gethost
@c snarfed from net_db.c:134
@deffn {Scheme Procedure} gethost [host]
@deffnx {Scheme Procedure} gethostbyname hostname
@deffnx {Scheme Procedure} gethostbyaddr address
@deffnx {C Function} scm_gethost (host)
Look up a host by name or address, returning a host object.  The
@code{gethost} procedure will accept either a string name or an integer
address; if given no arguments, it behaves like @code{gethostent} (see
below).  If a name or address is supplied but the address can not be
found, an error will be thrown to one of the keys:
@code{host-not-found}, @code{try-again}, @code{no-recovery} or
@code{no-data}, corresponding to the equivalent @code{h_error} values.
Unusual conditions may result in errors thrown to the
@code{system-error} or @code{misc_error} keys.
@end deffn

getnet
@c snarfed from net_db.c:216
@deffn {Scheme Procedure} getnet [net]
@deffnx {Scheme Procedure} getnetbyname net-name
@deffnx {Scheme Procedure} getnetbyaddr net-number
@deffnx {C Function} scm_getnet (net)
Look up a network by name or net number in the network database.  The
@var{net-name} argument must be a string, and the @var{net-number}
argument must be an integer.  @code{getnet} will accept either type of
argument, behaving like @code{getnetent} (see below) if no arguments are
given.
@end deffn

getproto
@c snarfed from net_db.c:268
@deffn {Scheme Procedure} getproto [protocol]
@deffnx {Scheme Procedure} getprotobyname name
@deffnx {Scheme Procedure} getprotobynumber number
@deffnx {C Function} scm_getproto (protocol)
Look up a network protocol by name or by number.  @code{getprotobyname}
takes a string argument, and @code{getprotobynumber} takes an integer
argument.  @code{getproto} will accept either type, behaving like
@code{getprotoent} (see below) if no arguments are supplied.
@end deffn

getserv
@c snarfed from net_db.c:334
@deffn {Scheme Procedure} getserv [name [protocol]]
@deffnx {Scheme Procedure} getservbyname name protocol
@deffnx {Scheme Procedure} getservbyport port protocol
@deffnx {C Function} scm_getserv (name, protocol)
Look up a network service by name or by service number, and return a
network service object.  The @var{protocol} argument specifies the name
of the desired protocol; if the protocol found in the network service
database does not match this name, a system error is signalled.

The @code{getserv} procedure will take either a service name or number
as its first argument; if given no arguments, it behaves like
@code{getservent} (see below).
@end deffn

sethost
@c snarfed from net_db.c:385
@deffn {Scheme Procedure} sethost [stayopen]
@deffnx {C Function} scm_sethost (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endhostent}.
Otherwise it is equivalent to @code{sethostent stayopen}.
@end deffn

setnet
@c snarfed from net_db.c:401
@deffn {Scheme Procedure} setnet [stayopen]
@deffnx {C Function} scm_setnet (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endnetent}.
Otherwise it is equivalent to @code{setnetent stayopen}.
@end deffn

setproto
@c snarfed from net_db.c:417
@deffn {Scheme Procedure} setproto [stayopen]
@deffnx {C Function} scm_setproto (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endprotoent}.
Otherwise it is equivalent to @code{setprotoent stayopen}.
@end deffn

setserv
@c snarfed from net_db.c:433
@deffn {Scheme Procedure} setserv [stayopen]
@deffnx {C Function} scm_setserv (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endservent}.
Otherwise it is equivalent to @code{setservent stayopen}.
@end deffn

htons
@c snarfed from socket.c:80
@deffn {Scheme Procedure} htons value
@deffnx {C Function} scm_htons (value)
Convert a 16 bit quantity from host to network byte ordering.
@var{value} is packed into 2 bytes, which are then converted
and returned as a new integer.
@end deffn

ntohs
@c snarfed from socket.c:91
@deffn {Scheme Procedure} ntohs value
@deffnx {C Function} scm_ntohs (value)
Convert a 16 bit quantity from network to host byte ordering.
@var{value} is packed into 2 bytes, which are then converted
and returned as a new integer.
@end deffn

htonl
@c snarfed from socket.c:102
@deffn {Scheme Procedure} htonl value
@deffnx {C Function} scm_htonl (value)
Convert a 32 bit quantity from host to network byte ordering.
@var{value} is packed into 4 bytes, which are then converted
and returned as a new integer.
@end deffn

ntohl
@c snarfed from socket.c:115
@deffn {Scheme Procedure} ntohl value
@deffnx {C Function} scm_ntohl (value)
Convert a 32 bit quantity from network to host byte ordering.
@var{value} is packed into 4 bytes, which are then converted
and returned as a new integer.
@end deffn

inet-aton
@c snarfed from socket.c:135
@deffn {Scheme Procedure} inet-aton address
@deffnx {C Function} scm_inet_aton (address)
Convert an IPv4 Internet address from printable string
(dotted decimal notation) to an integer.  E.g.,

@lisp
(inet-aton "127.0.0.1") @result{} 2130706433
@end lisp
@end deffn

inet-ntoa
@c snarfed from socket.c:158
@deffn {Scheme Procedure} inet-ntoa inetid
@deffnx {C Function} scm_inet_ntoa (inetid)
Convert an IPv4 Internet address to a printable
(dotted decimal notation) string.  E.g.,

@lisp
(inet-ntoa 2130706433) @result{} "127.0.0.1"
@end lisp
@end deffn

inet-netof
@c snarfed from socket.c:178
@deffn {Scheme Procedure} inet-netof address
@deffnx {C Function} scm_inet_netof (address)
Return the network number part of the given IPv4
Internet address.  E.g.,

@lisp
(inet-netof 2130706433) @result{} 127
@end lisp
@end deffn

inet-lnaof
@c snarfed from socket.c:196
@deffn {Scheme Procedure} inet-lnaof address
@deffnx {C Function} scm_lnaof (address)
Return the local-address-with-network part of the given
IPv4 Internet address, using the obsolete class A/B/C system.
E.g.,

@lisp
(inet-lnaof 2130706433) @result{} 1
@end lisp
@end deffn

inet-makeaddr
@c snarfed from socket.c:214
@deffn {Scheme Procedure} inet-makeaddr net lna
@deffnx {C Function} scm_inet_makeaddr (net, lna)
Make an IPv4 Internet address by combining the network number
@var{net} with the local-address-within-network number
@var{lna}.  E.g.,

@lisp
(inet-makeaddr 127 1) @result{} 2130706433
@end lisp
@end deffn

inet-pton
@c snarfed from socket.c:350
@deffn {Scheme Procedure} inet-pton family address
@deffnx {C Function} scm_inet_pton (family, address)
Convert a string containing a printable network address to
an integer address.  Note that unlike the C version of this
function,
the result is an integer with normal host byte ordering.
@var{family} can be @code{AF_INET} or @code{AF_INET6}.  E.g.,

@lisp
(inet-pton AF_INET "127.0.0.1") @result{} 2130706433
(inet-pton AF_INET6 "::1") @result{} 1
@end lisp
@end deffn

inet-ntop
@c snarfed from socket.c:388
@deffn {Scheme Procedure} inet-ntop family address
@deffnx {C Function} scm_inet_ntop (family, address)
Convert a network address into a printable string.
Note that unlike the C version of this function,
the input is an integer with normal host byte ordering.
@var{family} can be @code{AF_INET} or @code{AF_INET6}.  E.g.,

@lisp
(inet-ntop AF_INET 2130706433) @result{} "127.0.0.1"
(inet-ntop AF_INET6 (- (expt 2 128) 1))
  @result{} "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
@end lisp
@end deffn

socket
@c snarfed from socket.c:430
@deffn {Scheme Procedure} socket family style proto
@deffnx {C Function} scm_socket (family, style, proto)
Return a new socket port of the type specified by @var{family},
@var{style} and @var{proto}.  All three parameters are
integers.  Supported values for @var{family} are
@code{AF_UNIX}, @code{AF_INET} and @code{AF_INET6}.
Typical values for @var{style} are @code{SOCK_STREAM},
@code{SOCK_DGRAM} and @code{SOCK_RAW}.

@var{proto} can be obtained from a protocol name using
@code{getprotobyname}.  A value of zero specifies the default
protocol, which is usually right.

A single socket port cannot by used for communication until it
has been connected to another socket.
@end deffn

socketpair
@c snarfed from socket.c:451
@deffn {Scheme Procedure} socketpair family style proto
@deffnx {C Function} scm_socketpair (family, style, proto)
Return a pair of connected (but unnamed) socket ports of the
type specified by @var{family}, @var{style} and @var{proto}.
Many systems support only socket pairs of the @code{AF_UNIX}
family.  Zero is likely to be the only meaningful value for
@var{proto}.
@end deffn

getsockopt
@c snarfed from socket.c:476
@deffn {Scheme Procedure} getsockopt sock level optname
@deffnx {C Function} scm_getsockopt (sock, level, optname)
Return the value of a particular socket option for the socket
port @var{sock}.  @var{level} is an integer code for type of
option being requested, e.g., @code{SOL_SOCKET} for
socket-level options.  @var{optname} is an integer code for the
option required and should be specified using one of the
symbols @code{SO_DEBUG}, @code{SO_REUSEADDR} etc.

The returned value is typically an integer but @code{SO_LINGER}
returns a pair of integers.
@end deffn

setsockopt
@c snarfed from socket.c:544
@deffn {Scheme Procedure} setsockopt sock level optname value
@deffnx {C Function} scm_setsockopt (sock, level, optname, value)
Set the value of a particular socket option for the socket
port @var{sock}.  @var{level} is an integer code for type of option
being set, e.g., @code{SOL_SOCKET} for socket-level options.
@var{optname} is an
integer code for the option to set and should be specified using one of
the symbols @code{SO_DEBUG}, @code{SO_REUSEADDR} etc.
@var{value} is the value to which the option should be set.  For
most options this must be an integer, but for @code{SO_LINGER} it must
be a pair.

The return value is unspecified.
@end deffn

shutdown
@c snarfed from socket.c:646
@deffn {Scheme Procedure} shutdown sock how
@deffnx {C Function} scm_shutdown (sock, how)
Sockets can be closed simply by using @code{close-port}. The
@code{shutdown} procedure allows reception or transmission on a
connection to be shut down individually, according to the parameter
@var{how}:

@table @asis
@item 0
Stop receiving data for this socket.  If further data arrives,  reject it.
@item 1
Stop trying to transmit data from this socket.  Discard any
data waiting to be sent.  Stop looking for acknowledgement of
data already sent; don't retransmit it if it is lost.
@item 2
Stop both reception and transmission.
@end table

The return value is unspecified.
@end deffn

connect
@c snarfed from socket.c:789
@deffn {Scheme Procedure} connect sock fam address . args
@deffnx {C Function} scm_connect (sock, fam, address, args)
Initiate a connection from a socket using a specified address
family to the address
specified by @var{address} and possibly @var{args}.
The format required for @var{address}
and @var{args} depends on the family of the socket.

For a socket of family @code{AF_UNIX},
only @var{address} is specified and must be a string with the
filename where the socket is to be created.

For a socket of family @code{AF_INET},
@var{address} must be an integer IPv4 host address and
@var{args} must be a single integer port number.

For a socket of family @code{AF_INET6},
@var{address} must be an integer IPv6 host address and
@var{args} may be up to three integers:
port [flowinfo] [scope_id],
where flowinfo and scope_id default to zero.

The return value is unspecified.
@end deffn

bind
@c snarfed from socket.c:848
@deffn {Scheme Procedure} bind sock fam address . args
@deffnx {C Function} scm_bind (sock, fam, address, args)
Assign an address to the socket port @var{sock}.
Generally this only needs to be done for server sockets,
so they know where to look for incoming connections.  A socket
without an address will be assigned one automatically when it
starts communicating.

The format of @var{address} and @var{args} depends
on the family of the socket.

For a socket of family @code{AF_UNIX}, only @var{address}
is specified and must be a string with the filename where
the socket is to be created.

For a socket of family @code{AF_INET}, @var{address}
must be an integer IPv4 address and @var{args}
must be a single integer port number.

The values of the following variables can also be used for
@var{address}:

@defvar INADDR_ANY
Allow connections from any address.
@end defvar

@defvar INADDR_LOOPBACK
The address of the local host using the loopback device.
@end defvar

@defvar INADDR_BROADCAST
The broadcast address on the local network.
@end defvar

@defvar INADDR_NONE
No address.
@end defvar

For a socket of family @code{AF_INET6}, @var{address}
must be an integer IPv6 address and @var{args}
may be up to three integers:
port [flowinfo] [scope_id],
where flowinfo and scope_id default to zero.

The return value is unspecified.
@end deffn

listen
@c snarfed from socket.c:881
@deffn {Scheme Procedure} listen sock backlog
@deffnx {C Function} scm_listen (sock, backlog)
Enable @var{sock} to accept connection
requests.  @var{backlog} is an integer specifying
the maximum length of the queue for pending connections.
If the queue fills, new clients will fail to connect until
the server calls @code{accept} to accept a connection from
the queue.

The return value is unspecified.
@end deffn

accept
@c snarfed from socket.c:993
@deffn {Scheme Procedure} accept sock
@deffnx {C Function} scm_accept (sock)
Accept a connection on a bound, listening socket.
If there
are no pending connections in the queue, wait until
one is available unless the non-blocking option has been
set on the socket.

The return value is a
pair in which the @emph{car} is a new socket port for the
connection and
the @emph{cdr} is an object with address information about the
client which initiated the connection.

@var{sock} does not become part of the
connection and will continue to accept new requests.
@end deffn

getsockname
@c snarfed from socket.c:1020
@deffn {Scheme Procedure} getsockname sock
@deffnx {C Function} scm_getsockname (sock)
Return the address of @var{sock}, in the same form as the
object returned by @code{accept}.  On many systems the address
of a socket in the @code{AF_FILE} namespace cannot be read.
@end deffn

getpeername
@c snarfed from socket.c:1042
@deffn {Scheme Procedure} getpeername sock
@deffnx {C Function} scm_getpeername (sock)
Return the address that @var{sock}
is connected to, in the same form as the object returned by
@code{accept}.  On many systems the address of a socket in the
@code{AF_FILE} namespace cannot be read.
@end deffn

recv!
@c snarfed from socket.c:1077
@deffn {Scheme Procedure} recv! sock buf [flags]
@deffnx {C Function} scm_recv (sock, buf, flags)
Receive data from a socket port.
@var{sock} must already
be bound to the address from which data is to be received.
@var{buf} is a string into which
the data will be written.  The size of @var{buf} limits
the amount of
data which can be received: in the case of packet
protocols, if a packet larger than this limit is encountered
then some data
will be irrevocably lost.

The optional @var{flags} argument is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

The value returned is the number of bytes read from the
socket.

Note that the data is read directly from the socket file
descriptor:
any unread buffered port data is ignored.
@end deffn

send
@c snarfed from socket.c:1120
@deffn {Scheme Procedure} send sock message [flags]
@deffnx {C Function} scm_send (sock, message, flags)
Transmit the string @var{message} on a socket port @var{sock}.
@var{sock} must already be bound to a destination address.  The
value returned is the number of bytes transmitted --
it's possible for
this to be less than the length of @var{message}
if the socket is
set to be non-blocking.  The optional @var{flags} argument
is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

Note that the data is written directly to the socket
file descriptor:
any unflushed buffered port data is ignored.
@end deffn

recvfrom!
@c snarfed from socket.c:1171
@deffn {Scheme Procedure} recvfrom! sock str [flags [start [end]]]
@deffnx {C Function} scm_recvfrom (sock, str, flags, start, end)
Return data from the socket port @var{sock} and also
information about where the data was received from.
@var{sock} must already be bound to the address from which
data is to be received.  @code{str}, is a string into which the
data will be written.  The size of @var{str} limits the amount
of data which can be received: in the case of packet protocols,
if a packet larger than this limit is encountered then some
data will be irrevocably lost.

The optional @var{flags} argument is a value or bitwise OR of
@code{MSG_OOB}, @code{MSG_PEEK}, @code{MSG_DONTROUTE} etc.

The value returned is a pair: the @emph{car} is the number of
bytes read from the socket and the @emph{cdr} an address object
in the same form as returned by @code{accept}.  The address
will given as @code{#f} if not available, as is usually the
case for stream sockets.

The @var{start} and @var{end} arguments specify a substring of
@var{str} to which the data should be written.

Note that the data is read directly from the socket file
descriptor: any unread buffered port data is ignored.
@end deffn

sendto
@c snarfed from socket.c:1236
@deffn {Scheme Procedure} sendto sock message fam address . args_and_flags
@deffnx {C Function} scm_sendto (sock, message, fam, address, args_and_flags)
Transmit the string @var{message} on the socket port
@var{sock}.  The
destination address is specified using the @var{fam},
@var{address} and
@var{args_and_flags} arguments, in a similar way to the
@code{connect} procedure.  @var{args_and_flags} contains
the usual connection arguments optionally followed by
a flags argument, which is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

The value returned is the number of bytes transmitted --
it's possible for
this to be less than the length of @var{message} if the
socket is
set to be non-blocking.
Note that the data is written directly to the socket
file descriptor:
any unflushed buffered port data is ignored.
@end deffn

regexp?
@c snarfed from regex-posix.c:106
@deffn {Scheme Procedure} regexp? obj
@deffnx {C Function} scm_regexp_p (obj)
Return @code{#t} if @var{obj} is a compiled regular expression,
or @code{#f} otherwise.
@end deffn

make-regexp
@c snarfed from regex-posix.c:151
@deffn {Scheme Procedure} make-regexp pat . flags
@deffnx {C Function} scm_make_regexp (pat, flags)
Compile the regular expression described by @var{pat}, and
return the compiled regexp structure.  If @var{pat} does not
describe a legal regular expression, @code{make-regexp} throws
a @code{regular-expression-syntax} error.

The @var{flags} arguments change the behavior of the compiled
regular expression.  The following flags may be supplied:

@table @code
@item regexp/icase
Consider uppercase and lowercase letters to be the same when
matching.
@item regexp/newline
If a newline appears in the target string, then permit the
@samp{^} and @samp{$} operators to match immediately after or
immediately before the newline, respectively.  Also, the
@samp{.} and @samp{[^...]} operators will never match a newline
character.  The intent of this flag is to treat the target
string as a buffer containing many lines of text, and the
regular expression as a pattern that may match a single one of
those lines.
@item regexp/basic
Compile a basic (``obsolete'') regexp instead of the extended
(``modern'') regexps that are the default.  Basic regexps do
not consider @samp{|}, @samp{+} or @samp{?} to be special
characters, and require the @samp{@{...@}} and @samp{(...)}
metacharacters to be backslash-escaped (@pxref{Backslash
Escapes}).  There are several other differences between basic
and extended regular expressions, but these are the most
significant.
@item regexp/extended
Compile an extended regular expression rather than a basic
regexp.  This is the default behavior; this flag will not
usually be needed.  If a call to @code{make-regexp} includes
both @code{regexp/basic} and @code{regexp/extended} flags, the
one which comes last will override the earlier one.
@end table
@end deffn

regexp-exec
@c snarfed from regex-posix.c:217
@deffn {Scheme Procedure} regexp-exec rx str [start [flags]]
@deffnx {C Function} scm_regexp_exec (rx, str, start, flags)
Match the compiled regular expression @var{rx} against
@code{str}.  If the optional integer @var{start} argument is
provided, begin matching from that position in the string.
Return a match structure describing the results of the match,
or @code{#f} if no match could be found.

The @var{flags} arguments change the matching behavior.
The following flags may be supplied:

@table @code
@item regexp/notbol
Operator @samp{^} always fails (unless @code{regexp/newline}
is used).  Use this when the beginning of the string should
not be considered the beginning of a line.
@item regexp/noteol
Operator @samp{$} always fails (unless @code{regexp/newline}
is used).  Use this when the end of the string should not be
considered the end of a line.
@end table
@end deffn
